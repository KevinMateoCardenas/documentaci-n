\documentclass[executivepaper]{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel} % Establece el idioma español
\usepackage{csquotes} % Carga el paquete csquotes
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[left=1.00cm, right=1.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}
\setlength{\parindent}{0.5in}
\usepackage{setspace}
\doublespacing

\lstset{
    inputencoding=utf8,
    language=[Sharp]C,
    basicstyle=\ttfamily,
    columns=fullflexible
}

% Define colores para el código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuración de lstlisting
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

% Configuración del paquete hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=gray,
}

\lstset{style=mystyle}

\renewcommand{\baselinestretch}{1.5}

\newtheorem{propo}{Proposición}[section]
\newtheorem{lema}[propo]{Lema}
\newtheorem{teo}[propo]{Teorema}
\newtheorem{coro}[propo]{Corolario}
\newtheorem{defi}[propo]{Definición}
\newtheorem{obs}[propo]{Observación}
\newtheorem{ejemplo}[propo]{Ejemplo}

\newcommand{\Al}{(\mathcal{A},\mathds{F},\odot)}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\R}{\mathds{R}}
\newcommand{\N}{\mathds{N}}
\newcommand{\fu}{f:D\longrightarrow \mathds{R}}
\newcommand{\fun}{f:[a,b]\longrightarrow \mathds{R}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\F}{\mathds{F}}
\newcommand{\op}{``}
\newcommand{\cl}{''}
\newcommand{\po}{^}
\newcommand{\X}{\mathbf{X}}
\newcommand{\Q}{\matbbb{Q}}

\title{Curso de C\# en .Net}
\author{Kevin Cárdenas}

\begin{document}
\begin{titlepage}
   \begin{center}
        {\Huge \textbf{C\# en .NET}}
        \\[19cm]
        
        \large\emph{Autor:}\\
        Kevin Cárdenas.
        \\
        2023
    \end{center}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introducción}
C\# (pronunciado \enquote*{C Sharp}) es un lenguaje de programación de propósito general, moderno y orientado a objetos, desarrollado por Microsoft como parte de su plataforma .NET. C\# se utiliza para desarrollar aplicaciones de escritorio, aplicaciones web, aplicaciones móviles y videojuegos.

C\# fue creado en 2000 por el programador danés Anders Hejlsberg, quien anteriormente había trabajado en el desarrollo del lenguaje de programación Turbo Pascal y del entorno de desarrollo integrado (IDE) Borland Delphi. La primera versión pública de C\# fue lanzada en 2002 como parte de la plataforma .NET Framework.

C\# es un lenguaje diseñado para ser fácil de leer, escribir y mantener. Está diseñado para ser seguro y robusto, y su sintaxis se asemeja a la de otros lenguajes de programación populares, como Java y C++. C\# incluye muchas características avanzadas, como la recolección de basura, el control de excepciones, los delegados y los eventos, y los genéricos, que lo hacen muy potente y versátil.

C\# se utiliza comúnmente junto con el IDE Visual Studio de Microsoft, que proporciona herramientas para la edición de código, la depuración, la compilación y el despliegue de aplicaciones. Además, C\# es compatible con múltiples plataformas, incluyendo Windows, Linux y macOS, lo que lo hace ideal para el desarrollo de aplicaciones multiplataforma.

C\# se inspiró en varios lenguajes de programación anteriores, incluidos C++, Java y Delphi, entre otros. El objetivo de C\# era combinar lo mejor de estos lenguajes en un solo lenguaje que fuera fácil de aprender y usar.

C\# se basa en gran medida en la sintaxis de C++, con algunas diferencias clave para hacer que el lenguaje sea más seguro y fácil de usar. C\# utiliza palabras clave específicas para definir tipos de datos, como \enquote*{int} para enteros y \enquote*{string} para cadenas. También incluye soporte para la herencia y el polimorfismo, que son características clave de la programación orientada a objetos.

Además de C++, C\# también se inspiró en Java. De hecho, la sintaxis de C\# es muy similar a la de Java, lo que hace que sea fácil para los desarrolladores que ya conocen Java aprender C\#. C\# también utiliza el modelo de máquina virtual de Java, que permite que el código C\# se ejecute en cualquier plataforma que tenga una implementación de la máquina virtual de .NET.

En C\#, el tipado se refiere a la definición del tipo de datos que puede contener una variable. C\# es un lenguaje de programación fuertemente tipado, lo que significa que todas las variables deben tener un tipo de datos definido antes de que se puedan utilizar. Esto es diferente a los lenguajes de programación débilmente tipados, como JavaScript, que permiten que las variables cambien de tipo de datos dinámicamente.

En C\#, hay dos tipos de datos básicos: tipos de valor y tipos de referencia. Los tipos de valor contienen directamente el valor de los datos, como los números enteros, los números de punto flotante y los booleanos. Los tipos de referencia, por otro lado, contienen una referencia a un objeto en la memoria, como una cadena, una matriz o un objeto personalizado.

C\# también admite el uso de tipos genéricos, que permiten definir una clase o un método que puede trabajar con diferentes tipos de datos. Por ejemplo, una lista genérica puede contener cualquier tipo de datos, como enteros, cadenas o objetos personalizados.

Además, C\# permite la definición de tipos de datos personalizados a través de las estructuras y clases. Las estructuras son tipos de valor que se utilizan para almacenar datos relacionados, como un punto en el espacio tridimensional. Las clases, por otro lado, son tipos de referencia que se utilizan para definir objetos complejos con propiedades, métodos y eventos.

Existen convenciones para nombrar variables y otros elementos del código que ayudan a que el código sea más legible y fácil de entender. Algunas de las convenciones de nomenclatura más comunes son

\begin{itemize}
    \item CamelCase: es la convención más comúnmente utilizada. En este caso, la primera letra de la primera palabra se escribe en minúscula y la primera letra de cada palabra subsiguiente se escribe en mayúscula. Por ejemplo, \enquote*{nombreDeVariable} o \enquote*{miVariableNumeroUno}. Esta convención se utiliza comúnmente para nombrar \textbf{variables y métodos.}
    \item PascalCase: en este caso, la primera letra de cada palabra se escribe en mayúscula, sin espacios ni guiones bajos. Por ejemplo, \enquote*{NombreDeVariable} \enquote*{MiVariableNumeroUno}. Esta convención se utiliza a menudo para nombrar \textbf{clases}.
    \item Upper\_Case: en este caso, todas las letras se escriben en mayúscula. Esta convención se utiliza generalmente para nombrar constantes. Por ejemplo, \enquote*{VALOR\_MAXIMO} o \enquote*{PI}. Eta convención se utiliza comúnmente para nombrar \textbf{constantes}.
    \item snake\_case: en este caso, se utiliza una separación con guión bajo entre las palabras, todas en minúsculas. Por ejemplo, \enquote*{nombre\_de\_variable} o \enquote*{mi\_variable\_numero\_uno}. Esta convención se utiliza a menudo en otros lenguajes de programación, como Python, y algunos desarrolladores la usan para nombrar \textbf{variables y métodos.}
\end{itemize}

C\# es un lenguaje de programación muy completo que está diseñado para trabajar con programación orientada a objetos, pero también permite la programación funcional. Es importante conocer los principios de la orientación a objetos para poder programar eficientemente en C\#, y también es posible utilizar conceptos de la programación funcional como inmutabilidad, funciones de orden superior y lambdas.

\subsection{Gramatica y Tipos}

Para iniciar un programa en C\# es necesario crear un archivo con extensión \verb|.cs| que contenga el código fuente del programa. El archivo debe contener una clase con un método llamado \verb|Main|, que es el punto de entrada del programa. La estructura básica de un programa en C\# se ve así:

\begin{lstlisting}
using System;

class Program{
    static void Main(string[] args){
        // code
    }
}
\end{lstlisting}

En la primera línea se encuentra la directiva \verb|using System|, que indica que se utilizarán clases del espacio de nombres \verb|System|. Luego se define la clase \verb|Program|, que contiene el método \verb|Main| con un parámetro \verb|args| de tipo \verb|string[]|, que representa los argumentos pasados al programa desde la línea de comandos.

Dentro del método \verb|Main| se escribe el código que se quiere ejecutar al iniciar el programa. Por ejemplo, si se quiere imprimir un mensaje por consola, se puede utilizar el método \verb|Console.WriteLine| de la clase \verb|System|:

\begin{lstlisting}
using System;

class Program{
    static void Main(string[] args){
        Console.WriteLine("Hola, mundo!");
    }
}
\end{lstlisting}

Para ejecutar el programa, se debe compilar el archivo \verb|.cs| utilizando un compilador de C\# como el IDE Visual Studio, y luego, si es el caso, ejecutar el archivo resultante con extensión \verb|.exe|.

En  C\#, las variables deben declararse antes de usarse y se pueden inicializar con un valor. La sintaxis básica de una declaración de variable en  C\# es la siguiente:

\begin{lstlisting}
tipo nombre_variable;
\end{lstlisting}

Donde \verb|tipo| es el tipo de variable y \verb|nombre_variable| es el nombre que se le da a la variable.

Para inicializar una variable con un valor, se puede usar la siguiente sintaxis:

\begin{lstlisting}
tipo nombre_variable = valor_inicial;
\end{lstlisting}

Donde \verb|valor_inicial| es el valor que se le asigna a la variable al momento de su inicialización.

En  C\#, también es posible declarar varias variables del mismo tipo en una sola línea, separando cada nombre de variable con una coma. Por ejemplo:

\begin{lstlisting}
int a, b, c;
\end{lstlisting}

También es posible inicializar varias variables en una sola línea, separando cada par de nombre de variable y valor inicial con una coma. Por ejemplo:

\begin{lstlisting}
int a = 1, b = 2, c = 3;
\end{lstlisting}

Aquí te presento una lista más precisa de los tipos de variables que existen en C\#:

\begin{itemize}
\item Tipos numéricos: \verb|int|, \verb|long|, \verb|short|, \verb|byte|, \verb|float|, \verb|double|, \verb|decimal|.
\item Tipo de caracteres: \verb|char|.
\item Tipo booleano: \verb|bool|.
\item Tipos de referencia: \verb|string|, \verb|object| y otros tipos definidos por el usuario.
\item Tipos de colecciones: \verb|array|, \verb|List<T>|, \verb|Dictionary<TKey, TValue>| y otros tipos de colecciones definidos por el usuario.
\item Tipo implícito: \verb|var|.
\end{itemize}

En cuanto a la gramática de las variables en  C\#, hay algunas reglas que se deben seguir:

\begin{itemize}
\item Los nombres de las variables deben comenzar con una letra o un guión bajo (\verb|_|), seguidos de cero o más letras, dígitos o guiones bajos.
\item Los nombres de las variables no pueden ser iguales a palabras clave de  C\#.
\item Los nombres de las variables son sensibles a mayúsculas y minúsculas.
\end{itemize}

Es importante tener en cuenta que los nombres de las variables deben ser descriptivos y representar el propósito de la variable en el código.

En cuanto a los tipos de variables en  C\#, hay varios tipos numéricos (enteros y decimales), tipos de caracteres, tipos booleanos y tipos de referencia. Cada tipo de variable tiene un rango de valores que puede almacenar y una precisión determinada.

\subsection{Operadores}

En C\#, los operadores se utilizan para realizar operaciones matemáticas, lógicas, de comparación y de asignación. A continuación, veamos algunos de los operadores más comunes en C\#:

\subsubsection*{Operadores aritméticos}

Los operadores aritméticos se utilizan para realizar operaciones matemáticas básicas como la suma, la resta, la multiplicación y la división. A continuación, veamosn los operadores aritméticos en C\#:

\begin{itemize}
    \item \textbf{+}: Suma dos valores. Ejemplo: \emph{int resultado = 5 + 3;} // resultado es igual a 8.
    \item \textbf{-}: Resta dos valores. Ejemplo: \emph{int resultado = 5 - 3;} // resultado es igual a 2.
    \item \textbf{*}: Multiplica dos valores. Ejemplo: \emph{int resultado = 5 * 3;} // resultado es igual a 15.
    \item \textbf{/}: Divide dos valores. Ejemplo: \emph{int resultado = 15 / 3;} // resultado es igual a 5.
    \item \textbf{\%}: Devuelve el resto de una división. Ejemplo: \emph{int resultado = 15 \% 4;} // resultado es igual a 3.
\end{itemize}

\subsubsection*{Operadores de asignación}

Los operadores de asignación se utilizan para asignar un valor a una variable. A continuación, veamosn los operadores de asignación en C\#:

\begin{itemize}
    \item \textbf{=}: Asigna un valor a una variable. Ejemplo: \emph{int edad = 25;}
    \item \textbf{+=}: Incrementa el valor de una variable. Ejemplo: \emph{int contador = 0; contador += 1;} // contador es igual a 1.
    \item \textbf{-=}: Decrementa el valor de una variable. Ejemplo: \emph{int contador = 1; contador -= 1;} // contador es igual a 0.
    \item \textbf{*=}: Multiplica el valor de una variable. Ejemplo: \emph{int resultado = 5; resultado *= 3;} // resultado es igual a 15.
    \item \textbf{/=}: Divide el valor de una variable. Ejemplo: \emph{int resultado = 15; resultado /= 3;} // resultado es igual a 5.
    \item \textbf{\%=}: Asigna el resto de una división a una variable. Ejemplo: \emph{int resultado = 15; resultado \%= 4;} // resultado es igual a 3.
    \end{itemize}

\subsubsection*{Operadores de comparación}

Los operadores de comparación en C\# se utilizan para comparar dos valores y evaluar si se cumple o no una condición. Los operadores de comparación devuelven un valor booleano (verdadero o falso) como resultado.

Algunos de los operadores de comparación en C\# son:

\begin{itemize}
\item \textbf{==}: este operador se utiliza para comprobar si dos valores son iguales.
\item \textbf{!=}: este operador se utiliza para comprobar si dos valores son diferentes.
\item \textbf{>}: este operador se utiliza para comprobar si un valor es mayor que otro.
\item \textbf{<}: este operador se utiliza para comprobar si un valor es menor que otro.
\item \textbf{>=}: este operador se utiliza para comprobar si un valor es mayor o igual que otro.
\item \textbf{<=}: este operador se utiliza para comprobar si un valor es menor o igual que otro.
\end{itemize}

Veamos algunos ejemplos de cómo se utilizan estos operadores en C\#:

\begin{lstlisting}
int edad = 25;
bool esMayorDeEdad = edad >= 18; // Devuelve true
bool esMenorDeEdad = edad < 18; // Devuelve false

string nombre = "Juan";
string apellido = "Perez";
bool tienenElMismoNombre = nombre == apellido; // Devuelve false
bool tienenDistintoNombre = nombre != apellido; // Devuelve true
\end{lstlisting}

En el primer ejemplo, se utiliza el operador \textbf{>=} para comprobar si la variable \emph{edad} es mayor o igual a 18. Como el valor de \emph{edad} es 25, el resultado de la operación es \emph{true}, lo que significa que la variable \emph{esMayorDeEdad} toma el valor de \emph{true}.

En el segundo ejemplo, se utiliza el operador \textbf{<} para comprobar si la variable \emph{edad} es menor que 18. Como el valor de \emph{edad} es 25, el resultado de la operación es \emph{false}, lo que significa que la variable \emph{esMenorDeEdad} toma el valor de \emph{false}.

En el tercer ejemplo, se comparan dos variables de tipo \emph{string}, \emph{nombre} y \emph{apellido}, utilizando el operador \textbf{==}. Como los valores de las variables son distintos, el resultado de la operación es \emph{false}, lo que significa que la variable \emph{tienenElMismoNombre} toma el valor de \emph{false}.

En el cuarto ejemplo, se utiliza el operador \textbf{!=} para comprobar si las variables \emph{nombre} y \emph{apellido} son distintas. Como los valores de las variables son distintos, el resultado de la operación es \emph{true}, lo que significa que la variable \emph{tienenDistintoNombre} toma el valor de \emph{true}.

\subsection{Bucles, Sentencias if y Switch}

En C\#, existen varios tipos de bucles que permiten repetir un bloque de código un determinado número de veces o mientras se cumpla una condición. A continuación, veamos los principales tipos de bucles en C\#:

\subsubsection*{Bucle \emph{for}}

El bucle \verb|for| permite repetir un bloque de código un número determinado de veces. Su sintaxis es la siguiente:

\begin{lstlisting}
for (inicializacion; condicionn; expresion de actualizacion) {
// Codigo a repetir
}
\end{lstlisting}

La \emph{inicialización} se utiliza para declarar y asignar valores a una variable de control que se utiliza en el bucle. La \emph{condición} se evalúa al comienzo de cada iteración y si es verdadera, se ejecuta el código dentro del bucle. La \emph{expresión de actualización} se utiliza para modificar el valor de la variable de control después de cada iteración.

Por ejemplo, el siguiente bucle \verb|for| imprime los números del 1 al 10:

\begin{lstlisting}
for (int i = 1; i <= 10; i++) {
Console.WriteLine(i);
}
\end{lstlisting}

\subsubsection*{Bucle foreach}

El bucle foreach en C\# es utilizado para iterar sobre los elementos de una colección o arreglo sin la necesidad de conocer el número de elementos previamente. Su sintaxis es la siguiente:

\begin{lstlisting}
foreach (tipoDeElemento variable in coleccion) {
// Code
}
\end{lstlisting}

Donde \emph{tipoDeElemento} es el tipo de datos de cada elemento de la colección, \emph{variable} es una variable que se utiliza para representar cada elemento de la colección y \emph{coleccion} es la colección o arreglo sobre el que se va a iterar.

El bucle foreach es una forma más sencilla y legible de iterar sobre los elementos de una colección o arreglo en comparación con el bucle for tradicional. Además, también evita errores comunes como desbordamientos de índice o intentos de acceder a elementos que no existen en la colección.

Te doy un ejemplo:
\begin{lstlisting}
List<string> nombres = new List<string>() { "Juan", "Pedro", "Maria", "Lucas" };

foreach (string nombre in nombres){
    Console.WriteLine(nombre);
}
\end{lstlisting}

\subsubsection*{Bucle \emph{while}}

El bucle \verb|while| permite repetir un bloque de código mientras se cumpla una condición. Su sintaxis es la siguiente:

\begin{lstlisting}
while (condicion) {
// Codigo a repetir
}
\end{lstlisting}

La \emph{condición} se evalúa al comienzo de cada iteración y si es verdadera, se ejecuta el código dentro del bucle. Si la condición es falsa, el bucle se detiene.

Por ejemplo, el siguiente bucle \verb|while| imprime los números del 1 al 10:

\begin{lstlisting}
int i = 1;
while (i <= 10) {
Console.WriteLine(i);
i++;
}
\end{lstlisting}

\subsubsection*{Bucle \emph{do-while}}

El bucle \verb|do-while| permite repetir un bloque de código al menos una vez y mientras se cumpla una condición. Su sintaxis es la siguiente:

\begin{lstlisting}
do {
// Codigo a repetir
} while (condicion);
\end{lstlisting}

El código dentro del bucle se ejecuta al menos una vez, y luego la \emph{condición} se evalúa. Si es verdadera, se vuelve a ejecutar el código dentro del bucle. Si la condición es falsa, el bucle se detiene.

Por ejemplo, el siguiente bucle \verb|do-while| imprime los números del 1 al 10:

\begin{lstlisting}
int i = 1;
do {
Console.WriteLine(i);
i++;
} while (i <= 10);
\end{lstlisting}

\subsubsection*{Sentencia if - else if - else}
La sentencia if-elif-else es una estructura condicional en programación que permite ejecutar diferentes bloques de código dependiendo del valor de una expresión booleana. La sintaxis en C\# de la sentencia if-elif-else es la siguiente:
\begin{lstlisting}
if (expresion_booleana1){
    // code
}
else if (expresion_booleana2){
    // code
}
else{
    // code
\end{lstlisting}
En esta estructura, se evalúa primero la expresión booleana1. Si esta expresión es verdadera, se ejecuta el bloque de código correspondiente. Si es falsa, se evalúa la expresión booleana2. Si esta es verdadera, se ejecuta el bloque de código correspondiente. Si es falsa, se ejecuta el bloque de código en la cláusula else.

Es importante destacar que la sentencia if-elif-else puede tener tantas cláusulas elif como sea necesario, y que las expresiones booleanas pueden ser complejas, incluyendo operadores lógicos y aritméticos, así como llamadas a funciones que devuelvan un valor booleano.

Un ejemplo de uso de la sentencia if-elif-else podría ser el siguiente:
\begin{lstlisting}
int edad = 25;

if (edad < 18){
    Console.WriteLine("Eres menor de edad");
}
else if (edad >= 18 && edad < 65){
    Console.WriteLine("Eres adulto");
}
else{
    Console.WriteLine("Eres mayor de edad");
}
\end{lstlisting}
En la primera línea se declara la variable \enquote*{edad} y se le asigna un valor de 25. Luego, se utiliza la sentencia if para evaluar si la edad es menor a 18, en cuyo caso se imprime por pantalla el mensaje \enquote*{Eres menor de edad}. Si la edad no es menor a 18, se evalúa si la edad se encuentra en el rango de 18 a 64 años utilizando la sentencia else if. Si la edad está dentro de ese rango, se imprime por pantalla el mensaje \enquote*{Eres adulto}. Si la edad no es menor a 18 y no se encuentra en el rango de 18 a 64 años, se asume que es mayor de 65 años y se imprime el mensaje \enquote*{Eres mayor de edad} utilizando la sentencia else.

\subsubsection*{Sentencia switch}
La sentencia switch es otra estructura condicional en C\# que permite ejecutar diferentes bloques de código dependiendo del valor de una expresión. La sintaxis de la sentencia switch es la siguiente:
\begin{lstlisting}
switch (expresion){
    case valor1:
        // code
        break;
    case valor2:
        // code
        break;
    // otros casos
    default:
        // code
}
\end{lstlisting}
En esta estructura, se evalúa la expresión y se compara su valor con los distintos valores especificados en los casos. Si la expresión coincide con alguno de los valores, se ejecuta el bloque de código correspondiente. Si no coincide con ninguno de los valores, se ejecuta el bloque de código en la cláusula default.

Es importante destacar que la sentencia switch solo puede utilizarse para comparar expresiones que se puedan evaluar como enteros, caracteres, cadenas de texto o enumeraciones.

Un ejemplo de uso de la sentencia switch podría ser el siguiente:
\begin{lstlisting}
int diaDeLaSemana = 3;

switch (diaDeLaSemana){
    case 1:
        Console.WriteLine("Lunes");
        break;
    case 2:
        Console.WriteLine("Martes");
        break;
    case 3:
        Console.WriteLine("Miercoles");
        break;
    case 4:
        Console.WriteLine("Jueves");
        break;
    case 5:
        Console.WriteLine("Viernes");
        break;
    case 6:
        Console.WriteLine("Sabado");
        break;
    case 7:
        Console.WriteLine("Domingo");
        break;
    default:
        Console.WriteLine("Valor invalido");
        break;
}
\end{lstlisting}

El código que utiliza la sentencia switch se podría expresar en términos de if-else de la siguiente manera:

\begin{lstlisting}
int diaDeLaSemana = 3;

if (diaDeLaSemana == 1){
    Console.WriteLine("Lunes");
}
else if (diaDeLaSemana == 2){
    Console.WriteLine("Martes");
}
else if (diaDeLaSemana == 3){
    Console.WriteLine("Miercoles");
}
else if (diaDeLaSemana == 4){
    Console.WriteLine("Jueves");
}
else if (diaDeLaSemana == 5){
    Console.WriteLine("Viernes");
}
else if (diaDeLaSemana == 6){
    Console.WriteLine("Sabado");
}
else if (diaDeLaSemana == 7){
    Console.WriteLine("Domingo");
}
else{
    Console.WriteLine("Valor invalido");
}
\end{lstlisting}
En ese sentido, podemos comparar cual es más legible o más útil, en el fondo hacen lo mismo, la diferencia es la legibilidad y la facilidad de mantenimiento del código.

En general, el uso de la sentencia switch es más adecuado cuando se tienen múltiples casos que deben ser evaluados. El código es más compacto y fácil de leer, ya que se evita tener una gran cantidad de sentencias if-else anidadas. Además, el uso de la sentencia switch permite una ejecución más rápida del código, ya que el compilador puede optimizar la estructura de la sentencia para hacerla más eficiente.

Por otro lado, el uso de una serie de sentencias if-else puede ser más adecuado cuando se tienen condiciones complejas y varias opciones que deben ser evaluadas. El código es más detallado y es más fácil de entender cómo se están evaluando las diferentes opciones. Sin embargo, el uso excesivo de sentencias if-else puede hacer que el código sea más difícil de leer y mantener, especialmente si hay muchas condiciones anidadas.

\subsection{Metodos y funciones}

En C\#, un método es una acción que se puede realizar sobre un objeto o una instancia de una clase. Por otro lado, una función es una operación que se realiza y devuelve un valor.

Existen diferentes tipos de funciones y métodos en C\#, a continuación, veamos algunos de ellos:

\subsubsection*{Funciones y métodos estáticos}

Los métodos estáticos se definen en una clase y se pueden llamar sin necesidad de instanciar un objeto de dicha clase. Por lo tanto, se pueden usar en cualquier parte del código sin tener que crear un objeto primero. Por otro lado, una función estática es una función que no tiene acceso a las propiedades de un objeto y solo utiliza los parámetros que se le pasan.

A continuación, veamos un ejemplo de cómo se define un método estático en C\#:

\begin{lstlisting}
public static int Sum(int a, int b){
    return a + b;
}
\end{lstlisting}

En este ejemplo, el método \emph{Sum} se define como \emph{static}, lo que significa que se puede llamar sin tener que crear una instancia de la clase. El método toma dos argumentos de tipo \emph{int} y devuelve la suma de estos dos valores.

\subsubsection*{Métodos de instancia}

Los métodos de instancia son métodos que solo se pueden llamar en una instancia de una clase. Es decir, se tiene que crear un objeto primero antes de poder llamar al método.

A continuación, veamos un ejemplo de cómo se define un método de instancia en C\#:

\begin{lstlisting}
public class Calculator{
    public int Sum(int a, int b){
        return a + b;
        }
    }
\end{lstlisting}

En este ejemplo, se define una clase llamada \emph{Calculator} que contiene un método llamado \emph{Sum}. Este método toma dos argumentos de tipo \emph{int} y devuelve la suma de estos dos valores.

\subsubsection*{Métodos y funciones con parámetros opcionales}

En C\#, se pueden definir métodos y funciones que tengan parámetros opcionales. Esto significa que se pueden llamar sin especificar todos los argumentos, y los argumentos que no se especifican utilizarán valores predeterminados.

A continuación, veamos un ejemplo de cómo se define un método con un parámetro opcional en C\#:

\begin{lstlisting}
public static void PrintName(string firstName, string lastName = ""){
    Console.WriteLine($"Nombre completo: {firstName} {lastName}");
    Console.WriteLine($"Hola soy {firstName} {lastName}");
}
\end{lstlisting}

En este ejemplo, el parámetro \emph{lastName} se define como un parámetro opcional, lo que significa que se puede llamar al método sin especificar un valor para este parámetro. Si no se especifica un valor para \emph{lastName}, se utilizará una cadena vacía como valor predeterminado.

\subsubsection*{Métodos y funciones con valor de retorno}

En C\#, tanto los métodos como las funciones pueden tener un valor de retorno. La principal diferencia entre un método y una función es que un método está asociado a un objeto o clase y puede modificar su estado, mientras que una función no tiene asociación con un objeto o clase y no puede modificar su estado.

Para declarar una función con valor de retorno, se utiliza la palabra clave \textbf{return} seguida del valor que se desea devolver. Por ejemplo, la siguiente función recibe dos números enteros y devuelve la suma de ellos:

\begin{lstlisting}
int Sumar(int a, int b)
{
int resultado = a + b;
return resultado;
}
\end{lstlisting}

Para llamar a la función anterior y obtener su resultado, se puede hacer lo siguiente:

\begin{lstlisting}
int resultado = Sumar(3, 4);
Console.WriteLine(resultado); // Imprime 7
\end{lstlisting}

También se pueden declarar métodos con valor de retorno de la misma manera. Por ejemplo, el siguiente método estático de una clase llamada \textbf{Calculadora} recibe dos números enteros y devuelve su suma:

\begin{lstlisting}
public static int Sumar(int a, int b)
{
int resultado = a + b;
return resultado;
}
\end{lstlisting}

Para llamar a este método desde otro lugar del código, se utiliza el nombre de la clase seguido del operador punto y el nombre del método:

\begin{lstlisting}
int resultado = Calculadora.Sumar(3, 4);
Console.WriteLine(resultado); // Imprime 7
\end{lstlisting}

Es importante destacar que el valor de retorno de una función o método debe ser del mismo tipo que el indicado en la declaración. Si se intenta devolver un valor de un tipo distinto, el compilador generará un error.

Existen otros tipos de funciones en C\# como las funciones void, funciones anónimas y funciones lambda.

Las funciones void son aquellas que no retornan ningún valor, es decir, no se espera que devuelvan un resultado. En su lugar, estas funciones suelen realizar una tarea específica, como imprimir información en la consola o modificar un valor dentro de la aplicación.

Las funciones anónimas son aquellas que no tienen un nombre específico y se utilizan principalmente como argumentos de otras funciones. A menudo se utilizan en conjunción con delegados o eventos.

Las funciones lambda son un tipo especial de función anónima que se utilizan para crear expresiones que se pueden utilizar en lugar de métodos o delegados. Estas funciones son útiles para simplificar el código y mejorar la legibilidad.

En cuanto a los tipos de métodos, además de los métodos con valor de retorno, también existen los métodos void, que no retornan ningún valor, los métodos estáticos, que pertenecen a la clase y no a una instancia específica de la misma, y los métodos de instancia, que se ejecutan en una instancia específica de una clase.

En cuanto al nivel de acceso, los métodos y las variables pueden ser públicos, privados, protegidos o internos, lo que determina si se pueden acceder desde otras clases o dentro de la misma clase.

Por último, en función de los argumentos y la salida, podemos encontrar métodos y funciones con parámetros de entrada y sin ellos, así como con un número variable de argumentos. También pueden ser funciones y métodos genéricos, que aceptan tipos de datos específicos como argumentos y retornan valores del mismo tipo.

\subsection{Cadenas}

Las cadenas de texto son muy comunes en la programación, y en C\# se cuenta con una gran cantidad de métodos para trabajar con ellas. Algunos de los métodos más utilizados son:

\subsubsection*{Concatenación de cadenas}

El método más básico para trabajar con cadenas es la concatenación, que consiste en unir dos o más cadenas en una sola. En C\#, se puede hacer con el operador + o con el método Concat:
\begin{lstlisting}
string saludo = "Hola";
string nombre = "Juan";
string mensaje1 = saludo + " " + nombre + "!";
string mensaje2 = string.Concat(saludo, " ", nombre, "!");
\end{lstlisting}
Ambos métodos producirán la misma salida: \enquote*{Hola Juan!}.

\subsubsection*{Métodos de formato}

C\# también ofrece una serie de métodos para formatear cadenas de manera más sofisticada. Uno de ellos es el método Format, que permite crear una cadena con un formato predefinido, en el que se pueden incluir parámetros variables:
\begin{lstlisting}
string saludo = "Hola";
string nombre = "Juan";
string mensaje1 = saludo + " " + nombre + "!";
string mensaje2 = string.Concat(saludo, " ", nombre, "!");
\end{lstlisting}

El método Format toma una cadena de formato, que contiene marcadores de posición (en este caso, los números entre llaves), y una serie de argumentos, que se sustituyen en los marcadores de posición. La salida será: \enquote*{Hola Juan, tienes 25 años.}.

También se puede utilizar el operador \$ para crear una cadena interpolada, que es una forma más compacta de utilizar la sintaxis de formato:

\begin{lstlisting}
string saludo = "Hola";
string nombre = "Juan";
int edad = 25;
string mensaje = $"{saludo} {nombre}, tienes {edad} anos."; \\$
\end{lstlisting}
La salida será la misma que en el ejemplo anterior.

\subsubsection*{Métodos de búsqueda}

C\# también proporciona métodos para buscar y reemplazar cadenas dentro de otras. Por ejemplo, el método IndexOf busca la primera aparición de una subcadena dentro de otra cadena:
\begin{lstlisting}
string texto = "La casa de Juan esta en la calle Mayor";
int posicion = texto.IndexOf("Juan");    
\end{lstlisting}
El valor de posición será 12, que es la posición en la que empieza la palabra \enquote*{Juan} dentro de la cadena.

También se puede utilizar el método Replace para reemplazar una subcadena por otra:
\begin{lstlisting}
string texto = "La casa de Juan esta en la calle Mayor";
string nuevoTexto = texto.Replace("Juan", "Pedro");
\end{lstlisting}
La variable nuevoTexto contendrá la cadena \enquote*{La casa de Pedro está en la calle Mayor}.

\subsubsection*{Métodos de conversión}

Por último, C\# proporciona métodos para convertir cadenas en otros tipos de datos y viceversa. Uno de los métodos más útiles es el método Parse, que convierte una cadena en un valor numérico:
\begin{lstlisting}
string numeroComoTexto = "123";
int numero = int.Parse(numeroComoTexto);    
\end{lstlisting}
El valor de la variable número será 123, que es el valor numérico representado por la cadena.

También se puede utilizar el método ToString para convertir un valor numérico en una cadena:

\begin{lstlisting}
int numero = 123;
string numeroComoTexto = numero.ToString();    
\end{lstlisting}

\subsubsection*{StringBuilder}

StringBuilder es una clase en C\# que se utiliza para manipular cadenas de caracteres de manera más eficiente que con la clase String. La clase StringBuilder tiene métodos que permiten agregar, insertar, eliminar y reemplazar caracteres en una cadena. Además, permite trabajar con cadenas de caracteres mutables (modificables), a diferencia de la clase String, que trabaja con cadenas inmutables (no modificables).

En C\#, para utilizar la clase StringBuilder es necesario importar la librería System.Text. Por lo tanto, al comienzo del archivo de código se debe incluir la siguiente línea:
\begin{lstlisting}
using System.Text;    
\end{lstlisting}

La clase StringBuilder es especialmente útil cuando se trabaja con cadenas grandes y complejas, ya que se pueden realizar múltiples operaciones en la misma cadena sin tener que crear una nueva cadena cada vez, lo que ahorra memoria y tiempo de ejecución.

Aquí hay un ejemplo de cómo se utiliza StringBuilder:
\begin{lstlisting}
StringBuilder sb = new StringBuilder("Hola ");
sb.Append("mundo!");
Console.WriteLine(sb.ToString()); // Salida: "Hola mundo!"    
\end{lstlisting}
En este ejemplo, se crea un nuevo objeto StringBuilder con la cadena \enquote*{Hola }. Luego, se utiliza el método Append para agregar la cadena \enquote*{mundo!} al final de la cadena existente. Finalmente, se utiliza el método ToString para obtener la cadena resultante y mostrarla por consola.

\subsubsection*{El método ToString}

El método ToString es uno de los métodos más utilizados en C\#, ya que nos permite convertir cualquier objeto a su representación en formato de cadena. Este método se utiliza principalmente para imprimir valores en la pantalla o para concatenar cadenas.

La sintaxis básica del método ToString es la siguiente:

\begin{lstlisting}
string texto = objeto.ToString();
\end{lstlisting}

Donde \emph{objeto} es el objeto que se desea convertir a una cadena y \emph{texto} es la cadena resultante.

Es importante tener en cuenta que el método ToString se puede sobrescribir en una clase personalizada para proporcionar una representación de cadena personalizada del objeto. De esta manera, podemos controlar cómo se mostrará el objeto al llamar al método ToString en lugar de la representación predeterminada.

Veamos un ejemplo sencillo de cómo podemos utilizar el método ToString en C\#:

\begin{lstlisting}
int num = 123;
string cadena = num.ToString();
Console.WriteLine(cadena); // muestra "123" en la consola
\end{lstlisting}

En este ejemplo, el método ToString se utiliza para convertir el número entero \emph{num} a una cadena. La cadena resultante se almacena en la variable \emph{cadena} y veamos en la consola utilizando el método WriteLine de la clase Console.

En resumen, el método ToString es una herramienta útil para convertir objetos a su representación en formato de cadena. Si se desea personalizar la forma en que veamos un objeto, es posible sobrescribir este método en una clase personalizada.

\subsubsection*{Otros métodos útiles en cadenas}

En C\#, las cadenas tienen una serie de métodos útiles que pueden ser utilizados para realizar diversas operaciones. Algunos de los métodos más comunes son los siguientes:

\begin{itemize}
\item \textbf{Insert}: este método permite insertar una cadena en una posición específica dentro de otra cadena. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
string cadena = "Hola mundo!";
cadena = cadena.Insert(5, " querido");
Console.WriteLine(cadena); // Output: Hola querido mundo!
\end{lstlisting}
\item \textbf{EndsWith}: este método comprueba si una cadena termina con un valor específico. Devuelve un valor booleano que indica si es verdadero o falso. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
string cadena = "Hola mundo!";
bool resultado = cadena.EndsWith("!");
Console.WriteLine(resultado); // Output: True
\end{lstlisting}
\item \textbf{LastIndexOf}: este método busca la última aparición de una cadena dentro de otra cadena. Devuelve un entero que indica la posición donde se encuentra la última aparición de la cadena. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
string cadena = "Hola mundo!";
int posicion = cadena.LastIndexOf("o");
Console.WriteLine(posicion); // Output: 7
\end{lstlisting}
\item \textbf{Trim}: este método elimina los espacios en blanco del principio y final de una cadena. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
string cadena = " Hola mundo! ";
cadena = cadena.Trim();
Console.WriteLine(cadena); // Output: Hola mundo!
\end{lstlisting}
\item \textbf{string.Format}: este método permite dar formato a una cadena mediante la inclusión de valores variables. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
string nombre = "Juan";
int edad = 35;
string resultado = string.Format("Mi nombre es {0} y tengo {1} years.", nombre, edad);
Console.WriteLine(resultado); // Output: Mi nombre es Juan y tengo 35 years.
\end{lstlisting}
\item \textbf{DateTime.ToString}: este método permite dar formato a una fecha y hora en una cadena de texto. Se puede utilizar de la siguiente manera:
\begin{lstlisting}
DateTime fecha = new DateTime(2023, 4, 25, 15, 30, 0);
string resultado = fecha.ToString("dd/MM/yyyy hh:mm:ss");
Console.WriteLine(resultado); // Output: 25/04/2023 03:30:00 PM
\end{lstlisting}
\end{itemize}

\subsection{Colecciones}

La programación en C\# proporciona varios tipos de colecciones para almacenar y manipular conjuntos de datos. Algunos de los tipos de colecciones más comunes en C\# son los siguientes:

\subsubsection*{ArrayLists}
Un ArrayList es una colección de objetos que se pueden agregar o eliminar dinámicamente en tiempo de ejecución. El tamaño de un ArrayList puede crecer o disminuir automáticamente según sea necesario. Los elementos en un ArrayList se almacenan en orden secuencial, lo que significa que cada elemento tiene un índice numérico que representa su posición en la lista.

Para utilizar un ArrayList en C\#, es necesario importar el espacio de nombres System.Collections. A continuación, veamos un ejemplo de cómo crear y usar un ArrayList:

\begin{lstlisting}
using System.Collections;

ArrayList miArrayList = new ArrayList();

miArrayList.Add("Hola");
miArrayList.Add(123);
miArrayList.Add(true);
miArrayList.Add(4.56);

foreach (object elemento in miArrayList){
    Console.WriteLine(elemento);
    }
\end{lstlisting}

\subsubsection*{Pilas o stacks}
Una pila (o stack, en inglés) es una colección de elementos que se agregan y eliminan por el mismo extremo, conocido como \enquote*{extremo superior} o \enquote*{cima de la pila}. Esto significa que el último elemento en agregarse a la pila es el primero en salir de ella.

En C\#, una pila se puede implementar utilizando la clase Stack, que se encuentra en el espacio de nombres System.Collections. Aquí hay un ejemplo:

\begin{lstlisting}
using System.Collections;

Stack miPila = new Stack();

miPila.Push("uno");
miPila.Push("dos");
miPila.Push("tres");

Console.WriteLine("Cima de la pila: " + miPila.Peek());

while (miPila.Count > 0){
    Console.WriteLine(miPila.Pop());
    }
\end{lstlisting}

\subsubsection*{Colas o Queues}
Una cola (o queue, en inglés) es una colección de elementos que se agregan por un extremo y se eliminan por el otro, conocido como \enquote*{extremo final}. Esto significa que el primer elemento en agregarse a la cola es el primero en salir de ella.

En C\#, una cola se puede implementar utilizando la clase Queue, que se encuentra en el espacio de nombres System.Collections. Aquí hay un ejemplo:

\begin{lstlisting}
using System.Collections;

Queue miCola = new Queue();

miCola.Enqueue("uno");
miCola.Enqueue("dos");
miCola.Enqueue("tres");

Console.WriteLine("Primer elemento de la cola: " + miCola.Peek());

while (miCola.Count > 0){
    Console.WriteLine(miCola.Dequeue());
    }
\end{lstlisting}

\subsubsection*{HashTables}

Hashtable es una estructura de datos que permite almacenar una colección de pares clave-valor. Cada elemento en un Hashtable está identificado por una clave única y asociado con un valor.

Para crear una Hashtable en C\#, se utiliza la clase Hashtable que se encuentra en el espacio de nombres System.Collections.

A continuación, veamos un ejemplo de cómo crear una Hashtable y agregar elementos a ella:

\begin{lstlisting}
Hashtable ht = new Hashtable();
ht.Add("Juan", 25);
ht.Add("Maria", 30);
ht.Add("Pedro", 40);
\end{lstlisting}

En este ejemplo, se ha creado una Hashtable llamada ht y se han agregado tres elementos a ella. La clave de cada elemento es un string que representa el nombre de una persona, y el valor es un entero que representa su edad.

Para acceder a los elementos de una Hashtable, se utiliza la clave correspondiente. Por ejemplo:

\begin{lstlisting}
int edadMaria = (int)ht["Maria"];
\end{lstlisting}

En este ejemplo, se ha accedido al elemento cuya clave es \enquote*{Maria} y se ha almacenado su valor en la variable edadMaria. Como el valor almacenado es un entero, se ha utilizado un casting para convertirlo a ese tipo de datos.

Es importante tener en cuenta que al utilizar una Hashtable, las claves deben ser únicas. Si se intenta agregar un elemento con una clave que ya existe en la Hashtable, se producirá una excepción.

\section{Fundamentos de .NET}
.NET es una plataforma de desarrollo de software desarrollada por Microsoft que ofrece un entorno de ejecución y una biblioteca de clases amplias para la creación de aplicaciones de todo tipo, desde aplicaciones de escritorio hasta aplicaciones web y móviles. Veamos los fundamentos de .NET y cómo podemos comenzar a desarrollar aplicaciones utilizando esta plataforma.

\subsection*{Casos de uso de .NET}
.NET es ampliamente utilizado en una variedad de escenarios de desarrollo de software debido a sus numerosos beneficios y capacidades. A continuación, veamos algunos casos de uso comunes y ventajas clave de .NET:

\subsubsection*{Desarrollo de aplicaciones de escritorio}
.NET es una excelente opción para el desarrollo de aplicaciones de escritorio en Windows. Proporciona una amplia gama de herramientas y bibliotecas de clases para crear interfaces de usuario robustas y funcionales. Los desarrolladores pueden utilizar el framework de Windows Presentation Foundation (WPF) para construir aplicaciones de escritorio con interfaces gráficas modernas y atractivas.

\subsubsection*{Desarrollo de aplicaciones web}
.NET ofrece un sólido soporte para el desarrollo de aplicaciones web. Los desarrolladores pueden utilizar ASP.NET, un framework de desarrollo web de .NET, para construir aplicaciones web dinámicas y escalables. ASP.NET proporciona una gran cantidad de características y herramientas para la creación de sitios web, servicios web y aplicaciones web en general.

\subsubsection*{Desarrollo de servicios en la nube}
Con la versión multiplataforma .NET Core, los desarrolladores pueden crear servicios en la nube que se ejecutan en entornos Windows, macOS y Linux. Esto permite un despliegue más flexible y escalable de aplicaciones en la nube. .NET Core es especialmente adecuado para el desarrollo de microservicios y aplicaciones de contenedorización utilizando herramientas como Docker y Kubernetes.

\subsubsection*{Interoperabilidad y compatibilidad}
Una de las ventajas clave de .NET es su capacidad para interoperar con otros sistemas y lenguajes de programación. Los desarrolladores pueden utilizar bibliotecas existentes de otros lenguajes, como C y C++, a través de interoperabilidad con código nativo. Además, .NET también es compatible con servicios web estándares, como SOAP y REST, lo que facilita la integración con otros sistemas.

\subsubsection*{Productividad y herramientas de desarrollo}
.NET proporciona un conjunto completo de herramientas de desarrollo, incluido el IDE Visual Studio, que agilizan el proceso de desarrollo. Visual Studio ofrece características avanzadas de depuración, refactorización de código, pruebas automatizadas y mucho más. Además, la amplia comunidad de desarrolladores de .NET ofrece numerosos recursos, tutoriales y librerías de código abierto que pueden acelerar el desarrollo de aplicaciones.

\subsection{Ventajas de .NET}

.NET ofrece una serie de ventajas significativas para los desarrolladores y las organizaciones que eligen utilizarlo como plataforma de desarrollo. A continuación, veamos algunas de las principales ventajas de .NET:

\subsubsection*{Amplio conjunto de bibliotecas y herramientas}
.NET proporciona un amplio conjunto de bibliotecas de clases y herramientas que facilitan el desarrollo de aplicaciones. El entorno de .NET incluye bibliotecas para tareas comunes, como manipulación de archivos, acceso a bases de datos, creación de interfaces de usuario y comunicación en red. Además, Microsoft ofrece herramientas de desarrollo potentes y fáciles de usar, como Visual Studio, que mejoran la productividad de los desarrolladores.

\subsubsection*{Lenguajes de programación versátiles}
Con .NET, los desarrolladores tienen acceso a una variedad de lenguajes de programación, incluyendo C\#, Visual Basic .NET y F\#. Esto permite a los desarrolladores elegir el lenguaje que mejor se adapte a sus necesidades y preferencias. Además, los lenguajes de programación de .NET están diseñados para ser interoperables, lo que facilita la integración de código escrito en diferentes lenguajes.

\subsubsection*{Seguridad y robustez}
.NET ofrece características de seguridad integradas y sólidas. El Common Language Runtime (CLR) de .NET incluye un mecanismo de seguridad basado en el concepto de \enquote*{confianza} (trust). El CLR aplica medidas de seguridad, como el aislamiento de procesos y la verificación de tipos, para garantizar que las aplicaciones .NET se ejecuten de manera segura y confiable.

\subsubsection*{Escalabilidad y rendimiento}
.NET está diseñado para ofrecer un alto rendimiento y escalabilidad. El CLR de .NET utiliza técnicas avanzadas, como la compilación en tiempo de ejecución (Just-In-Time Compilation, JIT), la recolección de basura (garbage collection) y la optimización de código, para maximizar la eficiencia de las aplicaciones. Además, .NET ofrece soporte para aplicaciones distribuidas y servicios en la nube, lo que permite escalar y desplegar aplicaciones de manera flexible.

\subsubsection*{Interoperabilidad y compatibilidad}
.NET ofrece una gran interoperabilidad y compatibilidad con otras tecnologías y plataformas. Los servicios web de .NET se basan en estándares como SOAP y REST, lo que facilita la integración con sistemas externos. Además, .NET admite la interoperabilidad con código nativo y bibliotecas existentes de otros lenguajes, lo que permite a los desarrolladores utilizar y extender funcionalidades existentes.

Estas son solo algunas de las ventajas de .NET. La plataforma .NET tiene una amplia adopción y una comunidad de desarrolladores activa, lo que proporciona un soporte adicional y un ecosistema sólido para el desarrollo de aplicaciones. Al considerar una plataforma de desarrollo, las ventajas de .NET hacen que sea una elección sólida para crear aplicaciones modernas y confiables.

\subsection{Common Language Runtime (CLR)}

El Common Language Runtime (CLR) es un componente fundamental del entorno de .NET. Es el entorno de ejecución en el que se ejecutan las aplicaciones desarrolladas en lenguajes compatibles con .NET, como C\#, Visual Basic .NET y F\#. El CLR ofrece una serie de características y funcionalidades que mejoran la eficiencia, la seguridad y la capacidad de administración de las aplicaciones. A continuación, veamos algunas de las características clave del CLR:

\subsubsection*{Compilación y ejecución gestionada}
El CLR realiza una compilación gestionada, lo que significa que el código fuente se compila en un formato intermedio llamado Microsoft Intermediate Language (MSIL) o código IL. Este código IL es independiente de la arquitectura de hardware y se puede ejecutar en cualquier plataforma compatible con .NET. Durante la ejecución, el CLR utiliza la Just-In-Time Compilation (JIT) para compilar el código IL en código nativo específico de la máquina en tiempo de ejecución, lo que mejora el rendimiento de la aplicación.

\subsubsection*{Administración de memoria y recolección de basura}
El CLR se encarga de administrar la memoria utilizada por las aplicaciones .NET y realiza la recolección de basura de manera automática. Utiliza un sistema de administración de memoria basado en la recolección de basura (garbage collection) para liberar automáticamente la memoria no utilizada y evitar fugas de memoria. Esto libera a los desarrolladores de la responsabilidad de administrar la memoria manualmente y mejora la seguridad y la estabilidad de las aplicaciones.

\subsubsection*{Verificación de tipos y seguridad}
El CLR realiza una verificación de tipos exhaustiva para garantizar la seguridad y la integridad de las aplicaciones. Antes de ejecutar el código, el CLR verifica que los tipos utilizados sean válidos y que no se realicen operaciones que violen la seguridad de la plataforma. Esto ayuda a prevenir errores de tiempo de ejecución y protege las aplicaciones de posibles amenazas de seguridad, como el acceso no autorizado a recursos del sistema.

\subsubsection*{Manejo de excepciones y depuración}
El CLR proporciona un sólido sistema de manejo de excepciones que permite a los desarrolladores capturar y controlar los errores durante la ejecución de las aplicaciones. Los desarrolladores pueden utilizar bloques try-catch para manejar las excepciones y tomar acciones apropiadas en caso de errores. Además, el CLR ofrece herramientas de depuración avanzadas que facilitan la identificación y corrección de errores durante el desarrollo de aplicaciones.

\subsubsection*{Interoperabilidad y compatibilidad}
El CLR proporciona un alto nivel de interoperabilidad y compatibilidad con otras tecnologías y plataformas. Permite la interoperabilidad entre diferentes lenguajes de programación compatibles con .NET, lo que facilita la integración de código escrito en diferentes lenguajes. Además, el CLR es compatible con bibliotecas existentes de otros lenguajes y ofrece mecanismos para interactuar con código nativo y servicios web estándares.

El Common Language Runtime (CLR) es una parte esencial de .NET que proporciona una capa de abstracción entre el código .NET y el sistema operativo subyacente. Ofrece una serie de características que mejoran la eficiencia, la seguridad y la administración de las aplicaciones, permitiendo a los desarrolladores centrarse en la lógica de negocio y reducir la complejidad del desarrollo.

\subsection{Compilador Roslyn}

El compilador Roslyn es el compilador oficial de Microsoft para los lenguajes de programación C\# y VB.NET en el entorno .NET. A diferencia de los compiladores tradicionales, Roslyn no solo genera código compilado, sino que también proporciona una representación completa y detallada del código fuente mediante un modelo de árbol sintáctico y semántico.

\subsubsection*{Características clave de Roslyn}

\begin{itemize}
  \item \textbf{Análisis sintáctico:} Roslyn analiza el código fuente y construye un modelo de árbol sintáctico que representa la estructura y las relaciones entre los elementos del código.

  \item \textbf{Análisis semántico:} El compilador realiza un análisis semántico exhaustivo, que incluye la resolución de nombres, la verificación de tipos y la validación de reglas semánticas. Esto permite detectar errores de programación y proporcionar información de contexto valiosa para los desarrolladores.

  \item \textbf{API de compilación:} Roslyn ofrece una API de compilación completa que permite a los desarrolladores interactuar con el compilador y realizar tareas como generar código, analizar y modificar el árbol sintáctico, realizar refactorizaciones y más. Esta API brinda un alto grado de flexibilidad y extensibilidad en el desarrollo de herramientas y complementos para el entorno de desarrollo.

  \item \textbf{Intellisense y análisis en tiempo real:} Al utilizar Roslyn, los IDEs y editores de código pueden aprovechar las capacidades de análisis en tiempo real para ofrecer características como Intellisense, resaltado de errores en tiempo real, refactorización automática y sugerencias de código. Esto mejora significativamente la experiencia de desarrollo al proporcionar retroalimentación instantánea y facilitar la escritura de código correcto.

  \item \textbf{Compilación incremental:} Roslyn es capaz de realizar compilaciones incrementales, lo que significa que solo se compilan las partes del código que han cambiado desde la compilación anterior. Esto reduce el tiempo de compilación en proyectos grandes y facilita el desarrollo iterativo.
\end{itemize}

\subsection{Interfaz de Línea de Comandos (CLI)}
 
La Interfaz de Línea de Comandos (CLI) es una forma de interactuar con un programa o sistema operativo mediante comandos de texto ingresados en una terminal o consola. En el contexto de .NET, la CLI es una parte fundamental de la plataforma y proporciona un entorno de ejecución común para los programas .NET.

\subsubsection*{Características de la CLI}

\begin{itemize}
  \item \textbf{Interpretación de comandos:} La CLI interpreta los comandos ingresados por el usuario y los ejecuta según las instrucciones proporcionadas.

  \item \textbf{Acceso a funcionalidades:} A través de la CLI, los usuarios pueden acceder a diversas funcionalidades del sistema operativo o de los programas, como la ejecución de programas, la gestión de archivos y directorios, la configuración del entorno, entre otros.

  \item \textbf{Automatización de tareas:} La CLI permite la automatización de tareas mediante la creación de scripts o secuencias de comandos que pueden ejecutarse de manera secuencial o en respuesta a eventos específicos.

  \item \textbf{Flexibilidad y portabilidad:} La CLI es independiente del sistema operativo y, por lo tanto, los comandos pueden ejecutarse de manera similar en diferentes plataformas. Esto brinda flexibilidad y portabilidad a los usuarios y desarrolladores.

  \item \textbf{Amplia gama de herramientas:} Existen numerosas herramientas de línea de comandos disponibles en el entorno .NET, que van desde compiladores y depuradores hasta herramientas de administración y análisis de rendimiento.

  \item \textbf{Integración con .NET:} La CLI está estrechamente integrada con la plataforma .NET, lo que permite ejecutar programas y utilizar bibliotecas desarrolladas en lenguajes compatibles con .NET, como C\# y VB.NET.
\end{itemize}

\subsection{Creación una API en .NET}

La creación de una API (Application Programming Interface) en .NET permite exponer servicios y funcionalidades de una aplicación de forma accesible para otros sistemas o aplicaciones. .NET proporciona un conjunto de herramientas y bibliotecas que facilitan el desarrollo de APIs robustas y escalables. A continuación, veamos los pasos básicos para crear una API en .NET:

Para crear y ejecutar una API en .NET, podemos utilizar el comando \enquote*{dotnet new} junto con la plantilla \enquote*{webapi}. A continuación, veamosn los pasos necesarios:

\begin{enumerate}
  \item Abre una terminal o línea de comandos en el directorio donde deseas crear el proyecto de la API.

  \item Ejecuta el siguiente comando para crear un nuevo proyecto de API en .NET:

 \begin{lstlisting}[language=bash]
  dotnet new webapi -n MiProyectoAPI
\end{lstlisting}

  Este comando creará un nuevo proyecto de API en el directorio actual con el nombre \enquote*{MiProyectoAPI}. podemos reemplazar \enquote*{MiProyectoAPI} con el nombre deseado para tu proyecto.

  \item Navega al directorio del proyecto recién creado:

 \begin{lstlisting}[language=bash]
  cd MiProyectoAPI
\end{lstlisting}

  \item Finalmente, ejecuta el siguiente comando para compilar y ejecutar el proyecto de la API:

 \begin{lstlisting}[language=bash]
  dotnet run
\end{lstlisting}

  Esto compilará y ejecutará el proyecto de la API en el servidor web incorporado de .NET.

\end{enumerate}

Al utilizar \enquote*{dotnet new} con la opción \enquote*{webapi}, se crea un proyecto de API básico en .NET con una configuración inicial que incluye un controlador predeterminado, rutas de ejemplo y una configuración básica del servidor web.

Al utilizar el comando \emph{dotnet new webapi}, se crea un proyecto de API básico en .NET con una estructura y configuración inicial. A continuación veamos la salida del comando \emph{ls} para el proyecto creado:

\begin{lstlisting}[language=bash]
MiProyectoAPI/
    Controllers/
        WeatherForecastController.cs
    Program.cs
    Startup.cs
    appsettings.Development.json
    appsettings.json
    MiProyectoAPI.csproj
    WeatherForecast.cs
\end{lstlisting}

A continuación, se explica cada archivo generado por el comando \emph{dotnet new webapi}:

\begin{itemize}
  \item \textbf{Controllers/}: Directorio que contiene los controladores de la API. En el proyecto básico, se incluye el archivo \emph{WeatherForecastController.cs}, que es el controlador predeterminado y contiene las acciones para gestionar los pronósticos del clima.

  \item \textbf{Program.cs}: Archivo que contiene el punto de entrada de la aplicación. Aquí se configura y se ejecuta el servidor web incorporado.

  \item \textbf{Startup.cs}: Archivo que configura el pipeline de solicitud y respuesta de la aplicación. Aquí se pueden agregar middlewares y configurar servicios adicionales.

  \item \textbf{appsettings.Development.json}: Archivo de configuración específico para el entorno de desarrollo. Aquí se pueden establecer configuraciones adicionales como la cadena de conexión a la base de datos, entre otras.

  \item \textbf{appsettings.json}: Archivo de configuración general para la aplicación. Aquí se pueden establecer configuraciones comunes para todos los entornos.

  \item \textbf{MiProyectoAPI.csproj}: Archivo de proyecto de .NET que define las dependencias y la configuración del proyecto.

  \item \textbf{WeatherForecast.cs}: Clase que define la estructura de datos para los pronósticos del clima utilizados en el controlador.

\end{itemize}

Recuerda que el proyecto de la API generado con \emph{dotnet new webapi} es solo una base inicial y podemos modificarlo según tus necesidades específicas. podemos agregar más controladores, definir modelos de datos, implementar autenticación y autorización, configurar middleware adicional y establecer la conexión con una base de datos, entre otras cosas.

La API creada con \emph{dotnet new webapi} ofrece un punto de partida sólido para desarrollar una API en .NET y es altamente personalizable para adaptarse a tus requerimientos.

\subsubsection*{Estructura del program.cs de la API en .NET 6}

El programa de la API en .NET 6 es la entrada principal del proyecto y es responsable de configurar y ejecutar la aplicación web. En este programa, se utiliza el enfoque simplificado sin necesidad de una clase `Main` explícita.

\begin{lstlisting}
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();    
\end{lstlisting}

Creamos un \enquote*{WebApplicationBuilder} con el metodo \enquote*{WebApplication.CreateBuilder(args)}. A continuación, se pueden realizar configuraciones adicionales y agregar servicios necesarios para la aplicación.

Una vez que se ha configurado la aplicación, se llama al método \enquote*{Build()} en el \enquote*{WebApplicationBuilder} para construir la aplicación. Luego, se configura el pipeline de solicitud para manejar las diferentes rutas y operaciones HTTP.

Finalmente, se llama al método \enquote*{Run()} para iniciar la ejecución de la aplicación y comenzar a escuchar las solicitudes entrantes.

Este enfoque simplificado proporcionado por .NET 6 y C\# 9 permite una estructura más concisa y legible del programa, simplificando la configuración y ejecución de la aplicación web.

\subsubsection{Estructura de un controlador en .NET}

Un controlador en .NET es una clase que maneja las solicitudes HTTP y define las acciones que se pueden realizar en una API. A continuación, veamos un ejemplo de la estructura básica de un controlador en .NET:

\begin{lstlisting}
using Microsoft.AspNetCore.Mvc;

namespace MiProyectoAPI.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class EjemploController : ControllerBase
    {
        // GET: api/Ejemplo
        [HttpGet]
        public IActionResult Get()
        {
            // Logica para obtener los datos y retornarlos como respuesta
            return Ok("Respuesta del metodo GET");
        }

        // GET: api/Ejemplo/{id}
        [HttpGet("{id}")]
        public IActionResult GetById(int id)
        {
            // Logica para obtener un recurso especifico basado en el ID y retornarlo como respuesta
            return Ok($"Respuesta del metodo GET con ID: {id}");
        }

        // POST: api/Ejemplo
        [HttpPost]
        public IActionResult Post([FromBody] MiModelo modelo)
        {
            // Logica para procesar y guardar los datos recibidos en el cuerpo de la solicitud
            // utilizando el modelo proporcionado
            return CreatedAtAction(nameof(GetById), new { id = 1 }, modelo);
        }

        // PUT: api/Ejemplo/{id}
        [HttpPut("{id}")]
        public IActionResult Put(int id, [FromBody] MiModelo modelo)
        {
            // Logica para actualizar un recurso existente basado en el ID y los datos proporcionados
            return NoContent();
        }

        // DELETE: api/Ejemplo/{id}
        [HttpDelete("{id}")]
        public IActionResult Delete(int id)
        {
            // Logica para eliminar un recurso existente basado en el ID
            return NoContent();
        }
    }
}
\end{lstlisting}

En este ejemplo, veamos la estructura de un controlador llamado \lstinline{EjemploController}. El controlador hereda de la clase \lstinline{ControllerBase} y se utilizan los atributos \lstinline{[ApiController]} y \lstinline{[Route]} para configurar la API y definir las rutas de los endpoints.

Cada acción del controlador está decorada con un atributo HTTP (\lstinline{[HttpGet]}, \lstinline{[HttpPost]}, \lstinline{[HttpPut]}, \lstinline{[HttpDelete]}) para indicar el tipo de solicitud HTTP que maneja. En cada acción, se puede agregar la lógica necesaria para realizar operaciones y se retorna una respuesta utilizando métodos como \lstinline{Ok()}, \lstinline{CreatedAtAction()} o \lstinline{NoContent()}.

\subsubsection{Estándar de respuesta en un controlador}

En un controlador de una API en .NET, es importante seguir un estándar de respuesta consistente para cada método HTTP. Aquí veamos un ejemplo del estándar de respuesta común en los diferentes métodos HTTP:

\begin{itemize}
\item \textbf{GET}: El método GET se utiliza para obtener recursos y retornarlos como respuesta. El estándar de respuesta puede ser:

\begin{itemize}
\item Código de estado 200 (OK) junto con el recurso solicitado en el cuerpo de la respuesta.
\item Código de estado 404 (Not Found) si el recurso no existe.
\item Código de estado 500 (Internal Server Error) si ocurre un error en el servidor.
\end{itemize}

\item \textbf{POST}: El método POST se utiliza para crear nuevos recursos. El estándar de respuesta puede ser:

\begin{itemize}
\item Código de estado 201 (Created) junto con la ubicación del nuevo recurso creado en la cabecera de la respuesta.
\item Código de estado 400 (Bad Request) si la solicitud no es válida o faltan datos requeridos.
\item Código de estado 500 (Internal Server Error) si ocurre un error en el servidor.
\end{itemize}

\item \textbf{PUT}: El método PUT se utiliza para actualizar recursos existentes. El estándar de respuesta puede ser:

\begin{itemize}
\item Código de estado 204 (No Content) si la actualización se realizó correctamente y no hay contenido adicional para enviar en la respuesta.
\item Código de estado 404 (Not Found) si el recurso no existe.
\item Código de estado 500 (Internal Server Error) si ocurre un error en el servidor.
\end{itemize}

\item \textbf{DELETE}: El método DELETE se utiliza para eliminar recursos existentes. El estándar de respuesta puede ser:

\begin{itemize}
\item Código de estado 204 (No Content) si la eliminación se realizó correctamente y no hay contenido adicional para enviar en la respuesta.
\item Código de estado 404 (Not Found) si el recurso no existe.
\item Código de estado 500 (Internal Server Error) si ocurre un error en el servidor.
\end{itemize}

\end{itemize}

A continuación, veamos una lista completa de los códigos de estado HTTP más comunes:

\begin{itemize}
    \item \textbf{100 (Continue)}: El servidor ha recibido los encabezados de solicitud y el cliente debe continuar con la solicitud.
    
    \item \textbf{101 (Switching Protocols)}: El servidor acepta cambiar el protocolo solicitado en la solicitud.
    
    \item \textbf{200 (OK)}: La solicitud ha sido exitosa y se devuelve un resultado esperado.
    
    \item \textbf{201 (Created)}: La solicitud ha tenido éxito y se ha creado un nuevo recurso como resultado.
    
    \item \textbf{202 (Accepted)}: La solicitud ha sido aceptada para procesamiento, pero el resultado aún no está disponible.
    
    \item \textbf{204 (No Content)}: La solicitud ha sido exitosa y no hay contenido adicional para enviar en la respuesta.
    
    \item \textbf{300 (Multiple Choices)}: Indica que la solicitud tiene múltiples opciones y el cliente debe elegir una.
    
    \item \textbf{301 (Moved Permanently)}: El recurso solicitado se ha movido permanentemente a una nueva ubicación.
    
    \item \textbf{302 (Found)}: El recurso solicitado se ha encontrado temporalmente en una ubicación diferente.
    
    \item \textbf{304 (Not Modified)}: El recurso solicitado no ha sido modificado desde la última vez que se accedió a él.
    
    \item \textbf{400 (Bad Request)}: La solicitud no se pudo entender o es incorrecta debido a datos no válidos o malformados.
    
    \item \textbf{401 (Unauthorized)}: La solicitud requiere autenticación y el cliente no ha proporcionado las credenciales válidas.
    
    \item \textbf{403 (Forbidden)}: El cliente no tiene permiso para acceder al recurso solicitado.
    
    \item \textbf{404 (Not Found)}: El recurso solicitado no se ha encontrado en el servidor.
    
    \item \textbf{405 (Method Not Allowed)}: El método HTTP utilizado en la solicitud no está permitido para el recurso solicitado.
    
    \item \textbf{500 (Internal Server Error)}: Se ha producido un error interno en el servidor.
    
    \item \textbf{502 (Bad Gateway)}: El servidor actuando como un proxy o puerta de enlace ha recibido una respuesta no válida del servidor ascendente.
    
    \item \textbf{503 (Service Unavailable)}: El servidor no está disponible actualmente debido a una sobrecarga temporal o mantenimiento programado.
    
    \item \textbf{504 (Gateway Timeout)}: El servidor ascendente no ha recibido una respuesta oportuna del servidor descendente mientras actuaba como un proxy o puerta de enlace.
    
    \end{itemize}

Además, es importante considerar el formato de respuesta en el cuerpo de la respuesta. A continuación veamosn un ejemplo práctico de formatos de respuesta:

\begin{itemize}
  \item \textbf{JSON}: El formato JSON (JavaScript Object Notation) es ampliamente utilizado y fácilmente analizable. Un ejemplo de respuesta en formato JSON podría ser:

 \begin{lstlisting}
{
  "id": 1,
  "name": "John Doe",
  "email": "john.doe@example.com"
}
\end{lstlisting}
\end{itemize}

Y este podría ser el controlador que otorgue esta respuesta:

\begin{lstlisting}
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class ExampleController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        // Codigo de implementacion para el metodo GET. Aqui podemos obtener los datos solicitados y construir la respuesta

        var data = new
        {
            id = 1,
            name = "John Doe",
            email = "john.doe@example.com"
        };

        if (data != null)
        {
            return Ok(data); // Devuelve una respuesta 200 (OK) con los datos en formato JSON
        }
        else
        {
            return NotFound(); // Devuelve una respuesta 404 (Not Found) si el recurso no existe
        }
    }

    [HttpPost]
    public IActionResult Post()
    {
        // Codigo de implementacion para el metodo POST. Aqui podemos crear un nuevo recurso y construir la respuesta
        var newResource = new
        {
            id = 2,
            name = "Jane Smith",
            email = "jane.smith@example.com"
        };
        // Supongamos que se crea correctamente el nuevo recurso
        if (newResource != null)
        {
            return CreatedAtAction(nameof(Get), new { id = newResource.id }, newResource);
            // Devuelve una respuesta 201 (Created) con la ubicacion del nuevo recurso creado y los datos en formato JSON
        }
        else
        {
            return BadRequest(); // Devuelve una respuesta 400 (Bad Request) si la solicitud no es valida
        }
    }

    [HttpPut("{id}")]
    public IActionResult Put(int id)
    {
        // Codigo de implementacion para el metodo PUT. Aqui podemos actualizar el recurso existente y construir la respuesta
        // Supongamos que se actualiza el recurso con el ID proporcionado
        var updatedResource = new
        {
            id = id,
            name = "Updated Name",
            email = "updated.email@example.com"
        };
        if (updatedResource != null)
        {
            return NoContent(); // Devuelve una respuesta 204 (No Content) sin contenido adicional
        }
        else
        {
            return NotFound(); // Devuelve una respuesta 404 (Not Found) si el recurso no existe
        }
    }

    [HttpDelete("{id}")]
    public IActionResult Delete(int id)
    {
        // Codigo de implementacion para el metodo DELETE. Aqui podemos eliminar el recurso con el ID proporcionado y construir la respuesta
        // Supongamos que se ha eliminado el recurso con el ID proporcionado
        var success = true;
        if (success)
        {
            return NoContent(); // Devuelve una respuesta 204 (No Content) sin contenido adicional
        }
        else
        {
            return NotFound(); // Devuelve una respuesta 404 (Not Found) si el recurso no existe
        }
    }
}
\end{lstlisting}

\subsubsection{Implementación de Json Web Token en una API de .NET}

La implementación de JSON Web Tokens (JWT) en una aplicación permite la autenticación y autorización segura de usuarios. A continuación veamos un ejemplo de cómo implementar JWT en una api:

\begin{enumerate}
  \item Configuración en el archivo appsettings.json:

  En el archivo appsettings.json, agregue la siguiente configuración para JWT:

 \begin{lstlisting}
  "Jwt": {
    "Issuer": "https://example.com/",
    "Audience": "https://example.com/",
    "Key": "YourSecretKeyHere",
    "TokenDurationSeconds": 3600
  }
\end{lstlisting}

  Asegúrese de reemplazar \enquote*{YourSecretKeyHere} con su clave secreta personalizada.

  \item Configuración en el código de la aplicación:

  En el código de la aplicación, configure los servicios necesarios y la autenticación JWT:

 \begin{lstlisting}
  var builder = WebApplication.CreateBuilder(args);

  // ...

  builder.Services.AddAuthentication(options =>
  {
      options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
      options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
      options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
  }).AddJwtBearer(o =>
  {
      o.TokenValidationParameters = new TokenValidationParameters
      {
          ValidIssuer = builder.Configuration["Jwt:Issuer"],
          ValidAudience = builder.Configuration["Jwt:Audience"],
          IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"])),
          ValidateIssuer = true,
          ValidateAudience = true,
          ValidateLifetime = true,
          ValidateIssuerSigningKey = true
      };
  });

  builder.Services.AddAuthorization();

  // ...

  app.UseAuthorization();
  app.UseHttpsRedirection();
  app.MapControllers().RequireAuthorization();
\end{lstlisting}

  Asegúrese de ajustar el código según la estructura de su aplicación.

  \item Cree una clase para el ingreso de usuarios:
 \begin{lstlisting}
namespace APIJWT.user{
    public class User
    {
        public string UserName { get; set; }
        public string Password { get; set; }
    }
}
\end{lstlisting}
  \item Generación y verificación de tokens:
  
  Despues de mapear los controladores coloque el siguiente controlador, y agregue \enquote*{.RequireAuthorization()} en el mapeo, así \enquote*{app.MapControllers().RequireAuthorization();}, 

 \begin{lstlisting}
  app.MapPost("/security/createToken", [AllowAnonymous] (UserEntidad user) =>
  {
      if (user.UserName == "user" && user.Password == "password")
      {
          var issuer = builder.Configuration["Jwt:Issuer"];
          var audience = builder.Configuration["Jwt:Audience"];
          var tokenDurationSeconds = builder.Configuration.GetValue<int>("Jwt:TokenDurationSeconds");
          var key = Encoding.ASCII.GetBytes(builder.Configuration["Jwt:Key"]);
          var tokenDescriptor = new SecurityTokenDescriptor
          {
              Subject = new ClaimsIdentity(new[]
              {
                  new Claim("Id", Guid.NewGuid().ToString()),
                  new Claim(JwtRegisteredClaimNames.Sub, user.UserName),
                  new Claim(JwtRegisteredClaimNames.Email, user.UserName),
                  new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
              }),
              Expires = DateTime.UtcNow.AddSeconds(tokenDurationSeconds),
              Issuer = issuer,
              Audience = audience,
              SigningCredentials = new SigningCredentials(
                  new SymmetricSecurityKey(key),
                  SecurityAlgorithms.HmacSha512Signature
              )
          };
          var tokenHandler = new JwtSecurityTokenHandler();
          var token = tokenHandler.CreateToken(tokenDescriptor);
          var jwtToken = tokenHandler.WriteToken(token);
          var stringToken = tokenHandler.WriteToken(token);
          return Results.Ok(stringToken);
      }
      return Results.Unauthorized();
  });
\end{lstlisting}

  El archivo program.cs quedaría así:
 \begin{lstlisting}
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using APIJWT.user;
using Microsoft.AspNetCore.Authorization;
using System.Security.Claims;
using System.IdentityModel.Tokens.Jwt;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o =>
{
    o.TokenValidationParameters = new TokenValidationParameters
    {
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey
        (Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"])),
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true
    };
});

builder.Services.AddAuthorization();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseAuthorization();
app.UseHttpsRedirection();
app.MapControllers().RequireAuthorization();
app.MapGet("/security/getMessage", () => "Hello World!").RequireAuthorization();
app.MapPost("/security/createToken",
[AllowAnonymous] (User user) =>
{
    if (user.UserName == "user" && user.Password == "password")
    {
        var issuer = builder.Configuration["Jwt:Issuer"];
        var audience = builder.Configuration["Jwt:Audience"];
        var tokenDurationSeconds = builder.Configuration.GetValue<int>("Jwt:TokenDurationSeconds");
        var key = Encoding.ASCII.GetBytes
        (builder.Configuration["Jwt:Key"]);
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("Id", Guid.NewGuid().ToString()),
                new Claim(JwtRegisteredClaimNames.Sub, user.UserName),
                new Claim(JwtRegisteredClaimNames.Email, user.UserName),
                new Claim(JwtRegisteredClaimNames.Jti,
                Guid.NewGuid().ToString())
             }),
            Expires = DateTime.UtcNow.AddSeconds(tokenDurationSeconds),
            Issuer = issuer,
            Audience = audience,
            SigningCredentials = new SigningCredentials
            (new SymmetricSecurityKey(key),
            SecurityAlgorithms.HmacSha512Signature)
        };
        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        var jwtToken = tokenHandler.WriteToken(token);
        var stringToken = tokenHandler.WriteToken(token);
        return Results.Ok(stringToken);
    }
    return Results.Unauthorized();
});

app.Run();
\end{lstlisting}

\end{enumerate}

Con esta implementación, su aplicación estará configurada para utilizar JWT como mecanismo de autenticación y autorización.

Para consumir la aplicación debemos seguir estos pasos:

\begin{enumerate}
    \item Solicitud post al controlador \lstinline{/security/createToken} con el siguiente body:
   \begin{lstlisting}
{
    "userName" : "user",
    "password" : "password"
}
\end{lstlisting}
La respuesta a esta solicitud obtiene el token y status 200, por ejemplo:
\begin{lstlisting}
    "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJJZCI6IjA4ZWIwODc0LWRjNjctNDFhMS1YiI6InVzZXIiLCJlbWFpMTUtOWYxOC.0yMDVlMjhkYTdmMzMiLCJuYmYiOjE2ODkyMDEzOczovL2pveWRpcGthbmppbGFsLmNvbS8pcGthbmppbGFsLmNvbS8ifQ.PZrQGkqDWmu_zPm7m9gbyMDJ4_1zEic6_UPl7cHVUBdX8pon8NstYCXctAibL6rIClcVok4tXLwpzYuGoJAtlA"
\end{lstlisting}
\item Solicitud al controlador con el Token, en authorization, seleccionamos \enquote*{Bearer Token}, y ponemos el token. Si el token está mal o no está, la aplicación respondrá con un status 401.
\end{enumerate}

\subsubsection{Implementación de Log4net}

La implementación de Log4net en tu aplicación implica los siguientes pasos:

\begin{enumerate}
  \item \textbf{Instalación de paquetes NuGet:}
  
  Asegúrate de tener instalado el paquete NuGet de Log4net en tu proyecto. Esto se puede hacer mediante la administración de paquetes NuGet en Visual Studio.
  
  \item \textbf{Archivo de configuración log4net.config:}
  
  Crea un archivo llamado \emph{log4net.config} en la raíz de tu proyecto y configúralo según tus necesidades. Aquí tienes un ejemplo de cómo podría verse el contenido del archivo:
  
 \begin{lstlisting}
<log4net>
<root>
    <level value="ALL" />
    <!-- Debug, Info, Warn, Error, Fatal -->
    <appender-ref ref="file" />
</root>

<appender name="file" type="log4net.Appender.RollingFileAppender">
    <file value="log_Banco.txt" />
    <appendToFile value="true" />
    <rollingStyle value="Date" />
    <datePattern value="yyyyMMdd" />
    <maxSizeRollBackups value="5" />
    <maximumFileSize value="10MB" />
    <!--<staticLogFileName value="true" />-->
    <layout type="log4net.Layout.PatternLayout">
    <conversionPattern value="%date [%thread] %level %logger - %message%newline" />
    </layout>
</appender>
</log4net>
\end{lstlisting}
En este archivo de configuración, se utiliza un RollingFileAppender que genera archivos de registro con un nombre basado en la fecha actual \lstinline{log_Banco_YYYYMMDD.txt}. Se establece el nivel de registro en \enquote*{ALL}, lo que significa que se registrarán todos los niveles de registro, desde \enquote*{DEBUG} hasta \enquote*{FATAL}. Se especifica un tamaño máximo de archivo de 10MB y se mantendrán hasta 5 archivos de respaldo. El diseño de registro utiliza un patrón de conversión personalizado que muestra la fecha, el hilo, el nivel de registro, el nombre del registrador y el mensaje de registro.

\item \textbf{Inicialización de Log4net en el código:}
  
  En el archivo \emph{Program.cs} de tu proyecto, agrega el siguiente código para inicializar Log4net con la configuración del archivo \emph{log4net.config}:
  
\begin{lstlisting}
using log4net;
using log4net.Config;

var builder = WebApplication.CreateBuilder(args);

// Configurar Log4Net
var logConfig = new FileInfo("log4net.config");
XmlConfigurator.ConfigureAndWatch(logConfig);

// Agregar servicios al contenedor
builder.Services.AddControllers();

// Crear la aplicacion
var app = builder.Build();

// Configurar el pipeline de solicitudes HTTP
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseRouting();

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
});

app.Run(async context =>
{
    await context.Response.WriteAsync("Hello, World!");
});    
\end{lstlisting}
  
  \item \textbf{Uso de Log4net en los controladores:}
  
  En tus controladores, podemos utilizar Log4net para registrar mensajes de log en diferentes niveles, como DEBUG, INFO, WARN, ERROR y FATAL. Aquí tienes un ejemplo de cómo se podría usar en un controlador:
  
\begin{lstlisting}
using log4net;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using System;

namespace Banco.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ClienteController : ControllerBase
    {
        private static readonly ILog log = LogManager.GetLogger(typeof(ClienteController));

        [HttpGet]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status500InternalServerError)]
        public IActionResult Get()
        {
            try
            {
                log.Info("Obteniendo lista de clientes");

                // Resto del codigo para obtener la lista de clientes

                log.Debug("Lista de clientes obtenida exitosamente");
                return Ok();
            }
            catch (Exception ex)
            {
                log.Error("Error al obtener lista de clientes: " + ex.Message);
                return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);
            }
        }
        // Resto de acciones del controlador
    }
}
\end{lstlisting}
\end{enumerate}

\subsubsection*{Tipos de Logs en log4net}

log4net admite varios niveles de logs que se utilizan para clasificar la importancia de los mensajes de registro. Estos niveles de logs ayudan a filtrar y gestionar los mensajes según su relevancia. Los tipos de logs disponibles en log4net son los siguientes:

\begin{itemize}
  \item \textbf{DEBUG}: Este nivel de log se utiliza para mensajes de depuración y proporciona información detallada para fines de depuración. Los mensajes de depuración son útiles durante el desarrollo para rastrear el flujo de ejecución, verificar los valores de variables y detectar posibles errores. Sin embargo, en entornos de producción, los mensajes de depuración suelen desactivarse para evitar la sobrecarga del sistema y preservar la privacidad de los datos sensibles.

  \item \textbf{INFO}: Este nivel de log se utiliza para mensajes informativos que indican el estado o el progreso del sistema. Los mensajes informativos son útiles para rastrear eventos importantes y proporcionar información general sobre el funcionamiento del sistema. Estos mensajes no son críticos y no requieren acción inmediata.

  \item \textbf{WARN}: Este nivel de log se utiliza para mensajes de advertencia que indican situaciones potencialmente problemáticas. Los mensajes de advertencia suelen indicar condiciones anormales o eventos inesperados que no impiden el funcionamiento normal del sistema, pero que podrían requerir atención o corrección en el futuro. Estos mensajes proporcionan información útil para identificar y solucionar problemas potenciales.

  \item \textbf{ERROR}: Este nivel de log se utiliza para mensajes de error que indican problemas o excepciones que impiden el funcionamiento normal del sistema. Los mensajes de error son críticos y requieren atención inmediata, ya que representan fallas o condiciones no deseadas. Estos mensajes ayudan a identificar y solucionar problemas para mantener la estabilidad y el rendimiento del sistema.

  \item \textbf{FATAL}: Este nivel de log se utiliza para mensajes de error graves o críticos que indican una falla catastrófica del sistema. Los mensajes fatales suelen representar errores irreparables o condiciones que ponen en peligro la integridad de los datos o la continuidad del sistema. Estos mensajes requieren una acción inmediata para evitar daños mayores o interrupciones significativas.

\end{itemize}

Es importante elegir el nivel de log adecuado para cada mensaje, asegurándose de equilibrar la cantidad de información registrada con la sobrecarga del sistema y la seguridad de los datos. Configurar correctamente los niveles de logs permite filtrar y gestionar los mensajes de forma eficiente, lo que facilita la identificación y solución de problemas, así como el seguimiento del rendimiento y el comportamiento del sistema.

Para incluir los niveles de logs en el código utilizando log4net, se debe importar la biblioteca de log4net y configurar el archivo de configuración correspondiente. A continuación veamos un ejemplo de cómo se puede utilizar log4net para registrar mensajes de diferentes niveles:

\begin{lstlisting}
using log4net;

public class MyClass
{
    private static readonly ILog log = LogManager.GetLogger(typeof(MyClass));

    public void DoSomething()
    {
        log.Debug("Este es un mensaje de depuracion.");
        log.Info("Este es un mensaje informativo.");
        log.Warn("Este es un mensaje de advertencia.");
        log.Error("Este es un mensaje de error.");
        log.Fatal("Este es un mensaje fatal.");
    }
}
\end{lstlisting}

En este ejemplo, se utiliza la interfaz ILog de log4net para obtener una instancia del log asociada a la clase \emph{MyClass}. Luego, se utilizan los métodos \emph{Debug}, \emph{Info}, \emph{Warn}, \emph{Error} y \emph{Fatal} para registrar mensajes de diferentes niveles.

\subsubsection*{Registro en el Archivo de Texto}

Cuando los mensajes de log se registran en el archivo de texto, siguiendo la configuración establecida en el archivo \emph{log4net.config}, tendrán el siguiente formato:

\begin{verbatim}
2022-01-01 10:30:00 [DEBUG] MyClass - Este es un mensaje de depuracion.
2022-01-01 10:30:01 [INFO] MyClass - Este es un mensaje informativo.
2022-01-01 10:30:02 [WARN] MyClass - Este es un mensaje de advertencia.
2022-01-01 10:30:03 [ERROR] MyClass - Este es un mensaje de error.
2022-01-01 10:30:04 [FATAL] MyClass - Este es un mensaje fatal.
\end{verbatim}

En cada línea, veamos la fecha y hora del registro, seguida del nivel de log entre corchetes, el nombre de la clase que registró el mensaje y finalmente el contenido del mensaje en sí.

Es importante tener en cuenta que la apariencia exacta de los registros en el archivo de texto puede variar según la configuración específica establecida en el archivo \emph{log4net.config} y las opciones de formato definidas en el patrón de conversión.

\section{Programación orientada a objetos}

La programación orientada a objetos (POO) es un paradigma de programación que se basa en la utilización de objetos para representar y manipular los datos y su comportamiento en un programa. En POO, los objetos son instancias de una clase, que es una plantilla que define las características y el comportamiento de los objetos.

El enfoque en objetos permite la modularidad y el encapsulamiento, lo que hace que el código sea más fácil de mantener y extender, el encapsulamiento permite modelar ideas de seguridad y niveles de acceso entre clases. Además, la POO hace uso de conceptos como la herencia y el polimorfismo, que permiten una mayor flexibilidad y reutilización de código.

Los pilares de la programación orientada a objetos son:

\begin{enumerate}
    \item Abstracción: este pilar se refiere a la capacidad de representar objetos del mundo real de manera simplificada, enfocándonos en las características importantes y dejando de lado lo que no es relevante para nuestro objetivo. En POO, una clase es una abstracción de un objeto.
    \item Encapsulamiento: este pilar se refiere a la capacidad de ocultar ciertos datos y comportamientos de un objeto, de manera que sólo se puedan acceder a ellos mediante una interfaz definida. En POO, esto se logra utilizando modificadores de acceso (public, private, protected) para controlar la visibilidad de los miembros de una clase.
    \item Herencia: este pilar se refiere a la capacidad de crear nuevas clases a partir de clases existentes, heredando sus características y comportamientos. En POO, una clase hija hereda los miembros de la clase padre y puede añadir o sobrescribir miembros según sus necesidades.
    \item Polimorfismo: este pilar se refiere a que diferentes objetos pueden responder al \enquote*{mismo} metodo de diferentes maneras. Es usual que hayan clases que tengan el metodo \enquote*{Get}, que se encarga de mostrar los atributos de la clase en cuestiónm, Es inmediato entonces entender que dos objetos podrán responder \enquote*{al mismo metodo} de distintas formas. 
\end{enumerate}

\subsection{Clases y objetos}

En programación orientada a objetos, una clase es una plantilla o modelo que describe las propiedades y métodos que tendrán los objetos que son instancia de ella. Por lo tanto, una clase es un concepto abstracto que define la estructura y comportamiento de los objetos.

Por otro lado, un objeto es una instancia concreta de una clase. En otras palabras, es una representación tangible de la clase. Cuando se crea un objeto, se pueden establecer sus propias propiedades y métodos, aunque hereda las características definidas por la clase.

Veamos un ejemplo de cómo se declara una clase en C\#:
\begin{lstlisting}
public class Person {
    // atributos encapsulados
    private string name;
    private int age;

    // metodo constructor (luego veremos con detalle este concepto)
    public Person(string name, int age){
        this.name = name;
        this.age = age;
    }

    // metodo
    public void greet(){
        Console.WriteLine("Hi, my name is " + name + " and I'm " + age + " years old.");
    }
}
\end{lstlisting}
En este ejemplo, se ha creado una clase llamada Persona con dos propiedades (nombre y edad) y dos métodos (el método constructor y el método Saludar). El método constructor se utiliza para inicializar las propiedades cuando se crea un objeto, mientras que el método Saludar se utiliza para imprimir un mensaje en la consola.

Para crear un objeto de la clase Persona, se puede hacer lo siguiente:

\begin{lstlisting}
Person person1 = new Person("Juan", 30);
\end{lstlisting}

En este caso, se está creando un objeto llamado persona1 de la clase Persona, y se están pasando como argumentos al método constructor los valores \enquote*{Juan} y 30 para las propiedades nombre y edad, respectivamente.

Una vez creado el objeto, se puede llamar a su método Saludar de la siguiente manera:

\begin{lstlisting}
persona1.greet();
\end{lstlisting}

Este código imprimirá en la consola el mensaje \enquote*{Hi, my name is  Juan and I'm 30 years old.}, utilizando los valores de las propiedades del objeto creado.

\subsection{Herencia}

La herencia es un concepto importante en la programación orientada a objetos que permite que una clase adquiera las propiedades y métodos de otra clase existente. La clase existente se conoce como la clase base o superclase, mientras que la clase que hereda de ella se conoce como la clase derivada o subclase. Puede ser útil para crear una jerarquía de clases que comparten propiedades y comportamientos comunes. Al heredar de una clase base, una clase derivada puede reutilizar el código existente y extender o modificar su comportamiento. Además de la herencia de clases, también existen las interfaces funcionales y las clases abstractas. Las interfaces funcionales son un tipo especial de interfaz que define exactamente un método abstracto y pueden ser implementadas por cualquier clase que proporcione una implementación de este método. Las clases abstractas son clases que no se pueden instanciar directamente y deben ser extendidas por clases derivadas. Las clases abstractas pueden contener métodos abstractos, que deben ser implementados por cualquier clase derivada, así como métodos concretos que se pueden usar directamente en la clase derivada.

Te muestro un ejemplo de cómo la herencia puede hacer que el código sea más modular:

\begin{lstlisting}
public abstract class Animal{
    public abstract string Sound();
    }

public class Dog : Animal{
    public override string Sound(){
        return "Woof!";
    }
}

public class Cat : Animal{
    public override string Sound(){
        return "Meow!";
    }
}

    public class AnimalSound{
    public static void Main(){
        Animal dog = new Dog();
        Animal cat = new Cat();

        Console.WriteLine(dog.Sound());
        Console.WriteLine(cat.Sound());
        }
}
\end{lstlisting}

En este ejemplo, se define una clase abstracta llamada Animal que tiene un método abstracto llamado Sound(). La clase Dog y la clase Cat heredan de la clase Animal y proporcionan una implementación del método Sound(). La clase AnimalSound utiliza las clases Dog y Cat para imprimir los sonidos de un perro y un gato en la consola. Este código es más modular y fácil de mantener, ya que el comportamiento común se define en la clase Animal y las clases derivadas pueden proporcionar su propia implementación única del método Sound().

\subsection{Abstracción}

La abstracción es un concepto dentro de la programación orientada a objetos que se refiere al proceso mediante el cual se toman los aspectos de una entidad, asociada al objeto que queremos utilizar, y así pensar en la clase (plantilla) que al instanciar generará este objeto en cuestión. No se abstraen todos los aspectos que una entidad tiene en el mundo real, sino solo los que son realmente pertinentes en la aplicación en cuestión. 

Por ejemplo, si estamos escribiendo una aplicación bancaria, podríamos crear una clase \enquote*{CuentaBancaria} que tenga propiedades como \enquote*{balance} y \enquote*{número de cuenta}, así como métodos como \enquote*{depósito} y \enquote*{retiro}. Un programador que utilice esta clase puede utilizar estos métodos y propiedades sin necesidad de conocer los detalles internos de cómo se implementan. Además, entendemos que una cuenta bancaria puede tener otras propiedades, como un dueño, y este a su vez un numero relativamente grande de propiedades, que realmente en este contexto no nos van a interesar en este contexto.

\subsection{Encapsulamiento}

El encapsulamiento es otro concepto clave en la programación orientada a objetos que se refiere a la ocultación de los detalles internos de una clase o estructura de datos, de manera que solo se expongan los métodos y propiedades que son necesarios para interactuar con ella. En otras palabras, se protege la información dentro de la clase para que no pueda ser modificada por otros objetos externos.

Por ejemplo, en la clase \enquote*{CuentaBancaria} mencionada anteriormente, podríamos encapsular la propiedad \enquote*{balance} y el método \enquote*{retiro}, de manera que solo se pueda acceder a ellos desde dentro de la clase. Esto evita que otros objetos externos a la clase modifiquen directamente el balance de la cuenta o realicen retiros no autorizados.

La sintaxis para encapsular una propiedad en C\# es la siguiente:
\begin{lstlisting}
private double balance;
public double Balance
{
    get { return balance; }
    private set { balance = value; }
}
\end{lstlisting}
En este ejemplo, la propiedad \enquote*{balance} es privada, lo que significa que solo se puede acceder a ella desde dentro de la clase. Sin embargo, hemos creado un método público llamado \enquote*{Balance} que se utiliza para obtener el valor actual de la propiedad. También hemos creado un método privado \enquote*{set} para permitir que la propiedad sea modificada desde dentro de la clase, pero no desde fuera de ella.

Otro ejemplo de encapsulamiento puede ser un método que calcule el interés de una cuenta bancaria, el cual puede ser un proceso complejo que involucre varios cálculos. Este método se puede encapsular en la clase \enquote*{CuentaBancaria} y solo exponer el resultado final para ser utilizado por otros objetos externos. Esto hace que el código sea más modular y fácil de mantener.

\subsection{Polimorfismo}

El polimorfismo es un concepto clave en la programación orientada a objetos que se refiere a la capacidad de objetos de diferentes clases de responder al mismo mensaje o método de diferentes maneras. Esto significa que un método puede ser implementado de manera diferente por diferentes clases, pero su llamada por parte del objeto no varía, es decir, el método se llama de la misma manera independientemente de la clase a la que pertenece el objeto.

Un ejemplo común de polimorfismo es la función \enquote*{draw()} en un programa de gráficos. Diferentes objetos gráficos, como un círculo, un cuadrado o un triángulo, podrían tener su propia implementación de la función \enquote*{draw()}, que dibuja el objeto correspondiente. A pesar de que cada objeto tiene su propia implementación de la función \enquote*{draw()}, se puede llamar a la función de la misma manera para todos los objetos, lo que permite una programación más modular y flexible.

El polimorfismo se puede implementar en POO utilizando la herencia y las interfaces. En la herencia, una clase hija puede tener una implementación diferente de un método heredado de la clase padre. En las interfaces, varias clases pueden implementar una misma interfaz, cada una con su propia implementación de los métodos de la interfaz.

En términos de sintaxis, el polimorfismo se logra a través de la creación de clases con métodos que tienen la misma firma (nombre y parámetros) pero diferentes implementaciones. Cuando se llama a un método en un objeto, se ejecuta la implementación correspondiente de ese objeto.

Te presento un ejemplo:
\begin{lstlisting}
using System;

public class Animal
{
    public virtual void HacerSonido()
    {
        Console.WriteLine("Hace algun sonido");
    }
}

public class Perro : Animal
{
    public override void HacerSonido()
    {
        Console.WriteLine("Ladra");
    }
}

public class Gato : Animal
{
    public override void HacerSonido()
    {
        Console.WriteLine("Maulla");
    }
}

class Program
{
    static void Main(string[] args)
    {
        Animal miAnimal = new Animal();
        miAnimal.HacerSonido();  // output: "Hace algun sonido"

        miAnimal = new Perro();
        miAnimal.HacerSonido();  // output: "Ladra"

        miAnimal = new Gato();
        miAnimal.HacerSonido();  // output: "Maulla"
    }
}
\end{lstlisting}

En este ejemplo, tenemos una clase Animal que tiene un método virtual HacerSonido(). Luego creamos dos clases, Perro y Gato, que heredan de Animal y sobrescriben el método HacerSonido(). Finalmente, en el método Main creamos instancias de Animal, Perro y Gato y llamamos al método HacerSonido(). Dependiendo del tipo de objeto al que se hace referencia, se invoca la implementación correspondiente del método HacerSonido(). Esto es un ejemplo de polimorfismo en acción.

\subsection*{Estructuras vs clases}

Las estructuras son muy prácticas cuando se desea manejar datos que tienen un vínculo entre sí. Por ejemplo, en una aplicación contable, los datos relativos a los clientes (código cliente, apellido, nombre, dirección) se pueden gestionar más fácilmente bajo la forma de una estructura que por variables individuales.

\begin{itemize}
    \item Las estructuras son tipos de valor, mientras que las clases son tipos de referencia. Esto significa que cuando una variable de estructura se asigna a otra variable, se realiza una copia de los datos de la estructura, mientras que cuando se asigna una variable de clase a otra, se está haciendo referencia al mismo objeto en memoria.
    \item Las estructuras usan la asignación de pila, lo que significa que se almacenan en la memoria del programa que se encuentra en la parte superior de la pila. Las clases, por otro lado, usan la asignación del montón, lo que significa que se almacenan en la memoria dinámica del programa.
    \item Los miembros de una estructura son públicos de forma predeterminada, mientras que en una clase, solo los métodos y las propiedades públicas son públicos de forma predeterminada.
    \item Una estructura no requiere un constructor, mientras que una clase sí lo requiere. Además, las estructuras solo pueden tener constructores no compartidos si toman parámetros, mientras que las clases pueden tener constructores con o sin parámetros.
\end{itemize}

Te dejo un ejemplo:
\begin{lstlisting}
using System;

namespace EjemploEstructuraYClase
{
    // Declaracndo de una estructura
    struct PuntoEstructura
    {
        public int X;
        public int Y;

        public PuntoEstructura(int x, int y)
        {
            X = x;
            Y = y;
        }
    }

    // Declaracndo de una clase
    class PuntoClase
    {
        public int X;
        public int Y;

        public PuntoClase(int x, int y)
        {
            X = x;
            Y = y;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // creando de un objeto de la estructura
            PuntoEstructura puntoEstructura = new PuntoEstructura(5, 10);

            // creando de un objeto de la clase
            PuntoClase puntoClase = new PuntoClase(10, 20);

            // Modificando del valor de X en el objeto de la estructura
            puntoEstructura.X = 7;

            // Modificando del valor de X en el objeto de la clase
            puntoClase.X = 15;

            // inprimir los valores de X e Y en el objeto de la estructura
            Console.WriteLine("PuntoEstructura: X = {0}, Y = {1}", puntoEstructura.X, puntoEstructura.Y);

            // inprimir los valores de X e Y en el objeto de la clase
            Console.WriteLine("PuntoClase: X = {0}, Y = {1}", puntoClase.X, puntoClase.Y);
        }
    }
}
\end{lstlisting}

En este ejemplo, se define una estructura PuntoEstructura y una clase PuntoClase que tienen los mismos campos X e Y. Luego, se crean objetos de ambas y se modifica el valor del campo X en cada uno de ellos. Finalmente, se imprimen los valores de los campos X e Y de ambos objetos.

La principal diferencia entre una estructura y una clase es que las estructuras son tipos de valor y las clases son tipos de referencia. Esto significa que cuando se crea un objeto de una estructura, se almacena en la pila de la memoria del programa, mientras que cuando se crea un objeto de una clase, se almacena en el montón de la memoria del programa y se guarda una referencia (un puntero) a su ubicación en la memoria. En este ejemplo, podemos ver que cuando se modifica el valor de X en el objeto de la estructura, se modifica directamente el valor almacenado en la pila. En cambio, cuando se modifica el valor de X en el objeto de la clase, se modifica el valor almacenado en el montón, y se actualiza la referencia a ese objeto en el programa.

\subsection{¿Cómo operar con clases?}

Para trabajar con clases en la programación orientada a objetos, es necesario definir los atributos y métodos que conforman la clase. Los atributos son las características o datos que tiene un objeto de esa clase, mientras que los métodos son las acciones que se pueden realizar con ese objeto.

Por ejemplo, si estamos creando una clase \enquote*{Perro}, podríamos definir los atributos \enquote*{nombre}, \enquote*{raza} y \enquote*{edad}, y los métodos \enquote*{ladrar} y \enquote*{correr}. La sintaxis para definir una clase en C\# sería la siguiente:

\begin{lstlisting}
public class Perro {
    // atributos
    public string nombre;
    public string raza;
    public int edad;

    // metodos
    public void ladrar() {
        Console.WriteLine("Guau");
    }

    public void correr() {
        Console.WriteLine("Estoy corriendo");
    }
    }
\end{lstlisting}

En este ejemplo, la clase \enquote*{Perro} tiene tres atributos (nombre, raza y edad) y dos métodos (ladrar y correr). Los atributos son públicos, lo que significa que se pueden acceder desde cualquier parte del código. Sin embargo, esto puede no ser deseable en algunos casos, por lo que se puede usar el encapsulamiento para proteger los datos de la clase.

Para encapsular los datos de una clase, se pueden utilizar los modificadores de acceso \enquote*{private}, \enquote*{protected} o \enquote*{internal} para controlar quién puede acceder a los atributos y métodos de la clase. Por ejemplo, podríamos modificar la clase \enquote*{Perro} para que los atributos sean privados y solo se puedan acceder a través de métodos públicos:

\begin{lstlisting}
public class Perro {
    // atributos privados
    private string nombre;
    private string raza;
    private int edad;

    // metodos publicos para acceder a los atributos
    public string GetNombre() {
        return nombre;
    }

    public void SetNombre(string nombre) {
        this.nombre = nombre;
    }

    public string GetRaza() {
        return raza;
    }

    public void SetRaza(string raza) {
        this.raza = raza;
    }

    public int GetEdad() {
        return edad;
    }

    public void SetEdad(int edad) {
        this.edad = edad;
    }

    // metodos publicos
    public void Ladrar() {
        Console.WriteLine("Guau");
    }

    public void Correr() {
        Console.WriteLine("Estoy corriendo");
    }
}
\end{lstlisting}   
En este ejemplo, los atributos \enquote*{nombre}, \enquote*{raza} y \enquote*{edad} son privados y solo se pueden acceder a través de los métodos \enquote*{Get} y \enquote*{Set} correspondientes. Los métodos \enquote*{Ladrar} y \enquote*{Correr} siguen siendo públicos y se pueden acceder desde cualquier parte del código.

Para acceder a los métodos y atributos de una clase en la programación orientada a objetos, primero se debe instanciar la clase, lo que crea un objeto que es una instancia de esa clase. Luego, se puede acceder a los métodos y atributos a través de ese objeto utilizando el operador de punto (.) seguido del nombre del método o atributo.

En el ejemplo anterior de la clase \enquote*{Perro} que has proporcionado, los métodos y atributos están definidos con modificadores de acceso \enquote*{public} y \enquote*{private}. Esto significa que los atributos \enquote*{nombre}, \enquote*{raza} y \enquote*{edad} son privados, lo que significa que solo se pueden acceder a ellos desde dentro de la propia clase. Sin embargo, hay métodos \enquote*{Get} y \enquote*{Set} públicos para cada uno de estos atributos, lo que permite a otros objetos acceder y modificar estos atributos desde fuera de la clase.

Para establecer el nombre de un objeto de la clase \enquote*{Perro}, se puede llamar al método \enquote*{SetNombre} y pasar el nombre deseado como argumento:
\begin{lstlisting}
    Perro miPerro = new Perro();
    miPerro.SetNombre("Fido");
\end{lstlisting}

Para recuperar el valor del atributo \enquote*{nombre}, se puede llamar al método \enquote*{GetNombre}:
\begin{lstlisting}
    string nombreDelPerro = miPerro.GetNombre();
\end{lstlisting}
También hay dos métodos públicos adicionales, \enquote*{Ladrar} y \enquote*{Correr}, que pueden ser llamados para realizar las acciones correspondientes en un objeto de la clase \enquote*{Perro}.

En general, el uso de métodos \enquote*{Get} y \enquote*{Set} públicos para acceder y modificar atributos privados se conoce como encapsulamiento. Esto ayuda a asegurar que los datos de la clase sean manejados de manera controlada y consistente, lo que puede ser importante para evitar errores y garantizar la integridad de los datos.

\subsection{Niveles de acceso (Scope)}

En la programación orientada a objetos, los niveles de acceso determinan la visibilidad de los miembros de una clase (atributos, métodos, propiedades) desde el exterior de la misma.

Existen 4 niveles de acceso en C\#:

\begin{itemize}
\item \textbf{Public:} El miembro es accesible desde cualquier parte del programa.
\item \textbf{Private:} El miembro solo es accesible desde dentro de la misma clase.
\item \textbf{Protected:} El miembro es accesible desde dentro de la misma clase y desde las clases derivadas (heredadas).
\item \textbf{Internal:} El miembro es accesible desde cualquier clase del mismo ensamblado (assembly). Un ensamblado es un archivo .dll o .exe que contiene uno o varios módulos.
\end{itemize}

La sintaxis para definir el nivel de acceso de un miembro es mediante los modificadores de acceso \textbf{public}, \textbf{private}, \textbf{protected} o \textbf{internal}, seguidos del tipo de miembro y su nombre. Por ejemplo:

\begin{lstlisting}
public class MiClase {
    public int miVariablePublica;
    private int miVariablePrivada;
    protected int miVariableProtegida;
    internal int miVariableInterna;
}
\end{lstlisting}

En este ejemplo, se han declarado cuatro variables de diferentes niveles de acceso en una clase llamada \emph{MiClase}. La variable \emph{miVariablePublica} es pública y, por tanto, puede ser accedida desde cualquier parte del programa. La variable \emph{miVariablePrivada} es privada, por lo que solo es accesible desde dentro de la misma clase. La variable \emph{miVariableProtegida} es protegida, lo que significa que es accesible desde dentro de la misma clase y desde cualquier clase derivada de ella. La variable \emph{miVariableInterna} es interna, por lo que es accesible desde cualquier clase dentro del mismo ensamblado, un ensamblado es una colección de tipos y recursos compilados para funcionar en conjunto y formar una unidad lógica de funcionalidad. Los ensamblados adoptan la forma de un archivo ejecutable (.exe) o de biblioteca de vínculos dinámicos (.dll), y son los bloques de creación de las aplicaciones.

Es importante destacar que el uso adecuado de los niveles de acceso contribuye a escribir código más seguro y fácil de mantener, ya que restringe el acceso a los miembros que no deberían ser modificados o accedidos desde fuera de la clase.

\subsection{Clases Abstractas}

En la programación orientada a objetos, una clase abstracta es una clase que no puede ser instanciada y solo puede ser utilizada como una clase base para otras clases. Es decir, una clase abstracta solo puede ser heredada y sus métodos abstractos deben ser implementados en las clases derivadas. Por otro lado, una clase virtual es una clase que puede ser instanciada, pero sus métodos virtuales pueden ser reemplazados por las clases derivadas.

A continuación, veamos un ejemplo de una clase abstracta Animal con un método abstracto HacerSonido:

\begin{lstlisting}
public abstract class Animal {
    public abstract void HacerSonido();
}

public class Perro : Animal {
    public override void HacerSonido() {
        Console.WriteLine("Guau guau!");
    }
}

public class Gato : Animal {
    public override void HacerSonido() {
        Console.WriteLine("Miau miau!");
    }
}
\end{lstlisting}

En este ejemplo, la clase Animal es una clase abstracta que define un método abstracto HacerSonido. Las clases Perro y Gato heredan de la clase Animal y deben implementar el método HacerSonido.

Por otro lado, las clases virtuales permiten la creación de métodos virtuales que pueden ser reemplazados por las clases derivadas. A continuación, veamos un ejemplo de una clase virtual Figura con un método virtual CalcularArea:

\begin{lstlisting}
public class Figura {
    public virtual double CalcularArea() {
        return 0;
    }
}

public class Circulo : Figura {
    private double radio;

    public Circulo(double radio) {
        this.radio = radio;
    }

    public override double CalcularArea() {
        return Math.PI * radio * radio;
    }
    public Circulo(double radio) {
        this.radio = radio;
    }

    public override double CalcularArea() {
        return Math.PI * radio * radio;
    }
    public Rectangulo(double baseFigura, double altura) {
        this.baseFigura = baseFigura;
        this.altura = altura;
    }

    public override double CalcularArea() {
        return baseFigura * altura;
    }
}
\end{lstlisting}

En este ejemplo, la clase Figura es una clase virtual que define un método virtual CalcularArea. Las clases Circulo y Rectangulo heredan de la clase Figura y reemplazan el método CalcularArea con su propia implementación.

\subsection{Clases selladas y estáticas}

En C\#, las clases selladas y estáticas son dos conceptos que se utilizan para restringir la herencia y la creación de objetos, respectivamente.

\subsubsection{Clases selladas}

Las clases selladas son aquellas que no se pueden heredar. Es decir, una vez definida una clase sellada, no se pueden crear subclases a partir de ella. Para declarar una clase sellada, se utiliza la palabra clave sealed. Por ejemplo:

\begin{lstlisting}
sealed class MiClaseSellada {
// Codigo de la clase
}
\end{lstlisting}

En este caso, la clase MiClaseSellada es sellada y no se puede heredar de ella.

Las clases selladas son útiles cuando queremos evitar que se modifique el comportamiento de una clase en subclases o cuando queremos garantizar que una clase se mantendrá inmutable.

\subsubsection{Clases estáticas}

Las clases estáticas son aquellas que no se pueden instanciar. Es decir, no se pueden crear objetos a partir de ellas. En lugar de eso, los miembros de una clase estática se acceden utilizando el nombre de la clase. Para declarar una clase estática, se utiliza la palabra clave static. Por ejemplo:

\begin{lstlisting}
static class MiClaseEstatica {
public static void MiMetodoEstatico() {
// Codigo del metodo
}
}
\end{lstlisting}

En este caso, la clase MiClaseEstatica es estática y el método MiMetodoEstatico se puede llamar utilizando el nombre de la clase:

\begin{lstlisting}
MiClaseEstatica.MiMetodoEstatico();
\end{lstlisting}

Las clases estáticas son útiles cuando queremos agrupar métodos y propiedades relacionados, pero no necesitamos crear instancias de la clase. También son útiles cuando queremos evitar el gasto de memoria que implica crear múltiples instancias de una clase.

\subsection{Metodos de extensión, constructores y destructores}

Los métodos de extensión, los constructores y los destructores son conceptos importantes en la programación orientada a objetos.

\subsubsection*{Métodos de extensión}

Un método de extensión es un método estático que se define en una clase estática y que se utiliza para agregar funcionalidad a una clase existente sin tener que modificar la clase original. Los métodos de extensión son útiles cuando no se tiene acceso al código fuente de la clase original o cuando se desea mantener la compatibilidad con versiones anteriores de la clase.

La sintaxis de un método de extensión es similar a la de un método normal, pero con la adición de la palabra clave "this" antes del primer parámetro. El primer parámetro es el objeto al que se aplicará el método de extensión.

Un ejemplo de un método de extensión en C\# que agrega una función de \enquote*{reverse} a la clase \enquote*{string} sería:
\begin{lstlisting}
public static class StringExtensions {
public static string Reverse(this string str) {
    char[] chars = str.ToCharArray();
    Array.Reverse(chars);
    return new string(chars);
    }
}

// Uso del metodo de extension
string s = "Hola mundo";
string reversed = s.Reverse();
Console.WriteLine(reversed);
\end{lstlisting}

\subsubsection*{Constructores}

Un constructor es un método especial que se llama automáticamente cuando se crea un objeto de una clase. El constructor se utiliza para inicializar los valores de los campos y propiedades de la clase.

En C\#, el constructor tiene el mismo nombre que la clase y no tiene tipo de retorno. Puede haber varios constructores con diferentes parámetros, lo que se conoce como sobrecarga de constructores.

Un ejemplo de un constructor en C\# sería:

\begin{lstlisting}
public class Persona {
    public string Nombre { get; set; }
    public int Edad { get; set; }

    public Persona(string nombre, int edad) {
        this.Nombre = nombre;
        this.Edad = edad;
    }
}

// Uso del constructor
Persona persona = new Persona("Juan", 30);
\end{lstlisting}

\subsubsection*{Destructores}

Un destructor es un método especial que se llama automáticamente cuando un objeto de una clase es destruido por el recolector de basura. El destructor se utiliza para liberar recursos no administrados como archivos, conexiones de bases de datos, etc.

En C\#, el destructor tiene el mismo nombre que la clase y comienza con el símbolo "~". El destructor no tiene parámetros ni tipo de retorno.

Un ejemplo de un destructor en C\# sería:

\begin{lstlisting}
public class ConexionBD {
    private string cadenaConexion;
    private SqlConnection conexion;

    public ConexionBD(string cadenaConexion) {
        this.cadenaConexion = cadenaConexion;
        this.conexion = new SqlConnection(cadenaConexion);
        this.conexion.Open();
    }

    ~ConexionBD() {
        this.conexion.Close();
    }
}

// Uso del destructor
ConexionBD conexion = new ConexionBD("cadena de conexion");
\end{lstlisting}

\subsubsection*{Métodos con cuerpo de expresión (Expression-bodied members)}

En C\#, los métodos, propiedades, constructores y destructores pueden ser definidos utilizando el cuerpo de expresión en lugar de un bloque de código. Esto es conocido como \enquote*{métodos con cuerpo de expresión} o \enquote*{expression-bodied members} en inglés.

Por ejemplo, en lugar de definir un método como:

\begin{lstlisting}
public int Sumar(int a, int b) {
return a + b;
}
\end{lstlisting}

Se puede definir utilizando el cuerpo de expresión de la siguiente manera:

\begin{lstlisting}
public int Sumar(int a, int b) => a + b;
\end{lstlisting}

Los métodos con cuerpo de expresión pueden ser útiles cuando se tiene una función simple que se puede definir en una sola línea de código. También pueden hacer que el código sea más legible al reducir la cantidad de caracteres utilizados.

También se pueden utilizar los métodos con cuerpo de expresión en propiedades, constructores y destructores. Por ejemplo:

\begin{lstlisting}
public class Persona {
public string Nombre { get; set; }
public int Edad { get; set; }
public Persona(string nombre, int edad) => (Nombre, Edad) = (nombre, edad);

~Persona() => Console.WriteLine($"Adios {Nombre}"); \\$
}
\end{lstlisting}

En este ejemplo, el constructor utiliza el cuerpo de expresión para inicializar las propiedades \enquote*{Nombre} y \enquote*{Edad} en una sola línea de código. El destructor utiliza el cuerpo de expresión para escribir un mensaje de despedida en la consola.

\subsection{Sobrecarga de métodos}

La sobrecarga de métodos (en inglés, method overloading) es una técnica de programación en la que se definen varios métodos con el mismo nombre en una misma clase, pero con diferentes parámetros. En otras palabras, la sobrecarga de métodos permite tener varios métodos con el mismo nombre, pero que aceptan diferentes tipos de datos como argumentos.

Un ejemplo de sobrecarga de métodos sería una clase \enquote*{Calculadora} que tenga varios métodos con el nombre \enquote*{Sumar}, pero que acepten diferentes tipos de argumentos. Por ejemplo, podría tener los siguientes métodos:

\begin{lstlisting}
public int Sumar(int a, int b)
{
    return a + b;
}

public float Sumar(float a, float b)
{
    return a + b;
}

public double Sumar(double a, double b)
{
    return a + b;
}
\end{lstlisting}

En este ejemplo, la clase \enquote*{Calculadora} tiene tres métodos diferentes llamados \enquote*{Sumar}, pero cada uno acepta un tipo de datos diferente: enteros, números en coma flotante y números de doble precisión. Esto permite que el usuario pueda llamar al método "Sumar" con diferentes tipos de datos y obtener el resultado esperado.

\subsection{Interfaces}

Una interfaz es un tipo de referencia similar a una clase que solo contiene miembros abstractos, como métodos, propiedades, eventos e indexadores. Las interfaces no proporcionan implementaciones para estos miembros, sino que definen una lista de miembros que deben estar presentes en cualquier clase o estructura que implemente la interfaz.

Las interfaces se utilizan para definir contratos que las clases deben cumplir, lo que significa que si una clase implementa una interfaz, debe proporcionar implementaciones para todos los miembros de la interfaz. Esto permite a los desarrolladores crear código más modular y extensible.

Por ejemplo, podemos definir una interfaz IVehiculo que contenga métodos como Arrancar(), Acelerar() y Frenar(). Luego, podemos tener varias clases que implementen esta interfaz, como Automovil, Motocicleta y Camión. Cada una de estas clases proporcionaría una implementación única para los métodos de la interfaz, pero todas tendrían los mismos métodos.

La herencia múltiple se refiere a la capacidad de una clase de heredar de más de una clase o interfaz. En C\#, las clases solo pueden heredar de una clase base, pero pueden implementar varias interfaces. Esto permite que una clase tenga comportamientos de múltiples fuentes sin la necesidad de heredar de múltiples clases, lo que puede resultar en una jerarquía de clases compleja y difícil de mantener.

Por ejemplo, podemos tener una clase VehiculoElectrico que implemente tanto la interfaz IVehiculo como una interfaz IElectrico, que contiene métodos para cargar y descargar la batería. De esta manera, podemos asegurarnos de que todos los vehículos eléctricos tengan los mismos métodos básicos de vehículo, mientras que también proporcionamos funcionalidad específica para los vehículos eléctricos.

Aquí un ejemplo:
\begin{lstlisting}
public interface IVehiculo {
    void Arrancar();
    void Acelerar();
    void Frenar();
    void Apagar();
}

public class Automovil : IVehiculo {
    public void Arrancar() {
        Console.WriteLine("El automovil arranco.");
    }

    public void Acelerar() {
        Console.WriteLine("El automovil esta acelerando.");
    }

    public void Frenar() {
        Console.WriteLine("El automovil esta frenando.");
    }

    public void Apagar() {
        Console.WriteLine("El automovil se apago.");
    }
}

public class Moto : IVehiculo {
    public void Arrancar() {
        Console.WriteLine("La moto arranco.");
    }

    public void Acelerar() {
        Console.WriteLine("La moto esta acelerando.");
    }

    public void Frenar() {
        Console.WriteLine("La moto esta frenando.");
    }

    public void Apagar() {
        Console.WriteLine("La moto se apago.");
    }
}
\end{lstlisting}

En este ejemplo, la interfaz IVehiculo define los métodos Arrancar(), Acelerar(), Frenar() y Apagar(). La clase Automovil y Moto implementan esta interfaz y proporcionan una implementación concreta para estos métodos. Esto permite que las instancias de Automovil y Moto se traten como instancias de IVehiculo y se puedan pasar a cualquier método que acepte un parámetro del tipo IVehiculo.

La interfaz IVehiculo también se puede usar para realizar herencia múltiple de manera limitada en C\#, ya que una clase puede implementar múltiples interfaces. Esto permite que una clase tenga la funcionalidad de varias interfaces diferentes, lo que puede ser útil en situaciones donde una clase necesita proporcionar comportamiento para varias funcionalidades diferentes.

\newpage
\section{Conceptos avanzados}

A medida que se avanza en el aprendizaje de la programación en C\#, se encuentran conceptos más avanzados que pueden mejorar la calidad y eficiencia de nuestro código. Estos conceptos incluyen delegados, métodos anónimos, tipos dinámicos, enumerados, espacios de nombres, tuplas, diccionarios, boxing y unboxing, serialización JSON, eventos, tratamiento de excepciones, trabajo con archivos y streams, y programación asíncrona.

Cada uno de estos temas tiene su propia utilidad y aplicabilidad en diferentes escenarios y situaciones de programación. En esta sección, se explicará cada uno de ellos con ejemplos prácticos y claros para que puedas entender su funcionamiento y cómo podemos aplicarlos en tus proyectos de C\#.

\subsection{Delegados}

Los delegados son una característica importante de C\# que permiten la encapsulación de métodos en objetos y su uso como argumentos y valores de retorno de otros métodos. Un delegado es esencialmente un tipo de referencia que puede apuntar a un método con una firma determinada. Se puede pensar en un delegado como un puntero a un método en otros lenguajes de programación.

Para crear un delegado, primero se debe definir un tipo de delegado que tenga la misma firma que el método al que se va a hacer referencia. Esto se hace mediante la definición de un delegado utilizando la palabra clave delegate y especificando los parámetros y el tipo de retorno del método al que se va a hacer referencia. A continuación veamos un ejemplo:

\begin{lstlisting}
delegate int OperacionMatematica(int a, int b);
\end{lstlisting}

En este ejemplo, se define un delegado llamado OperacionMatematica que tiene dos parámetros enteros y devuelve un valor entero. Una vez que se ha definido el tipo de delegado, se puede crear una instancia del delegado y asignarle una referencia a un método que tenga la misma firma que el delegado. A continuación veamos un ejemplo:

\begin{lstlisting}
int Suma(int a, int b) {
return a + b;
}

OperacionMatematica operacion = Suma;
\end{lstlisting}

En este ejemplo, se define un método Suma que toma dos parámetros enteros y devuelve la suma de estos parámetros. A continuación, se crea una instancia del delegado OperacionMatematica y se le asigna una referencia al método Suma mediante el operador de asignación =.

Los delegados también pueden utilizarse para añadir y eliminar métodos de un conjunto de métodos que se ejecutarán cuando se llame al delegado. Esto se hace mediante el operador += para añadir un método y -= para eliminar un método. A continuación veamos un ejemplo:

\begin{lstlisting}
OperacionMatematica operacion = Suma;
operacion += Resta;
operacion += Multiplicacion;
operacion -= Resta;
\end{lstlisting}

En este ejemplo, se crea una instancia del delegado OperacionMatematica y se le asigna una referencia al método Suma. A continuación, se añaden los métodos Resta y Multiplicacion al delegado mediante el operador +=. Finalmente, se elimina el método Resta del delegado mediante el operador -=.

Es importante tener en cuenta que los métodos añadidos a un delegado se ejecutan en el orden en que se añadieron. Por lo tanto, en el ejemplo anterior, se ejecutará primero el método Suma, seguido del método Multiplicacion.

Además, los delegados también pueden utilizarse como atributos en clases y estructuras, lo que permite crear eventos que pueden ser suscritos y desuscritos por otros métodos. Los eventos son un concepto importante en la programación de GUI y se utilizan para notificar a los objetos cuando ocurren ciertos eventos, como hacer clic en un botón.

Te dejo un ejemplo:

\begin{lstlisting}
using System;

// Declaracion de un delegado
delegate void MiDelegado(int parametro);

class Program
{
    static void Main(string[] args)
    {
        // Creacion de una instancia del delegado y asignacion del metodo que queremos ejecutar
        MiDelegado miDelegado = new MiDelegado(MetodoEjemplo);

        // Invocacion del delegado
        miDelegado(5); // Salida: "El parametro recibido es: 5"

        // Agregar otro metodo al delegado
        miDelegado += MetodoAdicional;

        // Invocacion del delegado nuevamente
        miDelegado(10); // Salida: "El parametro recibido es: 10" y "Este es otro metodo."

        // Eliminar un metodo del delegado
        miDelegado -= MetodoEjemplo;

        // Invocacion del delegado una ultima vez
        miDelegado(15); // Salida: "Este es otro metodo."
    }

    static void MetodoEjemplo(int parametro)
    {
        Console.WriteLine("El parametro recibido es: " + parametro);
    }

    static void MetodoAdicional(int parametro)
    {
        Console.WriteLine("Este es otro metodo.");
    }
}    
\end{lstlisting}

En este ejemplo, se define un delegado llamado MiDelegado que acepta un parámetro entero y no devuelve nada (void). Luego, se crea una instancia de este delegado y se le asigna el método MetodoEjemplo. Al invocar el delegado, se ejecuta el método asignado (MetodoEjemplo) con el parámetro indicado.

Posteriormente, se añade otro método al delegado (MetodoAdicional) y se invoca el delegado nuevamente, lo que hace que se ejecuten ambos métodos en orden. Luego, se elimina el método MetodoEjemplo del delegado y se invoca el delegado una última vez, lo que hace que solo se ejecute el método restante (MetodoAdicional).

\subsection{Metodos anonimos}

Los métodos anónimos son bloques de código que se pueden utilizar como parámetros de delegados. A diferencia de los métodos regulares, los métodos anónimos no tienen un nombre y se definen en línea. Estos métodos son útiles en situaciones donde se necesita pasar un pequeño bloque de código como parámetro a otro método o función.

Un ejemplo de esto es la siguiente definición de un delegado que acepta un método anónimo como parámetro:

\begin{lstlisting}
delegate void MiDelegado(int x, int y);

class Program
{
static void Main(string[] args)
    {
    // Definir un delegado con un metodo anonimo como parametro
    MiDelegado miDelegado = delegate (int x, int y) {
        Console.WriteLine($"La suma de {x} y {y} es: {x + y}"); \\$
        };
    // Llamar al delegado
    miDelegado(2, 3);
    }
}
\end{lstlisting}

En este ejemplo, se define un delegado llamado \emph{MiDelegado} que acepta dos parámetros enteros y no devuelve ningún valor. A continuación, se crea una instancia del delegado y se define un método anónimo dentro de él que toma los dos parámetros y los suma. Luego, se llama al delegado y se le pasan los valores 2 y 3 como argumentos.

Cabe destacar que los métodos anónimos también pueden ser utilizados en otros contextos, como en la definición de eventos o en la implementación de LINQ (Language Integrated Query).

\subsection*{Tipos dinamicos}

Los tipos dinámicos son un tipo de datos que se introdujo en C\# 4.0 que permiten omitir la comprobación de tipos estáticos en tiempo de compilación y posponerla hasta tiempo de ejecución. Esto significa que los objetos de tipos dinámicos pueden contener cualquier tipo de objeto, y se puede llamar a cualquier método o propiedad en tiempo de ejecución sin generar un error de compilación.

Para definir un objeto dinámico, se utiliza la palabra clave "dynamic". Por ejemplo:

\begin{lstlisting}
dynamic miObjeto = "Hola mundo";
Console.WriteLine(miObjeto.GetType()); // Imprime "System.String"
miObjeto = 123;
Console.WriteLine(miObjeto.GetType()); // Imprime "System.Int32"
\end{lstlisting}

En el ejemplo anterior, se crea un objeto dinámico "miObjeto" y se le asigna primero un valor de cadena y luego un valor entero. En tiempo de ejecución, se llama al método "GetType()" para imprimir el tipo de objeto que contiene en ese momento.

Es importante tener en cuenta que el uso excesivo de tipos dinámicos puede hacer que el código sea más difícil de entender y depurar. Por lo tanto, se recomienda utilizarlos con moderación y solo cuando sea necesario.

\subsection{Enumerados}

Un enumerado es un tipo de valor que tiene un conjunto de constantes con nombre. Cada constante enum tiene un valor asignado implícitamente y es del tipo del enumerado.

Un ejemplo de enumerado es el siguiente:

\begin{lstlisting}
enum Direccion {
Norte,
Sur,
Este,
Oeste
}
\end{lstlisting}

En este ejemplo, definimos un tipo de enumerado llamado \enquote*{Direccion} con cuatro constantes enumeradas: \enquote*{Norte}, \enquote*{Sur}, \enquote*{Este} y \enquote*{Oeste}.

Podemos usar un enumerado de la siguiente manera:

\begin{lstlisting}
Direccion dir = Direccion.Norte;
if (dir == Direccion.Norte) {
Console.WriteLine("Voy hacia el norte");
}
\end{lstlisting}

También podemos iterar sobre todos los valores de un enumerado utilizando el método estático \enquote*{GetValues} de la clase \enquote*{Enum}:

\begin{lstlisting}
foreach (Direccion d in Enum.GetValues(typeof(Direccion))) {
Console.WriteLine(d);
}
\end{lstlisting}

Este código imprimirá lo siguiente:

\begin{lstlisting}
Norte
Sur
Este
Oeste
\end{lstlisting}

\subsection{Espacios de nombres}

Los espacios de nombres en C\# son una forma de agrupar y organizar clases, estructuras, interfaces, enumeraciones y otros tipos en grupos lógicos y coherentes. Un espacio de nombres puede ser considerado como un contenedor para un conjunto de tipos relacionados.

Para acceder a los miembros de un espacio de nombres en C\#, podemos utilizar la palabra reservada "using". Esto nos permite omitir la necesidad de especificar el espacio de nombres completo cada vez que queramos utilizar una clase dentro del mismo. Por ejemplo, si queremos utilizar la clase "StringBuilder" del espacio de nombres "System.Text", podemos incluir una directiva "using" al principio de nuestro archivo:

\begin{lstlisting}
using System.Text;

// Ahora podemos utilizar la clase StringBuilder sin especificar el espacio de nombres completo
StringBuilder sb = new StringBuilder();
\end{lstlisting}

También es posible utilizar un alias para un espacio de nombres si queremos hacer referencia a él de una manera más corta o clara. Por ejemplo, podemos crear un alias para el espacio de nombres "System.Text" de la siguiente manera:

\begin{lstlisting}
using txt = System.Text;

// Ahora podemos utilizar el alias "txt" en lugar del espacio de nombres completo "System.Text"
txt.StringBuilder sb = new txt.StringBuilder();
\end{lstlisting}

Un buen uso de los espacios de nombres nos ayuda a organizar nuestro código y a evitar conflictos de nombres entre diferentes clases y librerías.

\subsection{Tuplas}

Las tuplas son un tipo de dato que permite agrupar múltiples elementos de diferentes tipos en un solo objeto. Las tuplas también pueden contener métodos y se pueden iterar usando un foreach. Sin embargo, es importante tener en cuenta que las tuplas tienen algunos límites. Por ejemplo, no se pueden agregar ni eliminar elementos de una tupla después de su creación, y las tuplas con más de siete elementos no se pueden utilizar con ciertas características de C\# como el parámetro "out" en métodos.

En cuanto a si son más optimas que otros tipos de datos, depende del caso de uso específico. Las tuplas son útiles para agrupar elementos de diferentes tipos en una sola estructura, lo que puede mejorar la legibilidad del código. Pero en términos de rendimiento, puede haber casos en los que otros tipos de datos sean más eficientes.

Un ejemplo de uso de tuplas en C\# es el siguiente:

\begin{lstlisting}
// Crear una tupla
var miTupla = (1, "Hola", true);

// Acceder a los elementos de la tupla
Console.WriteLine(miTupla.Item1); // salida: 1
Console.WriteLine(miTupla.Item2); // salida: Hola
Console.WriteLine(miTupla.Item3); // salida: True

// Declarar tuplas con nombres de elementos
var otraTupla = (edad: 30, nombre: "Juan", ciudad: "Bogota");

// Acceder a los elementos de la tupla por nombre
Console.WriteLine(otraTupla.edad); // salida: 30
Console.WriteLine(otraTupla.nombre); // salida: Juan
Console.WriteLine(otraTupla.ciudad); // salida: Bogota

// Tuplas como parametros y retorno de metodo
(int, int) Calcular(int a, int b) {
int suma = a + b;
int producto = a * b;
return (suma, producto);
}

// Llamar al metodo y desempaquetar los valores de la tupla resultante
var resultado = Calcular(2, 3);
Console.WriteLine(resultado.Item1); // salida: 5
Console.WriteLine(resultado.Item2); // salida: 6
\end{lstlisting}

En este ejemplo, veamos cómo crear y acceder a los elementos de tuplas, cómo declarar tuplas con nombres de elementos, cómo usar tuplas como parámetros y retorno de métodos, y cómo desempaquetar los valores de la tupla resultante.

\subsection{Diccionarios}

Un diccionario en C\# es una colección de pares clave-valor. Cada clave debe ser única en la colección y se utiliza para buscar su valor correspondiente. Los valores pueden ser de cualquier tipo de datos, incluyendo tipos de referencia y tipos de valor. Los diccionarios son útiles para almacenar y recuperar rápidamente información en función de una clave, y son una herramienta poderosa para la manipulación de datos en C\#.
\begin{itemize}
    \item Los diccionarios son una colección de pares de clave-valor.
    \item Se pueden agregar, eliminar y modificar elementos en un diccionario.
    \item Los métodos comunes en los diccionarios incluyen \emph{Add()}, \emph{ContainsKey()}, \emph{ContainsValue()}, \emph{Remove()}, \emph{Clear()}.
    \item Se puede iterar sobre un diccionario usando un \emph{foreach} loop.
    \item Los diccionarios son útiles para almacenar y buscar datos por una clave específica.
\end{itemize}

Ejemplo de creación y uso de un diccionario en C\#:
\begin{lstlisting}
Dictionary<string, int> diccionario = new Dictionary<string, int>();
diccionario.Add("uno", 1);
diccionario.Add("dos", 2);
diccionario.Add("tres", 3);

foreach (KeyValuePair<string, int> kvp in diccionario)
{
Console.WriteLine("Clave: {0}, Valor: {1}", kvp.Key, kvp.Value);
}

if (diccionario.ContainsKey("dos"))
{
int valor = diccionario["dos"];
Console.WriteLine("El valor para la clave 'dos' es {0}", valor);
}

diccionario.Remove("tres");

Console.WriteLine("Numero de elementos en el diccionario: {0}", diccionario.Count);
\end{lstlisting}

En este ejemplo, se crea un diccionario que asocia cadenas con enteros. Se agregan tres elementos al diccionario usando el método \emph{Add()}. Luego, se itera sobre el diccionario usando un \emph{foreach} loop, mostrando la clave y el valor de cada elemento. Se verifica si el diccionario contiene una clave específica usando el método \emph{ContainsKey()} y se accede al valor correspondiente usando la clave como índice. Se elimina un elemento del diccionario usando el método \emph{Remove()}. Finalmente, veamos el número de elementos restantes en el diccionario usando la propiedad \emph{Count}.

\subsection*{Boxing y unboxing}

El boxing y el unboxing son dos conceptos importantes en C\# que se utilizan para convertir tipos de datos de valor en objetos de referencia y viceversa.

Boxing se refiere al proceso de convertir un tipo de valor (como int, double, etc.) en un objeto de referencia (como object), mientras que unboxing se refiere al proceso inverso, es decir, convertir un objeto de referencia en su tipo de valor original.

Conceptos clave:
\begin{itemize}
\item Boxing: Conversión de un valor de tipo valor a un objeto de tipo objeto.
\item Unboxing: Conversión de un objeto de tipo objeto a un valor de tipo valor.
\item Overhead de Boxing y Unboxing.
\end{itemize}

Cuando se trabaja con tipos de valor en C\#, a veces es necesario convertirlos en objetos de tipo object para trabajar con ellos en un contexto que requiera un objeto. A esto se le llama "boxing". Por ejemplo, si se quiere almacenar un valor de tipo int en una colección de objetos, es necesario convertir el valor int en un objeto. Esto se puede hacer con la palabra clave box.

Por otro lado, cuando se tiene un objeto de tipo object que se sabe que es de un tipo de valor, es necesario extraer el valor de ese objeto para trabajar con él como un valor de tipo valor. A esto se le llama "unboxing". Esto se puede hacer con la palabra clave unbox.

El proceso de boxing y unboxing puede tener un costo alto de rendimiento, por lo que se debe tener cuidado al utilizarlo en situaciones críticas de rendimiento.

A continuación se presenta un ejemplo de boxing y unboxing:

\begin{lstlisting}
int x = 10;
object o = x; // boxing
int y = (int)o; // unboxing
\end{lstlisting}

\subsection*{Genericos}

Los genéricos son un mecanismo que permite definir clases, estructuras, interfaces y métodos que puedan trabajar con diferentes tipos de datos sin especificarlos previamente. Se utilizan para crear componentes reutilizables que pueden funcionar con diferentes tipos de datos.

El parámetro de tipo es la variable de tipo que se define al crear una clase o un método genérico. Se utiliza para indicar qué tipo de datos se va a utilizar en el momento de la creación de la instancia de la clase o llamada al método.

La sintaxis para definir un parámetro de tipo es la siguiente:

\begin{lstlisting}
class MiClase<T>
{
//...
}

void MiMetodo<T>(T parametro)
{
//...
}
\end{lstlisting}

En el ejemplo anterior, se define un parámetro de tipo T en la clase \emph{MiClase} y en el método \emph{MiMetodo}. Este parámetro puede ser cualquier tipo de dato, y se especifica en el momento de la creación de la instancia o llamada al método.

La utilización de genéricos permite escribir código más limpio y seguro, ya que se evitan conversiones innecesarias y se garantiza la compatibilidad de tipos en tiempo de compilación. Además, los genéricos son más eficientes en términos de rendimiento que la utilización de objetos de tipo \emph{Object}, ya que no requieren boxing y unboxing.

\subsection{Serialización JSON}


La serialización es el proceso de convertir un objeto en una secuencia de bytes para almacenarlo o transmitirlo. En el contexto de la programación, la serialización se utiliza para compartir datos entre diferentes aplicaciones o para almacenar datos en un formato que se pueda leer y escribir fácilmente.

JSON (JavaScript Object Notation) es un formato de intercambio de datos ligero y fácil de leer y escribir. La serialización de objetos a JSON se utiliza comúnmente en la comunicación entre aplicaciones web y en el almacenamiento de datos en sistemas de bases de datos NoSQL.

En C\#, la serialización de objetos a JSON se realiza utilizando la clase JsonSerializer que se encuentra en el espacio de nombres System.Text.Json. Esta clase proporciona una forma fácil de serializar y deserializar objetos a JSON.

La serialización de un objeto a JSON es tan sencillo como llamar al método Serialize de la clase JsonSerializer y pasarle el objeto a serializar como parámetro. El resultado de la serialización es una cadena JSON.

Aquí hay un ejemplo que serializa un objeto de tipo Persona a JSON:

\begin{lstlisting}
using System;
using System.Text.Json;

class Persona {
public string Nombre { get; set; }
public int Edad { get; set; }
}

class Program {
static void Main(string[] args) {
Persona p = new Persona { Nombre = "Juan", Edad = 30 };
string json = JsonSerializer.Serialize(p);
Console.WriteLine(json);
}
}
\end{lstlisting}

La salida de este ejemplo será la siguiente:

\begin{lstlisting}
{"Nombre":"Juan","Edad":30}
\end{lstlisting}

La deserialización de un objeto JSON a un objeto C\# se realiza utilizando el método Deserialize de la clase JsonSerializer. El método toma dos parámetros: la cadena JSON a deserializar y el tipo de objeto C\# al que se debe deserializar.

Aquí hay un ejemplo que deserializa un objeto JSON en un objeto de tipo Persona:

\begin{lstlisting}
using System;
using System.Text.Json;

class Persona {
public string Nombre { get; set; }
public int Edad { get; set; }
}

class Program {
static void Main(string[] args) {
string json = "{"Nombre":"Juan","Edad":30}";
Persona p = JsonSerializer.Deserialize<Persona>(json);
Console.WriteLine(p.Nombre);
Console.WriteLine(p.Edad);
}
}
\end{lstlisting}

La salida de este ejemplo será la siguiente:

\begin{lstlisting}[language=python]
Juan
30
\end{lstlisting}

\subsection{Eventos}

Los eventos son un mecanismo que permite a un objeto comunicar a otros objetos cuando cierto evento ocurre. Los eventos son muy utilizados en el patrón de diseño "Observer" o "Observable" donde un objeto "observable" notifica a los "observadores" cuando ocurre un cambio. En C\#, los eventos son definidos como miembros de una clase, y están compuestos por un delegado y una lista de métodos suscritos. Los métodos suscritos son llamados cuando el evento es disparado.

La declaración de un evento es similar a la de un delegado, con la adición de la palabra clave event. Por ejemplo:

\begin{lstlisting}
public class EventExample {
public delegate void MyEventHandler(object sender, EventArgs e);
public event MyEventHandler MyEvent;
public void DoSomething() {
    // Algo de codigo aqui
    // ...

    // Disparar el evento
    MyEvent?.Invoke(this, EventArgs.Empty);
}
}
\end{lstlisting}

En el ejemplo anterior, la clase EventExample tiene un evento MyEvent del tipo MyEventHandler. La clase también tiene un método DoSomething() que dispara el evento usando el operador ?.Invoke(). Los métodos suscritos al evento serán llamados cuando el evento sea disparado.

Para suscribir un método a un evento, se usa el operador +=. Por ejemplo:

\begin{lstlisting}
public class EventSubscriber {
public void OnMyEvent(object sender, EventArgs e) {
Console.WriteLine("MyEvent was fired!");
}
}

var obj = new EventExample();
var sub = new EventSubscriber();
obj.MyEvent += sub.OnMyEvent;

// ...

obj.DoSomething(); // Imprime "MyEvent was fired!"
\end{lstlisting}

En el ejemplo anterior, se crea una instancia de EventSubscriber y se suscribe su método OnMyEvent al evento MyEvent de la instancia EventExample. Cuando DoSomething() es llamado, el evento es disparado y el método OnMyEvent() es llamado.

\subsection*{depuración}

Para depurar un programa en Visual Studio, se pueden utilizar diferentes técnicas, una de las más comunes es el uso de puntos de interrupción. Un punto de interrupción es una instrucción que se inserta en el código fuente del programa, que le indica al depurador que detenga la ejecución del programa en ese punto y permita inspeccionar el estado del programa en ese momento.

Otra técnica común es el uso de accesos del teclado en Visual Studio, que permiten activar y desactivar puntos de interrupción, avanzar paso a paso en la ejecución del programa, inspeccionar variables y expresiones, entre otras acciones.

En general, la depuración es un proceso importante en el desarrollo de software, que permite identificar y corregir errores en el código, lo que puede ahorrar tiempo en el largo plazo.

\subsection{Tratamiento de excepciones}

En C\#, las excepciones son errores que ocurren durante la ejecución de un programa y que interrumpen el flujo normal de ejecución. Los errores que ocurren durante la ejecución del programa son llamados excepciones.

Existen diferentes tipos de excepciones predefinidas en C\#, tales como la excepción de división por cero, excepción de índice fuera de rango, excepción de referencia nula, etc. Además, también se pueden crear excepciones personalizadas definidas por el usuario.

Para crear una excepción personalizada, se debe heredar de la clase Exception y crear un constructor que reciba una cadena de texto que describa el error. Por ejemplo:

\begin{lstlisting}
class MyException : Exception
{
    public MyException(string message) : base(message)
    {}
}
\end{lstlisting}

Para lanzar una excepción, se utiliza la palabra clave throw seguida de una instancia de la excepción que se va a lanzar. Por ejemplo:

\begin{lstlisting}
if (x == 0)
{
    throw new MyException("Error: x no puede ser cero");
}
\end{lstlisting}

Para capturar una excepción, se utiliza el bloque try-catch. El bloque try contiene el código que se va a ejecutar y que puede lanzar una excepción. El bloque catch captura la excepción y maneja el error. Por ejemplo:

\begin{lstlisting}
try
{
    int x = 0;
    int y = 10 / x;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Error: division por cero");
}
catch (MyException ex)
{
    Console.WriteLine("Error: " + ex.Message);
}
    catch (Exception ex)
{
    Console.WriteLine("Error general: " + ex.Message);
}
\end{lstlisting}

En este ejemplo, si se intenta dividir por cero, se lanzará una excepción de tipo DivideByZeroException. Si se lanza una excepción de tipo MyException, se mostrará el mensaje de error que se pasó al constructor de la excepción. Si se lanza cualquier otra excepción, se mostrará un mensaje genérico de error.

Es importante capturar las excepciones de manera adecuada para evitar que el programa se bloquee y proporcionar una respuesta adecuada al usuario en caso de que ocurra un error.

\subsection{Trabajar con archivos y Streams}

El manejo de archivos y streams es una parte importante de la programación y en C\# contamos con la librería System.IO para facilitar el acceso a los mismos.

En esta sección hablaremos de algunas herramientas y conceptos importantes para trabajar con archivos y streams en C\#.

\subsubsection*{MemoryStream}
MemoryStream es una clase que nos permite trabajar con datos en memoria. Podemos escribir y leer datos de un objeto MemoryStream como si estuviéramos trabajando con un archivo.

Para trabajar con un objeto MemoryStream primero debemos instanciarlo:

\begin{lstlisting}
MemoryStream ms = new MemoryStream();
\end{lstlisting}

Una vez que tenemos nuestro objeto MemoryStream podemos escribir datos en él utilizando el método Write:

\begin{lstlisting}
ms.Write(buffer, 0, buffer.Length);
\end{lstlisting}

Donde buffer es un arreglo de bytes que contiene los datos que queremos escribir.

Para leer datos de un MemoryStream podemos utilizar el método Read:

\begin{lstlisting}
ms.Read(buffer, 0, buffer.Length);
\end{lstlisting}

Donde buffer es un arreglo de bytes que contendrá los datos leídos del MemoryStream.

También es posible posicionar el cursor en un MemoryStream utilizando el método Seek:

\begin{lstlisting}
ms.Seek(0, SeekOrigin.Begin);
\end{lstlisting}

Este ejemplo posiciona el cursor al inicio del MemoryStream.

\subsubsection*{Archivos}
Para trabajar con archivos podemos utilizar las clases File y FileInfo de la librería System.IO.

La clase File nos permite leer y escribir datos en archivos de forma sencilla:

\begin{lstlisting}
File.WriteAllText("archivo.txt", "contenido del archivo");
string contenido = File.ReadAllText("archivo.txt");
\end{lstlisting}

El primer ejemplo escribe el contenido \enquote*{contenido del archivo} en el archivo \enquote*{archivo.txt}. El segundo ejemplo lee el contenido del archivo \enquote*{archivo.txt} y lo almacena en la variable contenido.

La clase FileInfo nos permite obtener información sobre un archivo específico:

\begin{lstlisting}
FileInfo fileInfo = new FileInfo("archivo.txt");
long size = fileInfo.Length;
DateTime creationTime = fileInfo.CreationTime;
\end{lstlisting}

Este ejemplo obtiene el tamaño y la fecha de creación del archivo "archivo.txt".

\subsubsection*{Streams}
Un stream es una secuencia de bytes que puede ser leída o escrita. En C\# existen varios tipos de streams, como FileStream, MemoryStream y NetworkStream, entre otros.

Para trabajar con streams podemos utilizar las clases Stream y StreamReader/StreamWriter de la librería System.IO.

La clase Stream es la clase base para todos los streams en C\#. Podemos utilizarla para leer y escribir datos en un stream:

\begin{lstlisting}
Stream stream = new MemoryStream();
byte[] buffer = new byte[1024];
int bytesRead = stream.Read(buffer, 0, buffer.Length);
stream.Write(buffer, 0, bytesRead);
\end{lstlisting}

Este ejemplo lee datos de un MemoryStream y los escribe en el mismo stream.

También podemos utilizar las clases StreamReader y StreamWriter para leer y escribir texto en un stream:

\begin{lstlisting}
StreamWriter sw = new StreamWriter("archivo.txt");
sw.Write("contenido del archivo");
sw.Close();

StreamReader sr = new StreamReader("archivo.txt");
string contenido = sr.ReadToEnd();
sr.Close();
\end{lstlisting}

Aquí hay un ejemplo de cómo leer el contenido de un archivo usando la clase StreamReader:
\begin{lstlisting}
try
{
    using (StreamReader sr = new StreamReader("archivo.txt"))
    {
        string linea;
        while ((linea = sr.ReadLine()) != null)
        {
            Console.WriteLine(linea);
        }
    }
}
catch (Exception ex)
{
    Console.WriteLine("Error: " + ex.Message);
}
\end{lstlisting}

En este ejemplo, se usa un bloque try-catch para manejar cualquier excepción que pueda ocurrir mientras se lee el archivo. Primero, se crea una instancia de la clase StreamReader pasando el nombre del archivo como argumento. Luego, se utiliza un bucle while para leer cada línea del archivo y escribirla en la consola. Finalmente, se cierra el StreamReader utilizando la declaración using, lo que asegura que se libere correctamente cualquier recurso utilizado por la clase.

Además de la clase StreamReader, la biblioteca System.IO proporciona una variedad de clases y métodos para trabajar con archivos y streams en C\#. Estos incluyen la clase FileStream para leer y escribir datos en archivos, la clase BinaryReader y BinaryWriter para leer y escribir datos binarios, y la clase Directory para manipular directorios en el sistema de archivos.


Para trabajar con programación asíncrona en C\#, se utiliza la palabra clave \enquote*{async} junto con \enquote*{await}. Esto permite que el código se ejecute en un hilo diferente al hilo principal, lo que puede mejorar el rendimiento de la aplicación. Además, esto permite realizar varias tareas al mismo tiempo y esperar a que todas se completen antes de continuar con la siguiente instrucción.

Por ejemplo, supongamos que tenemos un método \enquote*{DescargarArchivoAsync} que descarga un archivo de Internet. Podríamos usar el siguiente código para llamar a este método de forma asíncrona:

\begin{lstlisting}
public async void DescargarAsync()
{
    await DescargarArchivoAsync();
    Console.WriteLine("Archivo descargado exitosamente");
}
\end{lstlisting}

Aquí, usamos la palabra clave \enquote*{async} en el método \enquote*{DescargarAsync} y \enquote*{await} en la llamada a \enquote*{DescargarArchivoAsync}. Esto indica que estamos esperando a que el método \enquote*{DescargarArchivoAsync} se complete antes de continuar con la siguiente instrucción, que en este caso es imprimir un mensaje en la consola.

Además, podemos iniciar varias tareas simultáneamente y esperar a que todas se completen antes de continuar con la siguiente instrucción. Por ejemplo, si tenemos dos métodos \enquote*{DescargarArchivo1Async} y \enquote*{DescargarArchivo2Async}, podemos usar el siguiente código para iniciar ambas tareas al mismo tiempo y esperar a que ambas se completen antes de continuar con la siguiente instrucción:

\begin{lstlisting}
public async void DescargarArchivosAsync()
{
    Task tarea1 = DescargarArchivo1Async();
    Task tarea2 = DescargarArchivo2Async();
    
    await Task.WhenAll(tarea1, tarea2);
    
    Console.WriteLine("Archivos descargados exitosamente");
}   
\end{lstlisting}

En este caso, usamos la clase \enquote*{Task} para iniciar las tareas \enquote*{DescargarArchivo1Async} y \enquote*{DescargarArchivo2Async} al mismo tiempo. Luego, usamos el método \enquote*{Task.WhenAll} para esperar a que ambas tareas se completen antes de continuar con la siguiente instrucción, que en este caso es imprimir un mensaje en la consola.

La programación asíncrona también permite la composición de tareas. Por ejemplo, si tenemos un método \enquote*{ProcesarArchivoAsync} que procesa un archivo después de descargarlo, podemos usar el siguiente código para llamar a este método de forma asíncrona después de descargar el archivo:

\begin{lstlisting}
public async void DescargarYProcesarAsync()
{
    await DescargarArchivoAsync();
    await ProcesarArchivoAsync();
    Console.WriteLine("Archivo procesado exitosamente");
}
\end{lstlisting}

Aquí, usamos la palabra clave \enquote*{async} y \enquote*{await} para llamar a los métodos \enquote*{DescargarArchivoAsync} y \enquote*{ProcesarArchivoAsync} de forma asíncrona. Esto nos permite descargar el archivo y procesarlo al mismo tiempo sin bloquear el hilo principal.

Finalmente, también podemos esperar a la finalización de una tarea antes de continuar con la siguiente instrucción. Por ejemplo, si tenemos un método \enquote*{EsperarAsync} que espera 5 segundos antes de continuar, podemos usar el siguiente código para esperar a que el método se complete antes de continuar con la siguiente instrucción:

\begin{lstlisting}
public async void EsperarYContinuarAsync()
{
    await EsperarAsync();
    Console.WriteLine("Espera completada");
}    
\end{lstlisting}

En este caso, usamos la palabra clave \enquote*{async} y \enquote*{await} para llamar al método \enquote*{Esperar}. La palabra clave \enquote*{async} le dice al compilador que este método puede contener operaciones asincrónicas, mientras que \enquote*{await} se utiliza para esperar la finalización de una tarea asincrónica antes de continuar con la ejecución del código.

El ejemplo anterior también muestra cómo iniciar tareas simultáneas con la clase Task. Podemos usar el método Task.WhenAll para esperar a que todas las tareas finalicen antes de continuar con la ejecución del código.

La programación asíncrona es especialmente útil cuando trabajamos con operaciones que pueden tardar mucho tiempo en completarse, como operaciones de entrada/salida o de red. En lugar de bloquear el subproceso principal mientras esperamos a que se complete una tarea, podemos permitir que el subproceso principal continúe ejecutando otras tareas.

Además, la programación asíncrona nos permite componer tareas de forma más eficiente. Podemos iniciar varias tareas simultáneamente y esperar a que todas finalicen antes de continuar con la ejecución del código.

\newpage
\subsection{LINQ}

LINQ es una tecnología de Microsoft que permite realizar consultas sobre datos en diversos orígenes de datos, incluyendo bases de datos, colecciones en memoria y servicios web, utilizando una sintaxis unificada y orientada a objetos. LINQ significa \enquote*{Language Integrated Query}, y está integrado en el lenguaje de programación C\# y otros lenguajes de .NET Framework. Con LINQ, se puede escribir consultas de una manera más fácil, eficiente y segura en comparación con otras técnicas de consulta de datos.

\subsubsection*{lambdas}

En LINQ, las lambdas son funciones anónimas que se utilizan para representar una expresión o un bloque de código que se ejecutará en el contexto de una consulta LINQ.

Las lambdas se usan para definir las condiciones de filtrado, las operaciones de proyección y otras operaciones que se aplican a los datos en una consulta LINQ.

Por ejemplo, en la siguiente consulta LINQ, se utiliza una lambda para definir la condición de filtrado:

\begin{lstlisting}
var productos = from p in listaDeProductos
                where p.Precio > 50
                select p;
\end{lstlisting}

En este caso, la lambda se utiliza para definir la condición de filtrado p.Precio > 50. La variable p representa cada objeto en la lista de productos, y la expresión p.Precio > 50 devuelve verdadero o falso para cada objeto según si su precio es mayor a 50 o no.

Las lambdas también se pueden utilizar para definir las operaciones de proyección, que son las que se aplican a los datos para transformarlos en otra forma. Por ejemplo:

\begin{lstlisting}
var nombresDeProductos = listaDeProductos.Select(p => p.Nombre);
\end{lstlisting}

En este caso, la lambda p => p.Nombre se utiliza para definir la operación de proyección que devuelve el nombre de cada producto en la lista. La variable p representa cada objeto en la lista de productos, y la expresión p.Nombre devuelve el nombre del producto.

En resumen, las lambdas son una herramienta fundamental en LINQ, ya que permiten definir de manera concisa y clara las operaciones de filtrado y proyección que se aplican a los datos en una consulta LINQ.

\subsubsection*{Sentencias from, join, let, where, order by, select, group by}

En LINQ, las consultas se construyen utilizando una combinación de cláusulas. Estas cláusulas se pueden utilizar en cierto orden y se encadenan para construir una consulta más compleja. A continuación, veamos algunas de las cláusulas más comunes:

\begin{itemize}
    \item from: especifica la fuente de los datos en la consulta. Por lo general, es una colección o una fuente de datos que implementa la interfaz IQueryable.
    \item join: se utiliza para combinar dos o más fuentes de datos en una única fuente. Es similar a la cláusula SQL \enquote*{JOIN}.
    \item let: permite declarar variables locales dentro de la consulta que se pueden utilizar en cláusulas posteriores.
    \item where: se utiliza para filtrar los datos en función de una condición especificada.order by: se utiliza para ordenar los resultados de la consulta en orden ascendente o descendente en función de una propiedad específica.
    \item select: se utiliza para seleccionar una propiedad o un conjunto de propiedades de los objetos en la fuente de datos.
    \item group by: se utiliza para agrupar los resultados de la consulta en función de una propiedad específica.
\end{itemize}

Cada una de estas cláusulas se puede encadenar para construir una consulta más compleja. Por ejemplo, una consulta LINQ puede tener el siguiente aspecto:
\begin{lstlisting}
var query = from p in db.Personas
            join d in db.Direcciones on p.Id equals d.PersonaId
            where p.Edad > 18
            orderby p.Nombre ascending
            select new {
                Nombre = p.Nombre,
                Direccion = d.Direccion
            };    
\end{lstlisting}

Esta consulta selecciona todas las personas mayores de 18 años de la tabla \enquote*{Personas} y las combina con sus respectivas direcciones de la tabla \enquote*{Direcciones}. Luego, filtra los resultados para incluir solo aquellos cuyo nombre empieza por una letra específica y los ordena alfabéticamente por nombre. Finalmente, selecciona el nombre de la persona y su dirección, y devuelve los resultados como una lista de objetos anónimos.

\subsubsection*{Operadores}

En LINQ, los operadores son métodos que se utilizan para realizar operaciones específicas en los objetos de consulta. Estos operadores se dividen en dos categorías: operadores de consulta y operadores de método.

Los operadores de consulta son palabras clave que se utilizan para definir una consulta LINQ, como from, where, select, orderby, etc. Estos operadores tienen una sintaxis similar a la de una cláusula de SQL.

Por otro lado, los operadores de método son métodos estáticos que se definen en la clase Enumerable y que se utilizan para ejecutar operaciones en los objetos de consulta. Algunos de los operadores de método más comunes son Where, Select, OrderBy, Join, etc.

Ambos tipos de operadores son muy útiles en LINQ para realizar consultas y operaciones complejas de manera fácil y eficiente.

Por ejemplo, el operador Where se utiliza para filtrar los elementos de una secuencia según un predicado determinado. El siguiente código muestra un ejemplo de cómo utilizar este operador para obtener todos los números pares de una secuencia de números:

\begin{lstlisting}
int[] numeros = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

var numerosPares = numeros.Where(n => n % 2 == 0);

foreach (var numero in numerosPares)
{
    Console.WriteLine(numero);
}
\end{lstlisting}

En este caso, la expresión lambda n => n \% 2 == 0 se utiliza como predicado para el operador Where. Esta expresión se evalúa para cada elemento de la secuencia numeros, devolviendo solo aquellos elementos que cumplen la condición de ser divisibles por 2, es decir, los números pares.

\subsubsection*{proveedores}

Los proveedores de LINQ son las bibliotecas que implementan el motor de consulta LINQ para un origen de datos específico. Proporcionan el acceso a los datos, el procesamiento de consultas y la devolución de resultados a través de LINQ. Algunos de los proveedores más comunes son:
\begin{enumerate}
    \item LINQ to Objects: permite realizar consultas en colecciones en memoria.
    \item LINQ to SQL: proporciona acceso a datos en bases de datos relacionales utilizando SQL Server.
    \item LINQ to Entities: proporciona acceso a datos en bases de datos relacionales a través del Entity Framework.
    \item LINQ to XML: proporciona acceso a datos XML.
\end{enumerate}
Cada proveedor tiene su propia implementación de los métodos de extensión de LINQ para admitir el procesamiento de consultas en su origen de datos específico.

\subsubsection*{Ejemplos}

Aquí hay algunos ejemplos de consultas LINQ usando las diferentes cláusulas y operadores mencionados:

\begin{enumerate}
    \item Ejemplo usando la cláusula from y where para filtrar una lista de estudiantes según su edad:
\begin{lstlisting}
List<Student> students = GetStudents(); // Obtener lista de estudiantes

var filteredStudents = from s in students
                        where s.Age > 18
                        select s;    
\end{lstlisting}
    \item Ejemplo usando la cláusula join para unir dos listas de estudiantes y departamentos según su identificador:
\begin{lstlisting}
List<Student> students = GetStudents(); // Obtener lista de estudiantes
List<Department> departments = GetDepartments(); // Obtener lista de departamentos

var joinedData = from s in students
                    join d in departments on s.DepartmentId equals d.Id
                    select new { StudentName = s.Name, DepartmentName = d.Name };

\end{lstlisting}
    \item Ejemplo usando la cláusula let para crear una variable intermedia y utilizarla en una expresión posterior:
\begin{lstlisting}
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

var result = from n in numbers
             let squared = n * n
             where squared > 10
             select squared;

\end{lstlisting}
    \item Ejemplo usando la cláusula order by para ordenar una lista de estudiantes por su nombre de forma ascendente:
\begin{lstlisting}
List<Student> students = GetStudents(); // Obtener lista de estudiantes

var sortedStudents = from s in students
                     orderby s.Name ascending
                     select s;

\end{lstlisting}
    \item Ejemplo usando la cláusula group by para agrupar una lista de estudiantes por su departamento:
\begin{lstlisting}
List<Student> students = GetStudents(); // Obtener lista de estudiantes

var groupedStudents = from s in students
                        group s by s.DepartmentId into g
                        select new { DepartmentId = g.Key, Students = g.ToList() };
\end{lstlisting}
\end{enumerate}

\section{Programación Asíncrona: Potenciando la Eficiencia del Desarrollo de Software}

La programación asíncrona es una técnica esencial en el desarrollo de software moderno que revoluciona la forma en que las aplicaciones manejan tareas que requieren tiempo de espera. A diferencia de la programación síncrona, donde las tareas se ejecutan secuencialmente, la programación asíncrona permite que ciertas operaciones se realicen en segundo plano, sin bloquear la ejecución del programa.

Esta capacidad de realizar tareas en paralelo es especialmente valiosa cuando trabajamos con operaciones que pueden llevar tiempo, como leer/escribir archivos, realizar llamadas a API web, procesar grandes conjuntos de datos, o interactuar con bases de datos.

Para comprender mejor el impacto de la programación asíncrona, consideremos el siguiente ejemplo con tres funciones que simulan tareas que toman 10 segundos cada una. Definimos las funciones \emph{Funcion1}, \emph{Funcion2} y \emph{Funcion3} con un retardo de 10 segundos utilizando \emph{Task.Delay} para simular tareas que toman tiempo.

\begin{lstlisting}
using System.Diagnostics;

// Ejecucion Sincrona
Console.WriteLine("Ejecucion Sincrona:");
var stopwatchSync = Stopwatch.StartNew();
EjecucionSincrona();
stopwatchSync.Stop();
Console.WriteLine($"Tiempo total de ejecucion (Sincrona): {stopwatchSync.ElapsedMilliseconds} ms");

// Ejecucion Asincrona
Console.WriteLine("\nEjecucion Asincrona:");
var stopwatchAsync = Stopwatch.StartNew();
EjecucionAsincrona().Wait();
stopwatchAsync.Stop();
Console.WriteLine($"Tiempo total de ejecucion (Asincrona): {stopwatchAsync.ElapsedMilliseconds} ms");

Console.ReadLine();

// Funcion que simula una tarea que toma 10 segundos
static void Funcion1()
{
    Task.Delay(10000).Wait();
    Console.WriteLine("Funcion 1 completada");
}

// Funcion que simula otra tarea que toma 10 segundos
static void Funcion2()
{
    Task.Delay(10000).Wait();
    Console.WriteLine("Funcion 2 completada");
}

// Funcion que simula una tercera tarea que toma 10 segundos
static void Funcion3()
{
    Task.Delay(10000).Wait();
    Console.WriteLine("Funcion 3 completada");
}

// Ejecucion Sincrona de las tres funciones
static void EjecucionSincrona()
{
    Funcion1();
    Funcion2();
    Funcion3();
}

// Ejecucion Asincrona de las tres funciones
static async Task EjecucionAsincrona()
{
    Task task1 = Task.Run(() => Funcion1());
    Task task2 = Task.Run(() => Funcion2());
    Task task3 = Task.Run(() => Funcion3());

    await Task.WhenAll(task1, task2, task3);
}
\end{lstlisting}

La salida de este codigo será.

\begin{verbatim}
Ejecucion Sincrona:
Funcion 1 completada
Funcion 2 completada
Funcion 3 completada
Tiempo total de ejecucion (Sincrona): 30025 ms

Ejecucion Asincrona:
Funcion 2 completada
Funcion 1 completada
Funcion 3 completada
Tiempo total de ejecucion (Asincrona): 10013 ms
\end{verbatim}

En este ejemplo, mostramos cómo medir el tiempo de ejecución de ambas versiones (síncrona y asíncrona) utilizando el \emph{Stopwatch}. La ejecución síncrona se realiza secuencialmente, mientras que la ejecución asíncrona utiliza \emph{Task.Run} para ejecutar las funciones en hilos separados y \emph{await Task.WhenAll} para esperar que todas las tareas finalicen en paralelo.

Con esto, podemos comparar los tiempos de ejecución y apreciar cómo la ejecución asíncrona mejora significativamente el rendimiento cuando las tareas son independientes y pueden ejecutarse en paralelo.

\subsection{Hilos de Procesamiento}

Los hilos de procesamiento son unidades de ejecución concurrente que permiten a una aplicación realizar múltiples tareas simultáneamente. En C\#, los hilos se gestionan utilizando la clase \emph{Thread} del espacio de nombres \emph{System.Threading}.

Para entender mejor cómo funcionan los hilos de procesamiento, consideremos el siguiente ejemplo, donde utilizaremos la metáfora de camareros que atienden pedidos. Imagina que tenemos dos camareros, cada uno con la tarea de servir cierta cantidad de pedidos. Cada pedido toma un segundo en ser atendido.

Sin hilos de procesamiento haríamso algo así.

\begin{lstlisting}
var stopwatchTotal = System.Diagnostics.Stopwatch.StartNew();

// Atender pedidos con un solo camarero
camarero1Atiende();
camarero2Atiende();

stopwatchTotal.Stop();
Console.WriteLine($"Tiempo total de ejecucion: {stopwatchTotal.ElapsedMilliseconds} ms");
Console.WriteLine("Finalizo la ejecucion sin el uso de hilos de procesamiento");
Console.ReadLine();
    

// Metodos de los camareros
static void camarero1Atiende()
{
    var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
    int cantidadPedidos = 5;
    for (int i = 0; i < cantidadPedidos; i++)
    {
        Thread.Sleep(1000); // Simulamos el tiempo de atencion de un pedido (1 segundo)
        Console.WriteLine("camarero 1 sirvio el pedido: " + i);
    }
    stopwatchSync.Stop();
    Console.WriteLine($"Tiempo total de ejecucion (para el camarero 1): {stopwatchSync.ElapsedMilliseconds} ms");
}

static void camarero2Atiende()
{
    var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
    int cantidadPedidos = 8;
    for (int i = 0; i < cantidadPedidos; i++)
    {
        Thread.Sleep(1000); // Simulamos el tiempo de atencion de un pedido (1 segundo)
        Console.WriteLine("camarero 2 sirvio el pedido: " + i);
    }
    stopwatchSync.Stop();
    Console.WriteLine($"Tiempo total de ejecucion (para el camarero 2): {stopwatchSync.ElapsedMilliseconds} ms");
}
\end{lstlisting}

Con salida.

\begin{verbatim}
camarero 1 sirvio el pedido: 0
camarero 1 sirvio el pedido: 1
camarero 1 sirvio el pedido: 2
camarero 1 sirvio el pedido: 3
camarero 1 sirvio el pedido: 4
Tiempo total de ejecucion (para el camarero 1): 5068 ms
camarero 2 sirvio el pedido: 0
camarero 2 sirvio el pedido: 1
camarero 2 sirvio el pedido: 2
camarero 2 sirvio el pedido: 3
camarero 2 sirvio el pedido: 4
camarero 2 sirvio el pedido: 5
camarero 2 sirvio el pedido: 6
camarero 2 sirvio el pedido: 7
Tiempo total de ejecucion (para el camarero 2): 8084 ms
Tiempo total de ejecucion: 13162 ms
Finalizo la ejecucion sin el uso de hilos de ejecucion
\end{verbatim}

Podemos notar que no es el comportamiento que buscamos, pues queremos que cada camarero atienda de manera independente.

Si usamos dos hilos de procesamiento, tenemos.

\begin{lstlisting}
var stopwatchTotal = System.Diagnostics.Stopwatch.StartNew();

// Crear los hilos para los camareros
Thread camarero1 = new Thread(new ThreadStart(camarero1Atiende));
Thread camarero2 = new Thread(new ThreadStart(camarero2Atiende));

// Iniciar los hilos
camarero1.Start();
camarero2.Start();

// El hilo principal continua ejecutandose
Console.WriteLine("Inicio la ejecucion con el hilo principal, que es la clase Program");

// Esperar a que los hilos finalicen
camarero1.Join();
camarero2.Join();

stopwatchTotal.Stop();
Console.WriteLine($"Tiempo total de ejecucion: {stopwatchTotal.ElapsedMilliseconds} ms");
Console.WriteLine("Finalizo la ejecucion de todos los hilos");
Console.ReadLine();


// Metodos de los camareros
static void camarero1Atiende()
{
    var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
    int cantidadPedidos = 5;
    for (int i = 0; i < cantidadPedidos; i++)
    {
        Thread.Sleep(1000); // Simulamos el tiempo de atencion de un pedido (1 segundo)
        Console.WriteLine("camarero 1 sirvio el pedido: " + i);
    }
    stopwatchSync.Stop();
    Console.WriteLine($"Tiempo total de ejecucion (para el camarero 1): {stopwatchSync.ElapsedMilliseconds} ms");
}

static void camarero2Atiende()
{
    var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
    int cantidadPedidos = 8;
    for (int i = 0; i < cantidadPedidos; i++)
    {
        Thread.Sleep(1000); // Simulamos el tiempo de atencion de un pedido (1 segundo)
        Console.WriteLine("camarero 2 sirvio el pedido: " + i);
    }
    stopwatchSync.Stop();
    Console.WriteLine($"Tiempo total de ejecucion (para el camarero 2): {stopwatchSync.ElapsedMilliseconds} ms");
}    
\end{lstlisting}

Con salida.

\begin{verbatim}
Inicio la ejecucion con el hilo principal, que es la clase Program
camarero 1 sirvio el pedido: 0
camarero 2 sirvio el pedido: 0
camarero 1 sirvio el pedido: 1
camarero 2 sirvio el pedido: 1
camarero 1 sirvio el pedido: 2
camarero 2 sirvio el pedido: 2
camarero 1 sirvio el pedido: 3
camarero 2 sirvio el pedido: 3
camarero 1 sirvio el pedido: 4
camarero 2 sirvio el pedido: 4
Tiempo total de ejecucion (para el camarero 1): 5046 ms
camarero 2 sirvio el pedido: 5
camarero 2 sirvio el pedido: 6
camarero 2 sirvio el pedido: 7
Tiempo total de ejecucion (para el camarero 2): 8066 ms
Tiempo total de ejecucion: 8089 ms
Finalizo la ejecucion de todos los hilos
\end{verbatim}

En este ejemplo, los camareros representan los hilos de procesamiento. Cada camarero atiende un conjunto de pedidos (tareas) de forma independiente, y cada pedido toma un segundo en ser procesado. El hilo principal, que es el inicio de la aplicación (\emph{Main}), crea y arranca los hilos de los camareros utilizando \emph{Thread.Start()}. Luego, el hilo principal espera a que los hilos de los camareros finalicen mediante \emph{Thread.Join()}, lo que asegura que el hilo principal no finalice hasta que todos los hilos hayan completado su trabajo, si quitamos esta sentencia (\emph{Thread.Join()}), el hilo principal finalizaría aunque los dos camareros seguirían trabajando.

La ventaja de utilizar hilos de procesamiento es que permite que nuestra aplicación realice tareas en paralelo, lo que puede mejorar significativamente la eficiencia y el rendimiento, especialmente en situaciones donde hay operaciones que requieren mucho tiempo de procesamiento o cuando deseamos mantener una interfaz de usuario receptiva mientras se ejecutan tareas en segundo plano.

\subsection{Parallel.ForEach}

En C\#, la clase \emph{Parallel} proporciona una forma conveniente de realizar operaciones en paralelo utilizando el método \emph{ForEach}. Este método permite procesar elementos de una colección en paralelo, lo que puede mejorar el rendimiento en sistemas con múltiples núcleos de CPU.

El método \emph{Parallel.ForEach} se utiliza para realizar un bucle en paralelo en una colección de elementos. La sintaxis general es la siguiente:

\begin{lstlisting}
Parallel.ForEach(coleccion, (elemento) =>
{
    // Codigo para procesar cada elemento en paralelo
});
\end{lstlisting}

Donde:
\begin{itemize}
    \item \emph{coleccion}: Es la colección de elementos que se recorrerá en paralelo.
    \item \emph{elemento}: Es una variable que representa cada elemento de la colección en cada iteración del bucle.
\end{itemize}

A continuación, veamos un ejemplo utilizando \emph{Parallel.ForEach} para calcular el cuadrado de cada número en una lista de enteros:

\begin{lstlisting}
List<int> numeros = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
Parallel.ForEach(numeros, (numero) =>
{
    Thread.Sleep(1000);
    int cuadrado = numero * numero;
    Console.WriteLine($"El cuadrado de {numero} es: {cuadrado}");
});
Console.WriteLine("Procesamiento completado.");
Console.WriteLine($"Tiempo total de ejecucion: {stopwatchSync.ElapsedMilliseconds} ms");
Console.ReadLine();
\end{lstlisting}

Con salida.

\begin{verbatim}
El cuadrado de 4 es: 16
El cuadrado de 8 es: 64
El cuadrado de 7 es: 49
El cuadrado de 3 es: 9
El cuadrado de 9 es: 81
El cuadrado de 6 es: 36
El cuadrado de 2 es: 4
El cuadrado de 1 es: 1
El cuadrado de 5 es: 25
El cuadrado de 10 es: 100
Procesamiento completado.
Tiempo total de ejecucion: 1744 ms
\end{verbatim}

En este ejemplo, cada número en la lista se procesa en paralelo, calculando su cuadrado y mostrándolo en la consola.

Es importante tener en cuenta que no todas las operaciones son adecuadas para la ejecución en paralelo, y siempre es necesario realizar pruebas y evaluar el rendimiento en diferentes escenarios antes de utilizar \emph{Parallel.ForEach} en código de producción.

La opción, sin usar \emph{Parallel.ForEach} es.

\begin{lstlisting}
List<int> numeros = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
var stopwatchSync = System.Diagnostics.Stopwatch.StartNew();
foreach(int numero in numeros)
{
    Thread.Sleep(1000);
    int cuadrado = numero * numero;
    Console.WriteLine($"El cuadrado de {numero} es: {cuadrado}");
};
Console.WriteLine("Procesamiento completado.");
Console.WriteLine($"Tiempo total de ejecucion: {stopwatchSync.ElapsedMilliseconds} ms");
Console.ReadLine();
\end{lstlisting}

con salida.

\begin{verbatim}
El cuadrado de 1 es: 1
El cuadrado de 2 es: 4
El cuadrado de 3 es: 9
El cuadrado de 4 es: 16
El cuadrado de 5 es: 25
El cuadrado de 6 es: 36
El cuadrado de 7 es: 49
El cuadrado de 8 es: 64
El cuadrado de 9 es: 81
El cuadrado de 10 es: 100
Procesamiento completado.
Tiempo total de ejecucion: 10137 ms
\end{verbatim}

Notemos que hay una gran diferencia en los tiempos de ejecución.

Además de \emph{Parallel.ForEach} y \emph{Parallel.For}, la clase \emph{Parallel} en C\# proporciona otros métodos útiles para trabajar con tareas en paralelo. A continuación, veamos brevemente algunos de estos métodos:

\begin{itemize}
    \item \emph{Parallel.Invoke}: Permite invocar múltiples acciones en paralelo. Las acciones se ejecutan simultáneamente y el método espera hasta que todas las acciones hayan finalizado.
    
\begin{lstlisting}
Parallel.Invoke(
    () => Metodo1(),
    () => Metodo2(),
    () => Metodo3()
);
\end{lstlisting}

    \item \emph{Parallel.ForAll}: Similar a \emph{Parallel.ForEach}, pero este método trabaja con arreglos. Permite realizar un bucle en paralelo sobre un arreglo y aplicar una operación a cada elemento.
    
\begin{lstlisting}
int[] numeros = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

Parallel.ForAll(numeros, (numero) =>
{
    int cuadrado = numero * numero;
    Console.WriteLine($"El cuadrado de {numero} es: {cuadrado}");
});
\end{lstlisting}

    \item \emph{Parallel.ForEach<TSource, TLocal>}: Este método extiende \emph{Parallel.ForEach} y proporciona la capacidad de tener un estado local para cada hilo en el que se ejecuta. Puede ser útil cuando necesitas realizar cálculos parciales y luego combinar los resultados.
    
\begin{lstlisting}
List<int> numeros = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

Parallel.ForEach(numeros,
    () => new List<int>(),
    (numero, estado, listaLocal) =>
    {
        listaLocal.Add(numero * 2);
        return listaLocal;
    },
    (listaLocal) =>
    {
        Console.WriteLine($"Resultado combinado: {string.Join(", ", listaLocal)}");
    }
);
\end{lstlisting}

    \item \emph{Parallel.For}: Permite realizar un bucle \emph{for} en paralelo. Divide automáticamente el rango de iteración en partes y procesa cada iteración en hilos separados.
    
\begin{lstlisting}
Parallel.For(1, 11, (i) =>
{
    Console.WriteLine(i);
});
\end{lstlisting}

    \item \emph{Parallel.LoopResult}: Se utiliza con el método \emph{Parallel.For} para obtener información sobre el estado de ejecución del bucle en paralelo. Permite verificar si el bucle se ha completado correctamente o si se ha cancelado.
    
\begin{lstlisting}
ParallelLoopResult result = Parallel.For(1, 11, (i, estado) =>
{
    if (i == 5)
    {
        estado.Stop();
    }
});
if (!result.IsCompleted)
{
    Console.WriteLine("El bucle fue detenido antes de completarse.");
}
\end{lstlisting}

    \item \emph{ParallelOptions}: Esta clase se utiliza para establecer opciones y configuraciones adicionales al trabajar con métodos paralelos, como el número máximo de hilos utilizados, el token de cancelación, etc.

\begin{lstlisting}
ParallelOptions options = new ParallelOptions();
options.MaxDegreeOfParallelism = 4; // Limitar el numero maximo de hilos a 4

Parallel.ForEach(numeros, options, (numero) =>
{
    // Operaciones en paralelo con restriccion de hilos
});
\end{lstlisting}

\end{itemize}

\subsection{Callbacks}

Los callbacks son una técnica fundamental en la programación asíncrona. Consisten en pasar una función como argumento a otra función, y esta última la invocará una vez que haya finalizado una operación asíncrona. Los callbacks permiten personalizar qué acción o función se ejecutará después de que se complete la tarea asíncrona, lo que brinda flexibilidad y control en el flujo de ejecución del programa.

Supongamos que tenemos una clase llamada \emph{DataService}, que se encarga de descargar datos de un servidor remoto de manera asíncrona. A continuación, presentamos un ejemplo utilizando callbacks en C\#:

\begin{lstlisting}
DataService dataService = new DataService();

// Llamada a la funcion de descarga con un callback
string url = "https://example.com/data";
dataService.DownloadDataAsync(url, ProcessDownloadedData);

// Continuamos con otras tareas mientras esperamos la descarga
Console.WriteLine("Esperando la descarga...");
Console.ReadLine();    

public class DataService
{
    // Funcion de descarga asincrona con un callback
    public async Task DownloadDataAsync(string url, Action<string> callback)
    {
        // Simulamos una operacion de descarga que lleva tiempo
        await Task.Delay(3000); // Simulamos una descarga de 3 segundos

        // Datos descargados
        string data = "Datos descargados desde " + url;

        // Llamamos al callback y le pasamos los datos descargados
        callback(data);
    }
}

    // Funcion de callback para procesar los datos descargados
    public static void ProcessDownloadedData(string data)
    {
        Console.WriteLine("Datos recibidos:");
        Console.WriteLine(data);
    }
}
\end{lstlisting}

En este ejemplo, creamos una clase llamada \emph{DataService}, que contiene una función llamada \emph{DownloadDataAsync} para simular la descarga de datos desde una URL de manera asíncrona utilizando \emph{async} y \emph{await}. Esta función acepta dos parámetros: la URL de descarga y un callback representado por la firma \emph{Action<string>}.

Dentro de la función \emph{DownloadDataAsync}, utilizamos \emph{Task.Delay} para simular una operación asíncrona de descarga que lleva tiempo. Una vez que se completa la descarga, llamamos al callback y le pasamos los datos descargados.

En la función \emph{Main}, creamos una instancia de \emph{DataService} y llamamos a \emph{DownloadDataAsync} para iniciar la descarga de datos. Especificamos el callback \emph{ProcessDownloadedData} para procesar los datos una vez que estén disponibles.

Mientras esperamos la descarga, utilizamos \emph{Console.WriteLine} para mostrar un mensaje indicando que estamos esperando la descarga y leemos una línea desde la consola para que el programa no finalice inmediatamente.

Cuando la descarga finaliza, se ejecuta el callback \emph{ProcessDownloadedData}, que muestra los datos recibidos por pantalla.

\subsection{Promesas (Promises)}

Las promesas son un mecanismo más estructurado para manejar operaciones asíncronas. Representan un valor que puede estar disponible ahora, en el futuro o nunca. Las promesas permiten trabajar con operaciones asíncronas de manera más clara y manejar tanto el éxito como el fracaso de la operación de una forma más estructurada y legible.

En el contexto de C\#, podemos hacer uso de bibliotecas que implementan el concepto de promesas, como \emph{Task} y \emph{Task<T>} que se encuentran en el espacio de nombres \emph{System.Threading.Tasks}. Estas clases nos permiten crear y trabajar con promesas de manera sencilla.

A continuación, presentamos un ejemplo general utilizando \emph{Task} en C\# para ilustrar cómo funcionan las promesas:

\begin{lstlisting}
Task<string> promise = DownloadDataAsync("https://example.com/data");
// Continuamos con otras tareas mientras esperamos la descarga
Console.WriteLine("Esperando la descarga...");

// Cuando la promesa se resuelve, se ejecuta el codigo del then
promise.ContinueWith(result =>
{
    if (result.Status == TaskStatus.RanToCompletion)
    {
        string data = result.Result;
        ProcessDownloadedData(data);
    }
    else if (result.Status == TaskStatus.Faulted)
    {
        Console.WriteLine("Error al descargar los datos: " + result.Exception.InnerException.Message);
    }
});

// Continuamos con otras tareas mientras se completa la promesa
Console.ReadLine();

// Funcion de descarga asincrona utilizando Task<string>
public static async Task<string> DownloadDataAsync(string url)
{
    // Simulamos una operacion de descarga que lleva tiempo
    await Task.Delay(3000); // Simulamos una descarga de 3 segundos

    // Datos descargados
    string data = "Datos descargados desde " + url;

    return data;
}

// Funcion para procesar los datos descargados
public static void ProcessDownloadedData(string data)
{
    Console.WriteLine("Datos recibidos:");
    Console.WriteLine(data);
}
\end{lstlisting}

En este ejemplo, utilizamos la función \emph{DownloadDataAsync} para simular una operación de descarga de datos desde una URL utilizando \emph{Task<string>}. Esta función devuelve una promesa que representa la descarga de los datos.

Luego, continuamos con otras tareas mientras esperamos la descarga y mostramos un mensaje en la consola para indicar que estamos esperando.

Cuando la promesa se resuelve, se ejecuta el código dentro del bloque \emph{ContinueWith}. En este bloque, verificamos si la promesa se completó correctamente (\emph{TaskStatus.RanToCompletion}), en cuyo caso obtenemos los datos descargados y los procesamos llamando a \emph{ProcessDownloadedData}. Si la promesa se completó con un error (\emph{TaskStatus.Faulted}), mostramos un mensaje de error en la consola.

El uso de promesas nos permite manejar de manera más estructurada y legible el flujo de ejecución y los resultados de las operaciones asíncronas.    

\subsection{Async/Await}

La combinación de las palabras clave \emph{async} y \emph{await} en C\# (y en otros lenguajes) proporciona una sintaxis más legible y estructurada para trabajar con operaciones asíncronas. Con \emph{async}, se marca una función como asíncrona, y con \emph{await}, se puede esperar la resolución de una promesa antes de continuar con el código.

A continuación, presentamos un ejemplo de cómo utilizar \emph{async} y \emph{await} en C\#:

\begin{lstlisting}
using System.Net.Http;

string url = "https://api.example.com/data";
// Llamada a una funcion asincrona con await
try
{
    string data = await DownloadDataAsync(url);
    Console.WriteLine("Datos descargados: " + data);
}
catch (Exception ex)
{
    Console.WriteLine("Error al descargar los datos: " + ex.Message);
}

// Continuamos con otras tareas mientras se realiza la descarga
Console.WriteLine("Continuando con otras tareas...");
Console.ReadLine();

// Funcion de descarga asincrona utilizando HttpClient
public static async Task<string> DownloadDataAsync(string url)
{
    using (HttpClient httpClient = new HttpClient())
    {
        // Realizamos una peticion GET a la URL proporcionada
        HttpResponseMessage response = await httpClient.GetAsync(url);

        // Verificamos si la respuesta es exitosa
        response.EnsureSuccessStatusCode();

        // Leemos los datos de la respuesta y los devolvemos
        return await response.Content.ReadAsStringAsync();
    }
}

\end{lstlisting}

En este ejemplo, utilizamos \emph{async} y \emph{await} para trabajar con una función asíncrona llamada \emph{DownloadDataAsync}. Dentro de esta función, utilizamos la clase \emph{HttpClient} para realizar una petición GET a una URL y obtener los datos.

En la función \emph{Main}, llamamos a \emph{DownloadDataAsync} utilizando \emph{await} para esperar la resolución de la promesa. Cuando la descarga se completa exitosamente, obtenemos los datos descargados y los mostramos en la consola. Si ocurre un error durante la descarga, capturamos la excepción en el bloque \emph{catch} y mostramos un mensaje de error.

El uso de \emph{async} y \emph{await} nos permite escribir código asíncrono de manera más similar a un código síncrono, lo que facilita la lectura y comprensión del flujo de ejecución del programa.

\section{Arquitectura Hexagonal}

La arquitectura hexagonal, también conocida como arquitectura de puertos y adaptadores, es un patrón de arquitectura de software que se enfoca en separar la lógica de negocio de la implementación técnica.

En la arquitectura hexagonal, el sistema se divide en tres capas principales: la capa de dominio, la capa de aplicación y la capa de infraestructura. La capa de dominio es donde se encuentra la lógica de negocio de la aplicación, mientras que la capa de aplicación es responsable de orquestar las diferentes partes de la aplicación para que funcionen juntas. La capa de infraestructura es donde se encuentran los detalles técnicos de la aplicación, como la base de datos, el sistema de archivos y las interfaces de usuario.

El objetivo principal de la arquitectura hexagonal es crear una aplicación que sea fácil de mantener y evolucionar con el tiempo. Al separar la lógica de negocio de la implementación técnica, se reduce la dependencia de la aplicación a tecnologías específicas y se facilita la integración con otros sistemas. Además, al tener una capa de dominio claramente definida, se facilita la creación de pruebas automatizadas y la verificación de que la aplicación funciona correctamente.

\subsection{Participantes en una arquitectura hexagonal}

\begin{enumerate}
    \item Capa de Dominio:
   \begin{itemize}
        \item Modelos: Representan los objetos del dominio, encapsulando tanto los datos como la lógica de negocio relacionada.
        \item Interfaces de repositorio: Definen los contratos para la persistencia y recuperación de las entidades.
        \item Interfaces de servicios: Definen los contratos para los servicios.
        \item Servicios de dominio: Implementan la lógica de negocio más compleja que no se puede asignar directamente a un modelo específico.
    \end{itemize}
    \item Capa de Aplicación:
   \begin{itemize}
        \item Puertos de entrada (Entidades de servicios de entrada): Son los puntos de entrada a la aplicación desde la infraestructura. Los puertos de entrada son interfaces que definen cómo se pueden recibir y procesar las solicitudes externas.
        \item Puertos de salida (Entidades de servicios de entrada): Son los puntos de salida de la aplicación hacia la infraestructura. Los puertos de salida son interfaces que definen cómo se pueden enviar respuestas o datos a sistemas externos.
        \item Adaptadores de entrada (Servicios de entrada): Son implementaciones concretas de los puertos de entrada. Los adaptadores de entrada se encargan de recibir las solicitudes externas y mapearlas a los comandos o consultas internas de la aplicación. Estos adaptadores también se encargan de la validación de entrada y la traducción de datos hacia el formato interno de la aplicación.
        \item Adaptadores de salida (Servicios de salida): Son implementaciones concretas de los puertos de salida. Los adaptadores de salida se encargan de tomar los resultados o datos generados por la aplicación y enviarlos a sistemas externos.
    \end{itemize}
    \item Capa de Infraestructura:
   \begin{itemize}
        \item Entidades: Representan Las entidades de las bases de datos
        \item Implementaciones de Repositorio: Proporcionan la implementación concreta de los contratos de las interfaces de repositorio, realizando operaciones de persistencia y recuperación de datos.
        \item Adaptadores: Se encargan de adaptar los componentes de la aplicación a las interfaces de la infraestructura externa, como bases de datos, sistemas de archivos, servicios web, etc.
        \item Controladores: De ser necesario, en esta capa estarán los controladores si la aplicación es una api.
    \end{itemize}
    \item Patrones y principios adicionales:
   \begin{itemize}
        \item DTOs (Data Transfer Objects): Utilizados para transferir datos entre los componentes de la aplicación.
        \item Modelos: Representan estructuras de datos utilizadas internamente en la aplicación, a menudo mapeadas desde las entidades o DTOs.
        \item Inversión de Dependencias (Dependency Inversion Principle): Se enfoca en invertir las dependencias para permitir una arquitectura más flexible y modular.
        \item Principio de Separación de Preocupaciones (Separation of Concerns): Se busca separar las diferentes responsabilidades y preocupaciones en componentes distintos.
    \end{itemize}
\end{enumerate}

En una arquitectura hexagonal bien diseñada, los DTOs se utilizan para transferir datos entre los diferentes componentes de la aplicación, las entidades se utilizan internamente para representar estructuras de datos y los modelos se utilizan para modelar los objetos y la lógica de negocio del dominio. Los servicios en la capa de aplicación coordinan las interacciones entre las diferentes capas, mientras que los adaptadores de infraestructura se encargan de adaptar la aplicación a las interfaces de la infraestructura externa, sean bases de datos, apis, ets.

Estos componentes y principios trabajan en conjunto para lograr una arquitectura flexible, mantenible y escalable, donde la lógica de negocio se mantiene independiente de las tecnologías y detalles de implementación, y donde los diferentes componentes son intercambiables y se pueden probar de forma aislada.

\subsection{Flujo en una arquitectura hexagonal}

En la arquitectura hexagonal, el flujo de datos sigue un patrón conocido como "arquitectura de puertos y adaptadores". A continuación, se describe el flujo de datos típico en esta arquitectura:

\begin{enumerate}
    \item Entrada de datos: Los datos ingresan a la aplicación a través de los puertos de entrada. Estos puertos pueden ser interfaces de usuario, servicios web, mensajes, archivos, entre otros. Los datos de entrada son recibidos por adaptadores específicos que se encargan de transformarlos en un formato adecuado para ser procesados por la aplicación.
    \item Capa de aplicación: Los datos procesados en los adaptadores son enviados a la capa de aplicación. Aquí se encuentra la lógica de negocio de la aplicación. Los adaptadores hacen uso de los servicios y objetos definidos en esta capa para realizar las operaciones necesarias.
    \item Capa de dominio: La capa de dominio es el núcleo de la aplicación y contiene la lógica de negocio principal. Aquí se encuentran os modelos y los servicios relacionados con el dominio específico de la aplicación. Los objetos en esta capa pueden realizar operaciones en los datos recibidos y aplicar reglas de negocio.
    \item Capa de infraestructura: Una vez que la capa de dominio realiza las operaciones necesarias, los resultados son enviados de vuelta a los adaptadores a través de los puertos de salida. Los adaptadores se encargan de transformar los datos en un formato adecuado para su posterior envío o almacenamiento. Estos puertos de salida pueden ser interfaces de usuario, servicios web, bases de datos, sistemas de archivos, entre otros.
\end{enumerate}

El flujo de datos en la arquitectura hexagonal sigue un patrón en el cual los datos ingresan a través de los puertos de entrada, son procesados por la capa de aplicación y la capa de dominio, y finalmente se envían de vuelta a través de los puertos de salida. Esta arquitectura promueve la separación de la lógica de negocio de los detalles de implementación técnica, lo que facilita la modularidad, la prueba y la evolución de la aplicación.

Un puerto de entrada y un puerto de salida en la arquitectura hexagonal son interfaces que definen cómo se comunican los componentes externos con la aplicación y cómo la aplicación se comunica con los componentes externos, respectivamente. A nivel de diseño, un puerto de entrada y un puerto de salida se representan generalmente como interfaces en el lenguaje de programación utilizado.

Por ejemplo 

Port de entrada
\begin{lstlisting}
public interface IUserInputPort
{
    void CreateUser(string name, string email, string password);
}
\end{lstlisting}

Port de salida
\begin{lstlisting}
public interface IUserOutputPort
{
    void UserCreated(User user);
}
\end{lstlisting}

En este ejemplo, IUserInputPort representa un puerto de entrada y IUserOutputPort representa un puerto de salida.

El puerto de entrada (IUserInputPort) define un método CreateUser que toma como parámetros el nombre, el correo electrónico y la contraseña de un usuario. Este puerto es utilizado por los adaptadores de entrada, como un controlador de interfaz de usuario o un servicio web, para enviar datos a la aplicación.

El puerto de salida (IUserOutputPort) define un método UserCreated que recibe un objeto de tipo User como parámetro. Este puerto es utilizado por los adaptadores de salida, como un adaptador de base de datos o un servicio web, para recibir datos de la aplicación y realizar las acciones necesarias, como guardar los datos en una base de datos o enviar una respuesta al cliente.

Los adaptadores son componentes responsables de la comunicación entre los puertos de entrada/salida y la lógica de la aplicación. Los adaptadores actúan como intermediarios para transformar los datos recibidos desde los puertos de entrada en un formato adecuado para su procesamiento en la aplicación y viceversa, convirtiendo los datos de salida de la aplicación en un formato adecuado para ser enviado a través de los puertos de salida.

Existen dos tipos de adaptadores comunes en la arquitectura hexagonal: adaptadores de entrada y adaptadores de salida.

\begin{enumerate}
    \item Adaptadores de entrada:
    Los adaptadores de entrada son responsables de recibir los datos provenientes de los puertos de entrada y convertirlos en una forma que la aplicación pueda entender. Algunos ejemplos de adaptadores de entrada pueden incluir:
   \begin{itemize}
        \item Controladores de interfaz de usuario: Estos adaptadores reciben las solicitudes del usuario a través de la interfaz de usuario, extraen los datos necesarios y los pasan a la capa de aplicación para su procesamiento.
        \item Adaptadores de servicios web: Estos adaptadores reciben las solicitudes HTTP de los clientes, interpretan los datos de la solicitud y los convierten en una forma que la aplicación pueda manejar.
    \end{itemize}
    \item Adaptadores de salida:
    Los adaptadores de salida son responsables de recibir los resultados de la aplicación y convertirlos en un formato adecuado para enviarlos a través de los puertos de salida. Algunos ejemplos de adaptadores de salida pueden incluir:
   \begin{itemize}
        \item Adaptadores de bases de datos: Estos adaptadores se encargan de interactuar con una base de datos específica y realizar operaciones de lectura o escritura de datos.
        \item Adaptadores de servicios web: Estos adaptadores toman los resultados de la aplicación y los envían a través de servicios web para ser consumidos por otros sistemas.
        \item Adaptadores de mensajes: Estos adaptadores se utilizan para enviar mensajes a través de sistemas de mensajería o colas, permitiendo la integración con otros componentes o sistemas.
    \end{itemize}
\end{enumerate}
Cada adaptador implementa los métodos definidos en los puertos de entrada/salida correspondientes, transformando los datos de acuerdo con las necesidades de la aplicación y los sistemas externos con los que interactúa. Los adaptadores juegan un papel fundamental en la arquitectura hexagonal, ya que permiten la separación de la lógica de la aplicación de los detalles de comunicación y tecnología específicos.

Por ejemplo

Adaptador de entrada
\begin{lstlisting}
public class UserInputAdapter : IUserInputPort
{
    private readonly IUserOutputPort _outputPort;

    public UserInputAdapter(IUserOutputPort outputPort)
    {
        _outputPort = outputPort;
    }

    public void CreateUser(string name, string email, string password)
    {
        // Logic para adaptar los datos recibidos a la forma requerida por la app
        User user = new User(name, email, password);

        // Llamada al puerto de salida para indicar que se ha creado el usuario
        _outputPort.UserCreated(user);
    }
}
\end{lstlisting}

Adaptador de salida
\begin{lstlisting}
public class UserOutputAdapter : IUserOutputPort
{
        public void UserCreated(User user)
        {
            // Logic para adaptar los datos de salida y enviarlos a traves del puerto de salida
            Console.WriteLine("El usuario" + user.Name + "  ha sido creado exitosamente.");
        }
    }
    
\end{lstlisting}

En el ejemplo anterior, UserInputAdapter es un adaptador de entrada que implementa el puerto de entrada IUserInputPort. Recibe una instancia del adaptador de salida IUserOutputPort a través de su constructor, que se utiliza para llamar al método UserCreated del puerto de salida.

UserInputAdapter implementa el método CreateUser, que recibe los datos de entrada (nombre, correo electrónico, contraseña) y los adapta en un objeto User para su procesamiento en la aplicación. Luego, utiliza el puerto de salida para indicar que se ha creado un nuevo usuario, pasando el objeto User como parámetro.

UserOutputAdapter es un adaptador de salida que implementa el puerto de salida IUserOutputPort. En este ejemplo, simplemente muestra un mensaje en la consola indicando que el usuario ha sido creado exitosamente. En una implementación real, este adaptador podría realizar acciones adicionales, como guardar los datos en una base de datos o enviar una respuesta a través de un servicio web.

Estos adaptadores son ejemplos básicos, pero ilustran cómo se implementan y cómo se adaptan los datos entre los puertos de entrada y salida en la arquitectura hexagonal.

\subsection{DTO (Data Transfer Object)}

Un DTO (Data Transfer Object) es un patrón de diseño utilizado para transferir datos entre diferentes componentes de una aplicación. Los DTOs son objetos simples que contienen campos de datos y no contienen lógica de negocio adicional. Su propósito principal es facilitar la transferencia eficiente de datos entre capas de una aplicación o entre diferentes sistemas.

Aquí hay algunos puntos clave sobre los DTOs:

\begin{enumerate}
    \item Transferencia de datos: Los DTOs se utilizan para transferir datos entre componentes de la aplicación, como capas de la arquitectura o sistemas externos. Sirven como estructuras de datos que encapsulan los datos necesarios para una operación específica.
    \item Estructura de datos simples: Los DTOs generalmente son clases simples que contienen propiedades o campos para almacenar los datos relevantes. No contienen métodos con lógica de negocio compleja, ya que su propósito es simplemente contener y transportar datos.
    \item Independientes de la interfaz de usuarioación: Los DTOs son independientes de la capa de presentación y no deben contener referencias a frameworks o tecnologías específicas. De esta manera, se pueden utilizar en diferentes capas o en diferentes interfaces de usuario sin problemas de dependencia.
    \item Adaptación de datos: Los DTOs se adaptan para ajustarse a los requisitos de cada componente. Por ejemplo, en una capa de servicio web, los DTOs pueden ser serializados en formato JSON o XML para ser enviados a través de una solicitud HTTP. En una capa de acceso a datos, los DTOs pueden ser mapeados a las entidades del modelo de datos.
    \item Eficiencia en la transferencia de datos: Los DTOs permiten reducir el tráfico de datos y mejorar el rendimiento de la aplicación. Al enviar solo los datos necesarios en lugar de objetos completos con lógica de negocio, se reduce el tamaño de los mensajes y se mejora la eficiencia en la transferencia de datos.
    \item Separación de preocupaciones: Los DTOs ayudan a mantener una separación clara entre la capa de presentación y la capa de dominio. Al utilizar objetos DTO para transferir datos, se evita la exposición directa de las entidades de dominio a la capa de presentación, lo que facilita el mantenimiento y la evolución de la aplicación.
\end{enumerate}

Los DTOs son objetos simples utilizados para transferir datos entre componentes de una aplicación. Proporcionan una estructura de datos eficiente y desacoplada que facilita la comunicación entre diferentes capas o sistemas externos, mejorando la modularidad y el rendimiento de la aplicación.

\subsection{Entidades}

En el contexto de la arquitectura de software, las entidades suelen representar tablas de la base de datos, tales como clientes, usuarios, transacciones, etc. Las entidades encapsulan datos y son fundamentales para modelar y manipular la información dentro de la aplicación.

Aquí tienes algunas características y puntos clave sobre las entidades:
\begin{enumerate}
    \item Representación de conceptos del dominio: Las entidades representan objetos del mundo real o abstracto que son relevantes para el dominio de la aplicación. Por ejemplo, en una aplicación de gestión de usuarios, podría haber una entidad \enquote*{Usuario} que contiene los atributos como nombre, dirección de correo electrónico, contraseña, etc.
    \item Encapsulación de datos: Las entidades encapsulan los datos relacionados a un concepto específico. Estos datos se almacenan en propiedades o atributos de la entidad y pueden ser de diferentes tipos, como cadenas de texto, números, fechas, listas u otros objetos relacionados.
    \item No contienen lógica de negocio: Las entidades no contienen lógica de negocio relacionada a su comportamiento y reglas de validación. Por ejemplo, la entidad \emph*{Usuario}, puede estar relacionada a un modelo y este a su vez podría tener métodos para verificar la validez de una contraseña o para calcular información basada en sus atributos, pero estas verificaciones se hacen en la capa de dominio.
    \item Identidad única: Cada entidad generalmente tiene una identidad única que la distingue de otras entidades del mismo tipo. Esta identidad puede ser representada por un identificador único, como un número o una cadena de caracteres.
    \item Persistencia y almacenamiento: Las entidades suelen ser utilizadas para representar datos que se almacenan en una base de datos o en algún otro medio de almacenamiento. En estos casos, se utilizan técnicas de mapeo objeto-relacional (ORM) u otras técnicas para persistir y recuperar las entidades en el almacenamiento.
    \item Relaciones entre entidades: Las entidades pueden tener relaciones entre sí, formando una estructura de datos más compleja. Por ejemplo, en un sistema de gestión de pedidos, podría haber una entidad \enquote*{Pedido} que tiene una relación con una entidad \enquote*{Cliente}.
\end{enumerate}

En la arquitectura hexagonal, las entidades suelen pertenecer a la capa de infraestructura, representando entidades fundamentales del negocio. Estas entidades son independientes de las capas externas y no contienen detalles de implementación.

Las entidades desempeñan un papel central en la arquitectura, usualmente representan tablas de la base de datos. Mediante el uso de DTO's se puede conseguir relacionar las entidades con los modelos en el dominio.

\subsection{Inyección de dependencias}

La inyección de dependencias es un patrón de diseño utilizado en la programación orientada a objetos que permite gestionar las dependencias entre los componentes de una aplicación. En lugar de que un componente cree directamente sus dependencias, estas se inyectan desde el exterior, lo que proporciona una mayor flexibilidad, reutilización y facilita la prueba unitaria.

En la inyección de dependencias, se establece una separación clara entre la creación de un objeto y su uso, permitiendo que el objeto dependiente (llamado cliente) reciba las dependencias necesarias a través de algún mecanismo de inyección. Esto puede lograrse de varias formas:

\begin{enumerate}
    \item Inyección de dependencias constructor: Las dependencias se pasan como argumentos al constructor del objeto cliente durante su creación. Este enfoque garantiza que las dependencias requeridas estén disponibles desde el principio y promueve la creación de objetos inmutables.
    \item Inyección de dependencias por métodos/setters: Las dependencias se establecen a través de métodos o setters en el objeto cliente después de su creación. Esto permite una mayor flexibilidad en la configuración de las dependencias y permite la actualización de las mismas en tiempo de ejecución.
    \item Inyección de dependencias por contexto o contenedor: Se utiliza un contenedor de inversión de control (IoC) o un contexto que se encarga de gestionar la creación y la resolución de las dependencias. El cliente simplemente especifica las dependencias requeridas y el contenedor se encarga de inyectarlas automáticamente.
\end{enumerate}

Beneficios de la inyección de dependencias:

\begin{itemize}
    \item Mayor flexibilidad: Permite cambiar las implementaciones de las dependencias sin modificar el código del cliente, lo que facilita la adopción de diferentes configuraciones y la implementación de cambios sin impactar en otros componentes.
    \item Reutilización: Las dependencias se pueden compartir y reutilizar en diferentes componentes de la aplicación, evitando la duplicación de código y promoviendo una arquitectura más modular.
    \item Facilita la prueba unitaria: Al inyectar las dependencias, se pueden utilizar objetos simulados o de prueba para aislar el componente bajo prueba, lo que facilita la escritura de pruebas unitarias más robustas y reduce las dependencias externas.
    \item Desacoplamiento: La inyección de dependencias reduce el acoplamiento entre los componentes, ya que los objetos dependientes no están fuertemente acoplados a las implementaciones concretas de sus dependencias.
\end{itemize}

Por ejemplo. Supongamos que tienes una clase Cliente que necesita utilizar una implementación de la interfaz IServicioEmail para enviar correos electrónicos. En lugar de que la clase Cliente cree directamente una instancia de la implementación concreta de IServicioEmail, se utilizará la inyección de dependencias para recibirla desde el exterior.

\begin{lstlisting}
    public interface IServicioEmail
{
    void EnviarCorreo(string destinatario, string asunto, string contenido);
}

public class ServicioEmail : IServicioEmail
{
    public void EnviarCorreo(string destinatario, string asunto, string contenido)
    {
        // Implementacion para enviar el correo
        Console.WriteLine("Enviando correo a " + destinatario + ": " + asunto " - " contenido);
    }
}

public class Cliente
{
    private readonly IServicioEmail _servicioEmail;

    public Cliente(IServicioEmail servicioEmail)
    {
        _servicioEmail = servicioEmail;
    }

    public void MetodoEjemplo()
    {
        // Utiliza _servicioEmail para enviar un email
        _servicioEmail.EnviarEmail("destinatario@example.com", "Hola, esto es un ejemplo de email");
    }
}

\end{lstlisting}

En este ejemplo, la clase Cliente tiene una dependencia en la interfaz IServicioEmail, que representa la capacidad de enviar correos electrónicos. En el constructor de la clase Cliente, se espera una instancia de IServicioEmail para ser inyectada. Esto permite que el cliente sea independiente de la implementación concreta de IServicioEmail.

\begin{lstlisting}
services.AddTransient<IServicioEmail, ServicioEmail>();
\end{lstlisting}

En cualquier lugar donde necesites utilizar IServicioEmail, podemos hacerlo a través de la inyección de dependencia.

Con este enfoque, podemos cambiar fácilmente la implementación de IServicioEmail sin modificar la clase Cliente. Por ejemplo, podrías tener una implementación de IServicioEmail específica para pruebas unitarias que no envíe correos electrónicos reales, sino que los simule.

Recuerda que el alcance transitorio (AddTransient) crea una nueva instancia cada vez que se resuelve, lo cual puede ser adecuado para servicios livianos y sin estado. Si necesitas un comportamiento diferente, como un alcance de instancia única o un alcance por solicitud, podemos utilizar AddSingleton o AddScoped respectivamente en lugar de AddTransient en la configuración de inyección de dependencia.

\subsection*{Tipos de inyección de dependencias}

Las siguientes son configuraciones de inyección de dependencia en ASP.NET Core:

\begin{enumerate}
    \item \textbf{Singleto}n: Con AddSingleton, se registra una instancia única de una clase en el contenedor de inyección de dependencia. Esto significa que se crea una única instancia de la clase y se reutiliza cada vez que se resuelve esa dependencia. Es adecuado para objetos que deben compartirse en toda la aplicación. Aquí tienes un ejemplo:
   \begin{lstlisting}
services.AddSingleton<IServicioEmail, ServicioEmail>();
\end{lstlisting}
    \item \textbf{Scoped}: Con AddScoped, se registra una instancia por solicitud en el contenedor de inyección de dependencia. Esto significa que se crea una nueva instancia de la clase para cada solicitud HTTP entrante y se reutiliza en el ámbito de esa solicitud. Es útil cuando deseas que una instancia se mantenga durante la duración de una solicitud, pero no necesariamente en toda la aplicación. Aquí tienes un ejemplo:
   \begin{lstlisting}
services.AddScoped<IServicioEmail, ServicioEmail>();
\end{lstlisting}
    \item \textbf{Transitorio}: Con AddTransient, se registra una nueva instancia de la clase en cada solicitud de resolución en el contenedor de inyección de dependencia. Esto significa que se crea una nueva instancia cada vez que se resuelve la dependencia. Es útil cuando deseas una nueva instancia de la clase cada vez que se solicita. Aquí tienes un ejemplo:
   \begin{lstlisting}
services.AddTransient<IServicioEmail, ServicioEmail>();
\end{lstlisting}
\end{enumerate}

\section{Pruebas unitarias y de integración}
Las pruebas unitarias son una práctica esencial en el desarrollo de software que se enfoca en probar las unidades más pequeñas de código de forma aislada y automatizada. Estas unidades pueden ser métodos o funciones. Las pruebas unitarias se centran en verificar que cada una de estas unidades funcione correctamente de manera individual, cumpliendo con los requisitos establecidos y sin depender de otras partes del sistema.

El objetivo principal de las pruebas unitarias es asegurar que cada unidad de código produzca el resultado esperado para diferentes casos de prueba, evitando así la introducción de errores y asegurando que el software funcione correctamente en todas sus partes.

Al aplicar pruebas unitarias, los equipos de desarrollo obtienen diversos beneficios, entre ellos:

\begin{itemize}
  \item \textbf{Detección temprana de errores:} Las pruebas unitarias permiten identificar problemas y defectos en el código de manera temprana, lo que facilita su corrección antes de que se propaguen a otras partes del sistema.
  \item \textbf{Mantenimiento y refactorización:} Las pruebas unitarias brindan confianza al realizar cambios en el código, ya que proporcionan una forma de verificar rápidamente que las funcionalidades previamente implementadas sigan siendo válidas después de los cambios.
  \item \textbf{Documentación de uso:} Las pruebas unitarias sirven como una documentación ejecutable de cómo se debe utilizar una unidad de código. Al leer las pruebas, los desarrolladores pueden comprender rápidamente cómo utilizar y cómo debería comportarse el código.
  \item \textbf{Facilita el trabajo en equipo:} Las pruebas unitarias promueven la colaboración entre desarrolladores al proporcionar un conjunto de casos de prueba compartidos que definen el comportamiento esperado de las unidades de código.
\end{itemize}

Veamos un ejemplo práctico de pruebas unitarias para una clase llamada \emph{Cliente}. Esta clase representa un cliente de un banco y contiene atributos como nombre, apellido, correo electrónico y fecha de nacimiento. Nuestro objetivo es asegurar que la lógica de construcción de objetos \emph{Cliente} funcione correctamente, validando los parámetros ingresados durante la creación del objeto.

\begin{lstlisting}
using System.Text.RegularExpressions;

namespace Banco.Dominio.Modelos
{
    public class Cliente
    {
        public int MAYOR_EDAD = 18;
        public string TipoIdentificacion { get; set; }
        public string NumeroIdentificacion { get; set; }
        public string Nombre { get; set; }
        public string Apellido { get; set; }
        public DateTime FechaCreacion { get; set; }
        public DateTime FechaModificacion { get; set; }
        public string CorreoElectronico { get; set; }
        public DateTime FechaNacimiento { get; set; }
        public Cliente(string tipoIdentificacion, string numeroIdentificacion, string? _nombre, string apellido,
            string? _correoElectronico, DateTime _fechaNacimiento)
        {
            TipoIdentificacion = tipoIdentificacion;
            NumeroIdentificacion = numeroIdentificacion;
            Apellido = apellido;
            FechaCreacion = DateTime.Now;
            FechaModificacion = DateTime.Now;
            if (EsNombre(_nombre))
            {
                Nombre = _nombre;
            }
            else
            {
                throw new InvalidOperationException("El nombre no es valido.");
            }
            if (EsCorreoElectronicoValido(_correoElectronico))
            {
                CorreoElectronico = _correoElectronico;
            }
            else
            {
                throw new InvalidOperationException("El correo electronico no es valido.");
            }

            DateTime now = DateTime.Now;
            int anios = now.Year - _fechaNacimiento.Year;

            if ((anios >= MAYOR_EDAD) || (anios == MAYOR_EDAD-1 && now.Month > _fechaNacimiento.Month) || (anios == MAYOR_EDAD-1 && now.Month == _fechaNacimiento.Month && now.Day >= _fechaNacimiento.Day))
            {
                FechaNacimiento = _fechaNacimiento;
            }
            else
            {
                throw new InvalidOperationException("El cliente debe ser mayor de edad.");
            }
        }
        private bool EsCorreoElectronicoValido(string? email)
        {
            if (email == null) throw new ArgumentNullException(nameof(email));
            string patron = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$";
            Regex regex = new Regex(patron);
            return regex.IsMatch(email);
        }
        private bool EsNombre(string? nombre)
        {
            if (nombre == null) throw new ArgumentNullException(nameof(nombre));
            string patron = @"^[a-zA-Z\s]{2,}$";
            Regex regex = new Regex(patron);
            return regex.IsMatch(nombre);
        }
    }
}
\end{lstlisting}

Y esta puede ser la clase que contenga las pruebas unitarias suficientes para cubrir todo el codigo.

\begin{lstlisting}
public class ClienteTests
{
    [Fact]
    public void Constructor_ValidParameters_CreatesClienteObject()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = "John";
        string apellido = "Doe";
        string correoElectronico = "johndoe@example.com";
        DateTime fechaNacimiento = new DateTime(1990, 1, 1);
        // Act
        Cliente cliente = new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento);

        // Assert
        Assert.Equal(tipoIdentificacion, cliente.TipoIdentificacion);
        Assert.Equal(numeroIdentificacion, cliente.NumeroIdentificacion);
        Assert.Equal(nombre, cliente.Nombre);
        Assert.Equal(apellido, cliente.Apellido);
        Assert.Equal(correoElectronico, cliente.CorreoElectronico);
        Assert.Equal(fechaNacimiento, cliente.FechaNacimiento);
        Assert.Equal(typeof(DateTime), cliente.FechaCreacion.GetType());
        Assert.Equal(typeof(DateTime), cliente.FechaModificacion.GetType());
    }

    [Fact]
    public void Constructor_InvalidNombre_ThrowsException()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = "123"; // Nombre invalido
        string apellido = "Doe";
        string correoElectronico = "johndoe@example.com";
        DateTime fechaNacimiento = new DateTime(1990, 1, 1);

        // Act and Assert
        Assert.Throws<InvalidOperationException>(() =>
            new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento));
    }

    [Fact]
    public void Constructor_InvalidCorreoElectronico_ThrowsException()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = "John";
        string apellido = "Doe";
        string correoElectronico = "invalidemail"; // Correo electronico invalido
        DateTime fechaNacimiento = new DateTime(1990, 1, 1);

        // Act and Assert
        Assert.Throws<InvalidOperationException>(() =>
            new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento));
    }

    [Fact]
    public void Constructor_MenorEdad_ThrowsException()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = "John";
        string apellido = "Doe";
        string correoElectronico = "johndoe@example.com";
        DateTime fechaNacimiento = DateTime.Now.AddYears(-16); // Menor de edad

        // Act and Assert
        Assert.Throws<InvalidOperationException>(() =>
            new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento));
    }

    [Fact]
    public void EsCorreoElectronicoValido_null()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = "John";
        string apellido = "orton";
        string correoElectronico = null;
        DateTime fechaNacimiento = DateTime.Now.AddYears(-18); // Menor de edad

        // Act and Assert
        Assert.Throws<ArgumentNullException>(() =>
            new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento));
    }
    [Fact]
    public void EsNombreValido_null()
    {
        // Arrange
        string tipoIdentificacion = "Cedula";
        string numeroIdentificacion = "1234567890";
        string nombre = null;
        string apellido = "Doe";
        string correoElectronico = "johndoe@example.com";
        DateTime fechaNacimiento = DateTime.Now.AddYears(-18); // Menor de edad

        // Act and Assert
        Assert.Throws<ArgumentNullException>(() =>
            new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento));
    }
}
\end{lstlisting}

Podemos notar un patrón que se repite en cada prueba, llamado el patron triple A, también vemos cuál es la idea de las pruebas en conjunto, que es probar cada unidad de codigo existente, desde los casos donde un metodo arroja una respuesta hasta cuando arroje una excepción que hemos previsto, en este caso correos inválidos o válidos, nombres inválidos o válidos, cada uno \enquote*{activa} distinatas partes del código que, en conjunto, generan un comportamiento más robusto. Que las pruebas cubran cada caso, o al menos un representante de cada caso, genera una cobertura total de la clase en cuestión y nos ayuda a entender, cómo lectores, el funcionamiento del codigo.

\subsection{Patron AAA}
El patrón AAA (Arrange-Act-Assert) es una convención comúnmente utilizada en las pruebas unitarias para estructurar las pruebas de manera clara y legible. Este patrón divide la prueba en tres partes distintas: Arrange, Act y Assert.

\begin{itemize}
    \item \textbf{Arrange (Preparación):} En esta etapa, se prepara el entorno necesario para la prueba. Se configuran las condiciones iniciales, se crean objetos y se establecen las dependencias necesarias. Aquí se definen los datos de entrada y se configuran los valores esperados.
    \item \textbf{Act (Acción):} En esta etapa, se realiza la acción o el comportamiento que se quiere probar. Se invoca el método o se lleva a cabo la operación que se desea evaluar. Aquí se obtiene el resultado de la acción realizada.
    \item \textbf{Assert (Verificación):} En esta etapa, se verifica si el resultado obtenido de la acción realizada es el esperado. Se utilizan aserciones (assertions) para comparar el resultado actual con el valor esperado. Si la aserción es verdadera, la prueba pasa; de lo contrario, la prueba falla y veamos un mensaje de error.
\end{itemize}
El uso del patrón AAA facilita la comprensión de la intención de la prueba y mejora su mantenibilidad, ya que separa claramente las diferentes etapas de la misma. Podemos volver al ejemplo anterior, con una prueba de la clase \emph{ClienteTests}

\begin{lstlisting}
[Fact]
public void Constructor_ValidParameters_CreatesClienteObject()
{
    // Arrange
    string tipoIdentificacion = "Cedula";
    string numeroIdentificacion = "1234567890";
    string nombre = "John";
    string apellido = "Doe";
    string correoElectronico = "johndoe@example.com";
    DateTime fechaNacimiento = new DateTime(1990, 1, 1);

    // Act
    Cliente cliente = new Cliente(tipoIdentificacion, numeroIdentificacion, nombre, apellido, correoElectronico, fechaNacimiento);

    // Assert
    Assert.Equal(tipoIdentificacion, cliente.TipoIdentificacion);
    Assert.Equal(numeroIdentificacion, cliente.NumeroIdentificacion);
    Assert.Equal(nombre, cliente.Nombre);
    Assert.Equal(apellido, cliente.Apellido);
    Assert.Equal(correoElectronico, cliente.CorreoElectronico);
    Assert.Equal(fechaNacimiento, cliente.FechaNacimiento);
    Assert.Equal(typeof(DateTime), cliente.FechaCreacion.GetType());
    Assert.Equal(typeof(DateTime), cliente.FechaModificacion.GetType());
}
\end{lstlisting}

\subsection{TDD (Desarrollo Dirigido por Pruebas)}
El Desarrollo Dirigido por Pruebas (Test-Driven Development o TDD) es una metodología de desarrollo de software que se basa en escribir las pruebas unitarias antes de implementar el código de producción. Es un enfoque iterativo e incremental en el cual el ciclo de desarrollo consiste en tres pasos: Escribir una prueba, hacerla pasar y refactorizar.

El proceso de TDD sigue los siguientes pasos, iterando al agregar una nueva funcionalidad:

\begin{enumerate}
\item \textbf{Escribir una prueba (Write a test):} En esta etapa, se escribe una prueba unitaria que defina el comportamiento deseado del código a implementar. La prueba inicialmente fallará, ya que el código aún no existe. Este paso es llamado el paso rojo (red).
\item \textbf{Hacer pasar la prueba (Make the test pass):} En esta etapa, se implementa la funcionalidad mínima necesaria en el código para que la prueba pase. No se busca una implementación completa en esta etapa, solo lo suficiente para satisfacer la prueba. Este paso es llamado el paso verde (green).
\item \textbf{Refactorizar (Refactor):} Una vez que la prueba pasa, se realiza la refactorización del código para mejorar su calidad, eliminar duplicaciones y aplicar buenas prácticas de programación. Se asegura de que las pruebas sigan pasando después de cada refactorización.
\end{enumerate}

El TDD se centra en el desarrollo incremental y en la retroalimentación constante proporcionada por las pruebas unitarias. Al seguir esta metodología, se obtienen diversos beneficios, como un código más limpio y modular, mayor confianza en la calidad del código y una cobertura de pruebas más completa. También promueve un enfoque más centrado en el diseño y la arquitectura del código, ya que las pruebas ayudan a definir las interfaces y los requisitos antes de la implementación.

Supongamos que tenemos una clase llamada \emph{Cliente}, y queremos desarrollar un método que verifique que el correo electrónico tiene un patrón correcto.

Empezamos escribiendo la prueba unitaria para este método utilizando el marco de pruebas xUnit:

\begin{lstlisting}
using Xunit;

namespace ClienteTests
{
    public class ClienteTests
    {
        [Fact]
        public void EsCorreoElectronicoValido_ValidEmail_ReturnsTrue()
        {
            // Arrange
            string email = "john.doe@example.com";

            // Act
            bool result = Cliente.EsCorreoElectronicoValido(email);

            // Assert
            Assert.True(result);
        }

        [Fact]
        public void EsCorreoElectronicoValido_InvalidEmail_ReturnsFalse()
        {
            // Arrange
            string email = "invalid-email";

            // Act
            bool result = Cliente.EsCorreoElectronicoValido(email);

            // Assert
            Assert.False(result);
        }
    }
}
\end{lstlisting}

Procedemos a escribir el código necesario para que esta prueba pase:

\begin{lstlisting}
public class Cliente
{
    // Resto de propiedades y metodos de la clase Cliente

    public static bool EsCorreoElectronicoValido(string email)
    {
        if (email == null) throw new ArgumentNullException(nameof(email));
        
        // Utilizamos una expresion regular para validar el formato del correo electronico
        string patron = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$";
        Regex regex = new Regex(patron);
        return regex.IsMatch(email);
    }
}
\end{lstlisting}

Finalmente, hemos implementado el método \emph{EsCorreoElectronicoValido} de la clase \emph{Cliente}, y al ejecutar las pruebas, verificamos que la funcionalidad es correcta y se cumplen las condiciones esperadas.

\subsection{Moq}
Moq es un popular framework de moqueo para el lenguaje de programación C\#. Permite crear objetos simulados y configurar su comportamiento durante las pruebas unitarias. A continuación, veamos algunos conceptos y características clave de Moq:

\begin{itemize}
    \item \textbf{Instalación}: Moq se puede instalar a través del administrador de paquetes NuGet en Visual Studio. El paquete se llama \emph{Moq} y está disponible en la galería de paquetes de NuGet.

    \item \textbf{Creación de objetos simulados}: Moq permite crear objetos simulados utilizando el método estático \emph{Mock.Of<T>()}, donde \emph{T} representa el tipo de la interfaz o clase que se desea simular. También se puede utilizar el constructor de la clase \emph{Mock<T>()} para crear el objeto simulado.

    \item \textbf{Configuración de comportamiento}: Una vez creado el objeto simulado, se puede configurar su comportamiento utilizando el método \emph{Setup()} de Moq. Por ejemplo, se puede especificar el valor de retorno de un método simulado, lanzar una excepción, establecer el comportamiento de propiedades, etc.

    \item \textbf{Verificación de llamadas}: Moq proporciona métodos para verificar si se realizaron llamadas a métodos específicos en el objeto simulado. Por ejemplo, se puede utilizar el método \emph{Verify()} para comprobar si se llamó a un método en particular con los parámetros esperados.

    \item \textbf{ArgumentMatchers}: Moq ofrece soporte para ArgumentMatchers, que permiten definir reglas más flexibles al configurar el comportamiento de un método. Por ejemplo, se puede utilizar \emph{It.IsAny<T>()} para aceptar cualquier valor de un tipo determinado como argumento.

    \item \textbf{Callback}: Moq permite utilizar el método \emph{Callback()} para realizar acciones personalizadas cuando se llama a un método simulado. Esto puede ser útil para realizar verificaciones adicionales o ejecutar código adicional durante las pruebas.

    \item \textbf{Propiedades}: Moq permite configurar el comportamiento de propiedades en objetos simulados. Esto incluye establecer valores, permitir o evitar la lectura o escritura, y más.

    \item \textbf{Inyección de dependencias}: Moq se puede utilizar en combinación con patrones de inyección de dependencias para simular dependencias externas en las pruebas unitarias. Al utilizar Moq junto con un contenedor de inyección de dependencias, se pueden proporcionar objetos simulados en lugar de las implementaciones reales durante las pruebas.
\end{itemize}

Proporciona una sintaxis fácil de usar para configurar objetos simulados y verificar su comportamiento durante las pruebas unitarias. A continuación, profundizaremos en algunas de las características clave de Moq y brindaremos un ejemplo para ilustrar su uso.

\subsubsection*{Ejemplo de Uso de Moq en el Controlador ClienteController}

Supongamos que tenemos un controlador \emph{ClienteController} que depende de dos interfaces: \emph{IClienteServicio} e \emph{IRepositorioBase<ClienteEntidad, string>}. Queremos probar los métodos del controlador, y para ello utilizaremos Moq para simular las dependencias y configurar su comportamiento durante las pruebas.

\begin{lstlisting}
using Banco.Aplicacion.DTOs;
using Banco.Aplicacion.IRepositorios;
using Banco.Aplicacion.Servicios;
using Banco.Infraestructura.Datos.Entidades;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;

namespace Banco.Infraestructura.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class ClienteController : ControllerBase
    {
        private readonly IClienteServicio _clienteServicio;
        private readonly IRepositorioBase<ClienteEntidad, string> _clienteRepo;
        private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        public ClienteController(IClienteServicio clienteServicio, IRepositorioBase<ClienteEntidad, string> clienteRepo)
        {
            _clienteServicio = clienteServicio;
            _clienteRepo = clienteRepo;
        }

        // POST <ClienteController>
        [HttpPost]
        [ProducesResponseType(StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status500InternalServerError)]
        public ActionResult<ClienteDTO> Post([FromBody] ClienteDTO cliente)
        {
            try
            {
                log.Info($"Intentando agregar al cliente con cedula: {cliente.NumeroIdentificacion} y fecha de nacimiento: {cliente.FechaNacimiento}");

                string message = _clienteServicio.VerificadorUnicidadCedula(cliente.NumeroIdentificacion);
                if (!string.IsNullOrEmpty(message))
                {
                    message = $"El cliente no se puede registrar, ya existe alguien con esta cedula en nuestra base de datos: {message}";
                    log.Warn(message);
                    return StatusCode(StatusCodes.Status400BadRequest, new { message });
                }

                _clienteServicio.Agregar(cliente);
                log.Info($"Cliente con cedula {cliente.NumeroIdentificacion} agregado correctamente");
                return CreatedAtAction(nameof(Get), new { cedula = cliente.NumeroIdentificacion }, cliente);
            }
            catch (Exception ex)
            {
                log.Error($"Error al agregar el cliente con cedula: {cliente.NumeroIdentificacion}: {ex.Message}");
                return StatusCode(StatusCodes.Status500InternalServerError, new { ex.Message });
            }
        }
        // Otros Metodos del controlador ClienteController
    }
}
\end{lstlisting}

Ahora procederemos a realizar pruebas unitarias para el método POST del controlador \enquote*{ClienteController}. En estas pruebas, simularemos la dependencia \lstinline{IClienteServicio} utilizando Moq para verificar si el controlador se comporta correctamente en diferentes escenarios.

\begin{lstlisting}
using Banco.Aplicacion.DTOs;
using Banco.Aplicacion.IRepositorios;
using Banco.Aplicacion.Servicios;
using Banco.Infraestructura.Controllers;
using Moq;
using Xunit;

namespace Banco.Infraestructura.Tests
{
    public class ClienteControllerTests
    {
        private readonly Mock<IClienteServicio> _clienteServicioMock;
        private readonly Mock<IRepositorioBase<ClienteEntidad, string>> _clienteRepoMock;
        private readonly ClienteController _clienteController;

        public ClienteControllerTests()
        {
            _clienteServicioMock = new Mock<IClienteServicio>();
            _clienteRepoMock = new Mock<IRepositorioBase<ClienteEntidad, string>>();
            _clienteController = new ClienteController(_clienteServicioMock.Object, _clienteRepoMock.Object);
        }

        [Fact]
        public void Post_WithValidCliente_ReturnsCreatedResponse()
        {
            // Arrange
            var cliente = new ClienteDTO { NumeroIdentificacion = "1234567890", Nombre = "John", Apellido = "Doe" };

            // Simulamos que el metodo VerificadorUnicidadCedula retorna null, lo que indica que no existe otro cliente con la misma cedula.
            _clienteServicioMock.Setup(mock => mock.VerificadorUnicidadCedula(cliente.NumeroIdentificacion)).Returns((string)null);

            // Act
            var result = _clienteController.Post(cliente);

            // Assert
            var createdAtActionResult = Assert.IsType<CreatedAtActionResult>(result.Result);
            Assert.Equal(StatusCodes.Status201Created, createdAtActionResult.StatusCode);
            Assert.Equal(nameof(_clienteController.Get), createdAtActionResult.ActionName);
            Assert.Equal(cliente.NumeroIdentificacion, createdAtActionResult.RouteValues["cedula"]);

            var returnedCliente = Assert.IsType<ClienteDTO>(createdAtActionResult.Value);
            Assert.Equal(cliente, returnedCliente);
        }

        // Otras pruebas unitarias para el controlador ClienteController
        // ...
    }
}
\end{lstlisting}

En el ejemplo utilizamos Moq para simular la dependencia \emph{IClienteServicio} y configurar su comportamiento. También verificamos si el controlador se comporta correctamente y devuelve las respuestas esperadas en diferentes situaciones.

Estas pruebas aseguran que el controlador \emph{ClienteController} funcione según lo esperado y que los resultados sean coherentes con las entradas y las reglas de negocio. Utilizando Moq, podemos proporcionar objetos simulados para el servicio \emph{IClienteServicio} y así enfocarnos en probar específicamente la lógica del controlador. Esto nos permite crear pruebas más efectivas y precisas para asegurarnos de que nuestro código sea robusto y confiable.

\subsection{Cobertura de código con dotCover}

dotCover es una herramienta de cobertura de código desarrollada por JetBrains que te permite analizar la cobertura de tus pruebas unitarias en proyectos .NET. Cuando desarrollas aplicaciones, las pruebas unitarias son fundamentales para garantizar la calidad y estabilidad del código. Sin embargo, es igualmente importante asegurarse de que tus pruebas cubran adecuadamente todo el código que has escrito.

La cobertura de código es una medida que indica qué porcentaje de tu código ha sido ejecutado por tus pruebas unitarias. Con dotCover, podemos obtener información precisa sobre la cobertura de tus pruebas, identificar áreas no probadas y tomar decisiones informadas sobre cómo mejorar la calidad de tu código.

\subsubsection*{¿Por qué usar dotCover?}

A medida que tus proyectos se vuelven más complejos, mantener una cobertura de código adecuada se vuelve desafiante. Aquí es donde dotCover entra en juego y se convierte en una herramienta invaluable. Al utilizar dotCover en tu flujo de trabajo de pruebas unitarias, podemos obtener los siguientes beneficios:

\begin{itemize}
  \item \textbf{Identificación de áreas no probadas}: dotCover analiza tu código y te muestra qué partes no están siendo cubiertas por tus pruebas unitarias. Esto te ayuda a identificar áreas críticas que no están siendo evaluadas adecuadamente y te permite escribir pruebas adicionales para cubrir esas áreas.
  \item \textbf{Mejora de la calidad del código}: Al conocer la cobertura de tus pruebas unitarias, podemos tomar decisiones informadas sobre qué áreas necesitan una mayor atención. podemos enfocarte en mejorar la calidad del código en áreas críticas y reducir la probabilidad de errores.
  \item \textbf{Refactorización segura}: Cuando realizas cambios en tu código, la cobertura de dotCover te proporciona una medida objetiva de qué tan bien cubiertos están esos cambios por tus pruebas existentes. Esto te permite realizar refactorizaciones de manera segura, sabiendo que tus pruebas unitarias seguirán validando la funcionalidad correctamente.
\end{itemize}

\subsubsection*{Instalación}

Para instalar dotCover en Visual Studio, sigue estos pasos:

\begin{enumerate}
  \item Descarga e instala JetBrains dotCover desde el sitio web oficial de JetBrains.
  \item Abre Visual Studio y asegúrate de tener el proyecto abierto en el que deseas analizar la cobertura.
  \item Ve a la pestaña \enquote*{Extensiones} en la barra de menú superior y selecciona \enquote*{Gestor de extensiones} para abrir el Administrador de Extensiones de Visual Studio.
  \item En el Administrador de Extensiones, busca \enquote*{dotCover} en el cuadro de búsqueda y haz clic en \enquote{Descargar} para instalar la extensión de dotCover.
  \item Reinicia Visual Studio para completar la instalación.
\end{enumerate}

\subsubsection*{Uso}

Una vez que tienes dotCover instalado, podemos utilizarlo en Visual Studio de la siguiente manera:

\begin{enumerate}
  \item Abre el proyecto en Visual Studio y asegúrate de que las pruebas unitarias estén escritas y configuradas correctamente.
  \item En Visual Studio, ve al menú \enquote*{Pruebas} de la extensión \enquote*{JetBrains} y selecciona \enquote*{Analizar cobertura de dotCover} para iniciar el análisis de cobertura de código.
  \item Se abrirá una ventana de dotCover que muestra las opciones de análisis. Configura las opciones según tus necesidades, como el alcance del análisis, las pruebas unitarias a ejecutar, etc.
  \item Haz clic en el botón \enquote*{Iniciar} para comenzar el análisis de cobertura.
  \item dotCover ejecutará las pruebas unitarias y recopilará información sobre la cobertura del código.
  \item Después de finalizar el análisis, dotCover mostrará los resultados en una ventana especial. Aquí podemos ver métricas detalladas de cobertura, como el porcentaje de cobertura por línea, instrucción y rama.
  \item Explora los informes de cobertura para identificar áreas no cubiertas por las pruebas y toma acciones para mejorar la cobertura.
  \item Además, dotCover permite exportar los informes de cobertura en diferentes formatos, como HTML o XML, para compartirlos con otros miembros del equipo o integrarlos en tus procesos.
\end{enumerate}

\subsection{Pruebas de integración}

Las pruebas de integración son una fase crucial en el proceso de desarrollo de software que se enfoca en verificar la correcta interacción y funcionamiento conjunto de diferentes componentes o módulos del sistema. A diferencia de las pruebas unitarias, que evalúan las partes individuales del código de forma aislada, las pruebas de integración se centran en asegurar que todas las piezas se ensamblen adecuadamente y que el sistema funcione como una entidad cohesiva.

El objetivo principal de las pruebas de integración es detectar problemas que puedan surgir cuando los diferentes componentes del software se combinan y trabajan juntos. Algunos de los aspectos que se evalúan en estas pruebas incluyen:

\subsubsection*{Interoperabilidad}
Las pruebas de integración aseguran que los distintos módulos se comuniquen e interoperen correctamente entre sí. Esto implica verificar que las interfaces, formatos de datos y protocolos de comunicación sean compatibles y que los datos se transmitan correctamente de un componente a otro.

\subsubsection*{Flujo de datos}
Se verifica que los datos fluyan adecuadamente a través del sistema, desde la entrada hasta la salida, pasando por todos los procesos intermedios. Esto incluye evaluar la validez, transformación y consistencia de los datos a lo largo de su recorrido.

\subsubsection*{Funcionalidad conjunta}
Las pruebas de integración validan que las funcionalidades individuales de cada componente se combinen adecuadamente para lograr el resultado deseado del sistema en su conjunto.

\subsubsection*{Manejo de errores y excepciones}
Se verifica cómo el sistema maneja errores, excepciones y situaciones inesperadas en la interacción entre componentes, asegurándose de que se gestionen de manera adecuada y que no afecten negativamente al sistema.

\subsubsection*{Rendimiento y escalabilidad}
Se evalúa el rendimiento global del sistema y su capacidad para manejar cargas de trabajo significativas. Esto incluye analizar el tiempo de respuesta, la eficiencia y la escalabilidad del sistema.

\subsubsection*{Escenarios reales}
Las pruebas de integración intentan simular situaciones reales en las que el sistema operaría, asegurando que se comporta correctamente en condiciones similares a las del entorno de producción.

Algunas prácticas comunes en las pruebas de integración incluyen:

\subsubsection*{Enfoque incremental}
Se realiza la integración y las pruebas paso a paso, comenzando con componentes individuales y progresando hacia combinaciones más complejas. Esto permite detectar problemas tempranamente y facilita la identificación de las causas raíz de los errores.

\subsubsection*{Entornos de prueba similares a producción}
Es recomendable realizar las pruebas de integración en entornos que reflejen lo más posible el entorno de producción, lo que ayuda a prevenir sorpresas inesperadas cuando el software se despliega en el entorno real.

\subsubsection*{Automatización}
La automatización de las pruebas de integración permite ejecutarlas de manera repetitiva y consistente, acelerando el proceso de pruebas y facilitando la identificación de regresiones.

\subsubsection*{Ejemplo de una prueba de integración}

Podemos ver un ejemplo. Supongamos que tenemos este controlador:

\begin{lstlisting}
[Route("[controller]")]
[ApiController]
public class ClienteController : ControllerBase
{
    private readonly IClienteServicio _clienteServicio;
    private readonly IRepositorioBase<ClienteEntidad, string> _clienteRepo;
    private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

    public ClienteController(IClienteServicio clienteServicio, IRepositorioBase<ClienteEntidad, string> clienteRepo)
    {
        _clienteServicio = clienteServicio;
        _clienteRepo = clienteRepo;
    }

    // GET: <ClienteController>
    [HttpGet]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public ActionResult<List<ClienteDTO>> Get()
    {
        try
        {
            log.Info("Obteniendo lista de clientes");
            var clientes = _clienteServicio.Listar();
            return Ok(clientes);
        }
        catch (Exception ex)
        {
            log.Error($"Error al obtener la lista de clientes: {ex.Message}");
            return StatusCode(StatusCodes.Status500InternalServerError, new { ex.Message });
        }
    }

    // GET api/<ClienteController>/5
    [HttpGet("{cedula}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public ActionResult<ClienteDTO> Get(string cedula)
    {
        try
        {
            log.Info($"Obteniendo cliente con cedula: {cedula}");
            var cliente = _clienteServicio.SeleccionarPorID(cedula);
            if (cliente != null)
            {
                log.Info($"Cliente con cedula {cedula} encontrado correctamente");
                return Ok(cliente);
            }
            else
            {
                log.Warn($"No se encontro el cliente con cedula: {cedula}");
                return NotFound();
            }
        }
        catch (Exception ex)
        {
            log.Error($"Error al obtener el cliente con cedula: {cedula}: {ex.Message}");
            return StatusCode(StatusCodes.Status500InternalServerError, new { ex.Message });
        }
    }

    // POST <ClienteController>
    [HttpPost]
    [ProducesResponseType(StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public ActionResult<ClienteDTO> Post([FromBody] ClienteDTO cliente)
    {
        try
        {
            log.Info($"Intentando agregar al cliente con cedula: {cliente.NumeroIdentificacion} y fecha de nacimiento: {cliente.FechaNacimiento}");

            string message = _clienteServicio.VerificadorUnicidadCedula(cliente.NumeroIdentificacion);
            if (!string.IsNullOrEmpty(message))
            {
                message = $"El cliente no se puede registrar, ya existe alguien con esta cedula en nuestra base de datos: {message}";
                log.Warn(message);
                return StatusCode(StatusCodes.Status400BadRequest, new { message });
            }

            _clienteServicio.Agregar(cliente);
            log.Info($"Cliente con cedula {cliente.NumeroIdentificacion} agregado correctamente");
            return CreatedAtAction(nameof(Get), new { cedula = cliente.NumeroIdentificacion }, cliente);
        }
        catch (Exception ex)
        {
            log.Error($"Error al agregar el cliente con cedula: {cliente.NumeroIdentificacion}: {ex.Message}");
            return StatusCode(StatusCodes.Status500InternalServerError, new { ex.Message });
        }
    }

    // DELETE api/<ClienteController>/5
    [HttpDelete("{cedula}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public ActionResult<ClienteDTO> Delete(string cedula)
    {
        try
        {
            log.Info($"Eliminando cliente con cedula: {cedula}");
            var cliente = _clienteServicio.Eliminar(cedula);
            if (cliente != null)
            {
                log.Info($"Cliente con cedula {cedula} eliminado correctamente");
                return Ok(cliente);
            }
            else
            {
                log.Warn($"No se encontro el cliente con cedula: {cedula}");
                return NotFound();
            }
        }
        catch (Exception ex)
        {
            log.Error($"Error al borrar el cliente con cedula: {cedula}: {ex.Message}");
            return StatusCode(StatusCodes.Status500InternalServerError, new { ex.Message });
        }
    }
}
\end{lstlisting}

Y nos estamos conectando a una base de datos con este contexto

\begin{lstlisting}
public class BancoContexto : DbContext
{
    public DbSet<ProductoEntidad> Productos { get; set; }
    public DbSet<ClienteEntidad> Clientes { get; set; }
    public DbSet<TransferenciaEntidad> Transferencias { get; set; }
    public DbSet<RetiroEntidad> Retiros { get; set; }
    public DbSet<ConsignacionEntidad> Consignaciones { get; set; }
    public DbSet<UserEntidad> Usuarios { get; set; }

    private readonly string _tipoDB;

    public BancoContexto(string tipoDB)
    {
        _tipoDB = tipoDB;
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        IConfigurationRoot configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json")
            .Build();
        if(_tipoDB == "oracle")
        {
            var connectionString = configuration.GetConnectionString("oracle");
            optionsBuilder.UseOracle(connectionString);
        }
        else if(_tipoDB == "pgsql")
        {
            var connectionString = configuration.GetConnectionString("pgsql");
            optionsBuilder.UseNpgsql(connectionString);
        }
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.ApplyConfiguration(new TransferenciaConfig());
        modelBuilder.ApplyConfiguration(new RetiroConfig());
        modelBuilder.ApplyConfiguration(new ConsignacionConfig());
        modelBuilder.ApplyConfiguration(new ProductoConfig());
        modelBuilder.ApplyConfiguration(new ClienteConfig());
        modelBuilder.ApplyConfiguration(new UsersConfig());
    }
}
\end{lstlisting}

En este contexto, estoy permitiendo que el constructor reciba un indicador de cual base de datos se va a usar, pues la idea es que las pruebas de integracións se hagan con una instancia de postrges en docker, y la ejecución de la aplicación, de manera usual, se da conectandose a una base de datos de oracle. Por lo tanto, en el archivo \enquote*{appseting.json} deben estar las dos cadenas de conexión distintas.

Este es el servicio.

\begin{lstlisting}
public interface IClienteServicio : IServicioBase<ClienteDTO, string>
{
    string? VerificadorUnicidadCedula(string cedula);
    ClienteDTO Eliminar(string cedula);
}
public class ClienteServicio : IClienteServicio
{
    private readonly IRepositorioBase<ClienteEntidad, string> repoCliente;
    private readonly IRepositorioBase<ProductoEntidad, string> repoProducto;

    public ClienteServicio(IRepositorioBase<ClienteEntidad, string> _repoCliente, IRepositorioBase<ProductoEntidad, string> _repoProducto)
    {
        repoCliente = _repoCliente;
        repoProducto = _repoProducto;
    }
    public ClienteDTO Agregar(ClienteDTO clienteDTO)
    {
        if (clienteDTO.NumeroIdentificacion == null || clienteDTO.TipoIdentificacion == null)
            throw new ArgumentNullException(nameof(clienteDTO), "La identificacion es requerida");

        Cliente? clienteModelo = ClienteToClienteDTO.Map(clienteDTO);
        var clienteEntidad = repoCliente.Agregar(ClienteDTOToClienteEntidad.Map(clienteDTO));
        repoCliente.SalvarTodo();
        return ClienteDTOToClienteEntidad.Map(clienteEntidad);
    }
    public List<ClienteDTO> Listar()
    {
        return ClienteDTOToClienteEntidad.Map(repoCliente.Listar());
    }

    public ClienteDTO? SeleccionarPorID(string cedula)
    {
        return ClienteDTOToClienteEntidad.Map(repoCliente.SeleccionarPorID(cedula));
    }
    public string? VerificadorUnicidadCedula(string cedula)
    {
        string mensaje = "";
        ClienteDTO cliente = SeleccionarPorID(cedula);
        mensaje = cliente?.Nombre ?? string.Empty;
        return mensaje;
    }
    public ClienteDTO Eliminar(string cedula)
    {
        List<ProductoEntidad> Productos = repoProducto.Listar();
        Productos = Productos.Where(p => p.ClienteId == cedula).ToList();
        if (Productos.Count > 0)
        {
            throw new ArgumentNullException(nameof(Productos), "No se puede eliminar un cliente que tenga productos vinculados");
        }
        ClienteDTO cliente = ClienteDTOToClienteEntidad.Map(repoCliente.Eliminar(cedula));
        return cliente;
    }
}
\end{lstlisting}

y estos son los repositorios

\begin{lstlisting}
public class ClienteRepositorio : IRepositorioBase<ClienteEntidad, string>
{
    private readonly BancoContexto db;
    public ClienteRepositorio(BancoContexto contexto)
    {
        db = contexto;
    }

    public ClienteEntidad? SeleccionarPorID(string cedula)
    {
        var Selecc = db.Clientes.Where(olinea => olinea.NumeroIdentificacion == cedula).FirstOrDefault();
        return Selecc;
    }

    public List<ClienteEntidad> Listar()
    {
        return db.Clientes.ToList();
    }

    public ClienteEntidad Eliminar(string cedula)
    {
        var cliente = db.Clientes.Find(cedula) ?? throw new InvalidOperationException("No se encuentra el cliente");
        db.Clientes.Remove(cliente);
        db.SaveChanges();
        return cliente;
    }

    public void SalvarTodo()
    {
        db.SaveChanges();
    }

    public ClienteEntidad Agregar(ClienteEntidad cliente)
    {
        db.Clientes.Add(cliente);
        return cliente;
    }

    public ClienteEntidad Actualizar(ClienteEntidad cliente)
    {
        ClienteEntidad? Selecc = db.Clientes
            .Where(olinea => olinea.NumeroIdentificacion == cliente.NumeroIdentificacion).FirstOrDefault() ?? throw new InvalidOperationException("No se encuentra el cliente");
        Selecc.TipoIdentificacion = cliente.TipoIdentificacion;
        Selecc.FechaNacimiento = cliente.FechaNacimiento;
        Selecc.Nombre = cliente.Nombre;
        Selecc.Apellido = cliente.Apellido;
        Selecc.FechaModificacion = DateTime.Now.ToString("yyyy-MM-dd");
        Selecc.CorreoElectronico = cliente.CorreoElectronico;
        db.Entry(cliente).State = EntityState.Modified;
        db.SaveChanges();
        return cliente;
    }

    public void Editar(ClienteEntidad modelo)
    {
        throw new NotImplementedException();
    }
}
public class ProductoRepositorio : IRepositorioBase<ProductoEntidad, string>
{
    private readonly BancoContexto db;
    private readonly ClienteRepositorio _repoCliente;

    public ProductoRepositorio(BancoContexto contexto, ClienteRepositorio repoCliente)
    {
        db = contexto;
        _repoCliente = repoCliente;
    }
    public ProductoEntidad Actualizar(ProductoEntidad producto)
    {
        ProductoEntidad? selecc = db.Productos.FirstOrDefault(linea => linea.NumeroDeCuenta == producto.NumeroDeCuenta) ?? throw new InvalidOperationException("No se encuentra el producto");
        selecc.ClienteId = producto.ClienteId;
        selecc.saldo = producto.saldo;
        selecc.Tipo = producto.Tipo;
        selecc.estado = producto.estado;
        db.Entry(producto).State = EntityState.Modified;
        db.SaveChanges();

        var cliente = _repoCliente.SeleccionarPorID(producto.ClienteId);
        ClienteEntidad clienteEntidad = _repoCliente.Actualizar(cliente);
        return producto;
    }
    public ProductoEntidad Agregar(ProductoEntidad producto)
    {
        db.Productos.Add(producto);
        db.SaveChanges();
        return producto;
    }
    public void Editar(ProductoEntidad producto)
    {
        Actualizar(producto);
    }
    public ProductoEntidad Eliminar(string numeroCuenta)
    {
        var producto = db.Productos.Find(numeroCuenta) ?? throw new InvalidOperationException("No se encuentra el cliente");
        db.Productos.Remove(producto);
        db.SaveChanges();
        return producto;
    }
    public void SalvarTodo()
    {
        db.SaveChanges();
    }

    public List<ProductoEntidad> Listar()
    {
        return db.Productos.ToList();
    }

    public ProductoEntidad? SeleccionarPorID(string numeroCuenta)
    {
        var Selecc = db.Productos.FirstOrDefault(linea => linea.NumeroDeCuenta == numeroCuenta);
        return Selecc;
    }
}
\end{lstlisting}

Veamos el resto de dependencias, como los config.

\begin{lstlisting}
public class ClienteConfig : IEntityTypeConfiguration<ClienteEntidad>
{
    public void Configure(EntityTypeBuilder<ClienteEntidad> builder)
    {
        builder.ToTable("Clientes");
        builder.HasKey(c => c.NumeroIdentificacion);
    }
}
public class ProductoConfig : IEntityTypeConfiguration<ProductoEntidad>
{
    public void Configure(EntityTypeBuilder<ProductoEntidad> builder)
    {
        builder.ToTable("Productos");
        builder.HasKey(c => c.NumeroDeCuenta);
    }
}
\end{lstlisting}

Por otra parte, en la parte de la inyección de dependencias estamos inyectando de esta forma los servicios.

\begin{lstlisting}
using Banco.Infraestructura.Datos.Entidades;
using Banco.Aplicacion.Servicios;
using Banco.Aplicacion.IRepositorios;
using Banco.Infraestructura.Datos.Contexto;
using Banco.Infraestructura.Datos.Repositorios;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;
using log4net.Config;

var builder = WebApplication.CreateBuilder(args);

Console.WriteLine("Creando la DB si no existe...");
string tipoDB = "oracle";
BancoContexto db = new BancoContexto(tipoDB);
db.Database.EnsureCreated();
Console.WriteLine("Listo.");

// Configurar Log4Net
var logConfig = new FileInfo("log4net.config");
XmlConfigurator.ConfigureAndWatch(logConfig);

// Add services to the container.
builder.Services.AddSingleton(tipoDB);
builder.Services.AddControllers();
builder.Services.AddTransient<BancoContexto>();
builder.Services.AddTransient<IRepositorioBase<ClienteEntidad, String>, ClienteRepositorio>();
builder.Services.AddTransient<ClienteRepositorio>();
builder.Services.AddTransient<IClienteServicio, ClienteServicio>();
builder.Services.AddTransient<ClienteServicio>();

builder.Services.AddTransient<IRepositorioBase<ProductoEntidad, String>, ProductoRepositorio>();
builder.Services.AddTransient<ProductoRepositorio>();
builder.Services.AddTransient<IProductoServicio, ProductoServicio>();
builder.Services.AddTransient<ProductoServicio>();

builder.Services.AddTransient<IRepositorioMovimiento<ConsignacionEntidad, Guid>, ConsignacionRepositorio>();
builder.Services.AddTransient<ConsignacionRepositorio>();
builder.Services.AddTransient<IConsignacionServicio, ConsignacionServicio>();
builder.Services.AddTransient<ConsignacionServicio>();

builder.Services.AddTransient<IRepositorioMovimiento<RetiroEntidad, Guid>, RetiroRepositorio>();
builder.Services.AddTransient<RetiroRepositorio>();
builder.Services.AddTransient<IRetiroServicio, RetiroServicio>();
builder.Services.AddTransient<RetiroServicio>();

builder.Services.AddTransient<IRepositorioMovimiento<TransferenciaEntidad, Guid>, TransferenciaRepositorio>();
builder.Services.AddTransient<TransferenciaRepositorio>();
builder.Services.AddTransient<ITransferenciaServicio, TransferenciaServicio>();
builder.Services.AddTransient<TransferenciaServicio>();

builder.Services.AddTransient<IUserRepositorio, UserRepositorio>();
builder.Services.AddTransient<UserRepositorio>();

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o =>
{
    o.TokenValidationParameters = new TokenValidationParameters
    {
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey
        (Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"])),
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true
    };
});

builder.Services.AddAuthorization();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseAuthorization();
app.UseHttpsRedirection();
app.MapControllers();//.RequireAuthorization();
app.MapPost("/security/createToken", [AllowAnonymous] (UserEntidad user, IUserRepositorio userRepositorio) =>
{
    // Usar la dependencia IUserRepositorio para verificar si el usuario esta autorizado

    if (userRepositorio.VerificarCredenciales(user))
    {
        var issuer = builder.Configuration["Jwt:Issuer"];
        var audience = builder.Configuration["Jwt:Audience"];
        var tokenDurationSeconds = builder.Configuration.GetValue<int>("Jwt:TokenDurationSeconds");
        var key = Encoding.ASCII.GetBytes(builder.Configuration["Jwt:Key"]);

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("Id", Guid.NewGuid().ToString()),
                new Claim(JwtRegisteredClaimNames.Sub, user.UserName),
                new Claim(JwtRegisteredClaimNames.Email, user.UserName),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            }),
            Expires = DateTime.UtcNow.AddSeconds(tokenDurationSeconds),
            Issuer = issuer,
            Audience = audience,
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha512Signature)
        };
        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        var jwtToken = tokenHandler.WriteToken(token);

        return Results.Ok(jwtToken);
    }

    return Results.Unauthorized();
});

app.Run();
\end{lstlisting}

En este \emph{program.cs} estamos usando algunas cosas de las que hablamos en la sección \enquote*{Fundamentos de .NET} como \emph{log4Net}, entre otras, además tenemos inyectados otros servicios. Como podemos ver, se inyecta el controlador junto con las dependencias de este en esta parte del program.

\begin{lstlisting}
Console.WriteLine("Creando la DB si no existe...");
string tipoDB = "oracle";
BancoContexto db = new BancoContexto(tipoDB);
db.Database.EnsureCreated();
Console.WriteLine("Listo.");

//otros servicios

builder.Services.AddSingleton(tipoDB);
builder.Services.AddControllers();
builder.Services.AddTransient<BancoContexto>();
builder.Services.AddTransient<IRepositorioBase<ClienteEntidad, String>, ClienteRepositorio>();
builder.Services.AddTransient<ClienteRepositorio>();
builder.Services.AddTransient<IClienteServicio, ClienteServicio>();
builder.Services.AddTransient<ClienteServicio>();

builder.Services.AddTransient<IRepositorioBase<ProductoEntidad, String>, ProductoRepositorio>();
builder.Services.AddTransient<ProductoRepositorio>();
\end{lstlisting}

Por lo cual, cuando hacemos la prueba de integración debemos inyectar las dependencias como las necesitamos. Y así tenemos la prueba del contolador.

\begin{lstlisting}
public class IntegrationTestsControllers
{
    //docker run -d --name mi_postgres -e POSTGRES_USER=user -e POSTGRES_PASSWORD=password -p 5433:5432 postgres
    private readonly IClienteServicio _clienteServicio;
    private readonly IRepositorioBase<ClienteEntidad, string> _clienteRepo;
    private readonly IProductoServicio _productoServicio;
    private readonly IRepositorioBase<ProductoEntidad, string> _productoRepo;
    private readonly ITransferenciaServicio _transferenciaServicio;
    private readonly IRepositorioMovimiento<TransferenciaEntidad, Guid> _transferenciaRepo;
    private readonly ClienteController _clienteController; 
    private readonly ProductoController _productoController;
    private readonly TransferenciaController _transferenciaController;
    private readonly IConsignacionServicio _consignacionServicio;
    private readonly IRepositorioMovimiento<ConsignacionEntidad, Guid> _consignacionRepo;
    private readonly ConsignacionController _consignacionController;
    private readonly IRetiroServicio _retiroServicio;
    private readonly IRepositorioMovimiento<RetiroEntidad, Guid> _retiroRepo;
    private readonly RetiroController _retiroController;
    public IntegrationTestsControllers()
    {
        string tipoDB = "pgsql";
        Console.WriteLine("Creando la DB si no existe...");
        BancoContexto db = new BancoContexto(tipoDB);
        db.Database.EnsureCreated();
        Console.WriteLine("Listo.");
        // Configurar el contenedor de dependencias
        var services = new ServiceCollection();
        services.AddSingleton(tipoDB);
        services.AddControllers();
        services.AddTransient<BancoContexto>();
        services.AddTransient<IRepositorioBase<ClienteEntidad, string>, ClienteRepositorio>();
        services.AddTransient<ClienteRepositorio>();
        services.AddTransient<IRepositorioBase<ProductoEntidad, string>, ProductoRepositorio>();
        services.AddTransient<ProductoRepositorio>();
        services.AddTransient<IProductoServicio, ProductoServicio>();
        services.AddTransient<ProductoServicio>();
        services.AddTransient<IClienteServicio, ClienteServicio>();
        services.AddTransient<ClienteServicio>();

        // Construir el proveedor de servicios
        var serviceProvider = services.BuildServiceProvider();

        // Obtener las instancias de los servicios que necesitas
        _clienteServicio = serviceProvider.GetRequiredService<IClienteServicio>();
        _clienteRepo = serviceProvider.GetRequiredService<IRepositorioBase<ClienteEntidad, string>>();
        _productoRepo = serviceProvider.GetRequiredService<IRepositorioBase<ProductoEntidad, string>>();
        // Inicializar el controlador con las dependencias
        _clienteController = new ClienteController(_clienteServicio, _clienteRepo);
    }
    [Fact]
    public async Task TestCrearYEliminarCliente()
    {
        // Arrange - Crear un nuevo cliente
        var cedula = "987654321";
        var nombre = "Jane";
        var apellido = "Smith";
        var fechaNacimiento = new DateTime(1985, 5, 15);
        var CorreoElectronico = "johndo@example.com";
        var clienteDTO = new ClienteDTO
        {
            TipoIdentificacion = "cedula",
            NumeroIdentificacion = cedula,
            Nombre = nombre,
            Apellido = apellido,
            FechaNacimiento = fechaNacimiento,
            CorreoElectronico = CorreoElectronico
        };

        // Act - POST: Crear el cliente
        var postResponse = _clienteController.Post(clienteDTO);

        // Assert - Verificar que el cliente fue creado correctamente
        Assert.IsType<ActionResult<ClienteDTO>>(postResponse);

        // Act - GET: Obtener el cliente recien creado
        var getResponse = _clienteController.Get(cedula);

        // Assert - Verificar que el cliente existe y tiene los datos correctos
        Assert.IsType<ActionResult<ClienteDTO>>(getResponse);

        // Act - DELETE: Eliminar el cliente
        var deleteResponse = _clienteController.Delete(cedula);

        // Assert - Verificar que el cliente fue eliminado correctamente
        Assert.IsType<ActionResult<ClienteDTO>>(deleteResponse);
    }
    [Fact]
    public async Task TestProductoController()
    {
        // Arrange
        var cedula = "987654321";
        var nombre = "Jane";
        var apellido = "Smith";
        var fechaNacimiento = new DateTime(1985, 5, 15);
        var CorreoElectronico = "johndo@example.com";
        var clienteDTO = new ClienteDTO
        {
            TipoIdentificacion = "cedula",
            NumeroIdentificacion = cedula,
            Nombre = nombre,
            Apellido = apellido,
            FechaNacimiento = fechaNacimiento,
            CorreoElectronico = CorreoElectronico
        };

        var productoDTO = new ProductoDTO
        {
            ClienteId = cedula,
            Tipo = "corriente",
            saldo = 0
        };

        // Act - POST: Crear el cliente
        var postResponseCliente = _clienteController.Post(clienteDTO);

        // Assert - Verificar que el cliente fue creado correctamente
        Assert.IsType<ActionResult<ClienteDTO>>(postResponseCliente);

        // Act - POST: Crear el producto
        var postResponse = _productoController.Post(productoDTO);

        // Convertir el objeto ProductoDTO a formato JSON
        var productoJson = JsonConvert.SerializeObject(postResponse);

        // Assert - Verificar que el producto fue creado correctamente
        Assert.IsType<ActionResult<ProductoDTO>>(postResponse);
        var responseObject = JObject.Parse(productoJson);

        // Acceder a la clave "numeroDeCuenta" en el objeto ProductoDTO
        var resultObject = responseObject["Result"];
        var producto = resultObject?["Value"]?.ToObject<ProductoDTO>();
        var numeroDeCuenta = producto?.numeroDeCuenta;

        // Act - Delete: Eliminar el producto
        var deleteResponseProducto = _productoController.Delete(numeroDeCuenta);

        // Assert - Verificar que el producto fue creado correctamente
        Assert.IsType<ActionResult<ProductoDTO>>(deleteResponseProducto);

        // Act - DELETE: Eliminar el cliente
        var deleteResponse = _clienteController.Delete(cedula);

        // Assert - Verificar que el cliente fue eliminado correctamente
        Assert.IsType<ActionResult<ClienteDTO>>(deleteResponse);
    }
\end{lstlisting}

Notemos que estamos creando, leyendo y eliminando un cliente, lo cual prueba parcialmente la funcionalidad del controlador, y prueba la integración con la base de datos. No es necesario probar los casos de excepciones, pues estos se deben probar en las pruebas unitarias. Por otra parte, esta prueba de integración se puede hacer a nivel del servicio, pues desde este se podría crear, leer y eliminar un cliente, pero es útil ver que el controlador funcione, cómo debería funcionar en un ambiente de producción.

\section{SonarQube}
SonarQube es una plataforma de análisis estático de código que ayuda a medir y mejorar la calidad del software. Proporciona un conjunto de herramientas y características para evaluar la salud y el mantenimiento del código fuente, identificar problemas de calidad y seguridad, y ofrecer recomendaciones para su mejora.

La principal función de SonarQube es realizar análisis estáticos en el código fuente para detectar problemas y violaciones de buenas prácticas de programación. Utiliza una variedad de reglas predefinidas y personalizables que abarcan aspectos como complejidad del código, duplicación, seguridad, mantenibilidad y cumplimiento de estándares de codificación. Estas reglas son aplicadas de manera automática al código fuente, y los resultados veamos en un informe detallado y fácil de entender.

\begin{enumerate}
    \item \textbf{Integración continua}: SonarQube se puede integrar con herramientas de integración continua como Jenkins, Azure DevOps, GitLab CI/CD, entre otras. Esto permite realizar análisis de calidad de manera automática en cada etapa del ciclo de desarrollo de software.
    \item \textbf{Control de deuda técnica}: SonarQube ayuda a identificar y medir la deuda técnica en el código. La deuda técnica se refiere a la acumulación de problemas y malas prácticas que aumentan la complejidad y dificultan el mantenimiento del software. SonarQube proporciona métricas y seguimiento de la deuda técnica, lo que ayuda a priorizar y planificar las actividades de mejora.
    \item \textbf{Seguridad del código}: SonarQube incluye análisis de seguridad del código para identificar vulnerabilidades y riesgos potenciales en el software. Puede detectar problemas como inyecciones SQL, vulnerabilidades de seguridad conocidas, configuraciones inseguras y más. Esto permite a los equipos de desarrollo abordar los problemas de seguridad desde las etapas iniciales del desarrollo.
    \item \textbf{Integración con IDE y control de versiones}: SonarQube proporciona plugins e integraciones con IDE populares como Visual Studio, Eclipse, IntelliJ IDEA, lo que permite realizar análisis de calidad directamente desde el entorno de desarrollo. También se integra con sistemas de control de versiones como Git, SVN, TFS, lo que facilita el seguimiento de la calidad del código a lo largo del tiempo.
    \item \textbf{Gestión de portafolios}: SonarQube ofrece características para gestionar múltiples proyectos y aplicaciones dentro de un portafolio. Permite obtener una vista consolidada de la calidad del código en todos los proyectos, establecer métricas y objetivos comunes, y facilitar la gestión centralizada de la calidad del software.
\end{enumerate}

Para efectos de los que hablamos C\# seguiremos hablando acerca de SonartLint, que es el plugin en VisualStudio.

\subsection*{}
\end{document}