\documentclass[executivepaper]{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel} % Establece el idioma español
\usepackage{csquotes} % Carga el paquete csquotes
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[left=1.00cm, right=1.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}
\setlength{\parindent}{0.5in}
\usepackage{setspace}
\doublespacing

% Define colores para el código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{mycolor}{RGB}{0,0,255}
% Configuración de lstlisting
\lstset{
    inputencoding=utf8,
    language=SQL,
    basicstyle=\ttfamily,
    columns=fullflexible,
    backgroundcolor=\color{backcolour},     
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{cyan!60!black},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    morekeywords={DECLARE,
                    BEGIN,
                    END,
                    PACKAGE,
                    IS,
                    BODY,
                    FUNCTION,
                    PROCEDURE,
                    RETURN,
                    LOOP,
                    IF,
                    FOR,
                    WHILE,
                    EXIT,
                    SUBSTR,
                    LENGTH,
                    UPPER,
                    LOWER,
                    INSTR,
                    REPLACE,
                    TRIM,
                    SERVEROUTPUT,
                    },
}

% Configuración del paquete hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=gray,
}

\title{PL/SQL}
\author{Kevin Cárdenas}

\begin{document}

\begin{titlepage}
    \begin{center}
        {\Huge \textbf{PL/SQL}}
        \\[18cm]

        \large\emph{Autor:}\\
        Kevin Cárdenas.
        \\[1cm]
        {\large 2023}
    \end{center}
\end{titlepage}
\newpage
\tableofcontents
\newpage

\section{Introducción}
PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programación procedural desarrollado por Oracle Corporation para su uso con el sistema de gestión de bases de datos Oracle. Fue creado en la década de 1990 como una extensión del lenguaje SQL estándar, con el objetivo de proporcionar capacidades avanzadas de programación y lógica empresarial en el contexto de una base de datos relacional.

PL/SQL combina elementos de lenguajes de programación procedurales tradicionales, como variables, estructuras de control de flujo y subrutinas, con la potencia del lenguaje SQL para interactuar con la base de datos. Esto permite a los desarrolladores crear aplicaciones más complejas y sofisticadas que pueden aprovechar todas las capacidades de una base de datos relacional.

Una de las principales ventajas de PL/SQL es su estrecha integración con Oracle Database. Los programas PL/SQL se ejecutan directamente en el servidor de la base de datos, lo que reduce la necesidad de enviar múltiples consultas desde una aplicación cliente y minimiza la cantidad de datos transferidos a través de la red. Esto mejora significativamente el rendimiento y la eficiencia de las aplicaciones, especialmente en entornos empresariales donde el acceso a la base de datos es fundamental.

PL/SQL se utiliza ampliamente para desarrollar funciones, procedimientos almacenados, desencadenadores (triggers) y paquetes, que encapsulan la lógica de negocio y proporcionan una capa de abstracción adicional sobre los datos almacenados en la base de datos. Estas construcciones permiten una mejor organización y modularidad del código, promoviendo la reutilización y el mantenimiento eficiente de la lógica empresarial.

\subsection{Bloques de PL/SQL}
Un bloque de PL/SQL es una unidad básica de código en PL/SQL. Puede contener declaraciones, sentencias SQL y lógica de programación. Los bloques de PL/SQL se utilizan para encapsular la lógica de negocio y pueden ser anónimos o nombrados.

Los bloques anónimos se ejecutan de forma inmediata, mientras que los bloques nombrados se almacenan en la base de datos y se pueden invocar desde otras partes del sistema.

A continuación, se muestra un ejemplo de un bloque de PL/SQL anónimo:

\begin{lstlisting}
SET SERVEROUTPUT ON --Imprimir mensajes en consola

DECLARE
    nombre VARCHAR2(50) := 'Juan';
    edad NUMBER := 30;
BEGIN
    -- Logic of program
    IF edad >= 18 THEN
        DBMS_OUTPUT.PUT_LINE(nombre || ' es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE(nombre || ' es menor de edad');
    END IF;
END;

-- Sentencias SQL
INSERT INTO empleados (nombre, salario)
    VALUES ('Ana', 5000);

COMMIT;
END;
/
\end{lstlisting}

En este ejemplo, el bloque de PL/SQL anónimo comienza con la palabra clave \enquote*{BEGIN} y finaliza con \enquote*{/} para indicar el final del bloque. Dentro del bloque, se pueden realizar declaraciones como la declaración de variables y constantes. Además, se puede incluir lógica de programación como condicionales y sentencias SQL para manipular la base de datos.

Por otro lado, los bloques de PL/SQL nombrados se almacenan en la base de datos y se pueden invocar desde otras partes del sistema. A continuación se muestra un ejemplo de un procedimiento almacenado, que es un tipo de bloque de PL/SQL nombrado:

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE calcular_salario(p_empleado_id NUMBER) AS
v_salario NUMBER;
BEGIN
    -- Logica para calcular el salario del empleado
    SELECT salario INTO v_salario
        FROM empleados
        WHERE empleado_id = p_empleado_id;

    DBMS_OUTPUT.PUT_LINE('El salario del empleado ' || p_empleado_id || ' es: ' || v_salario);
END;
/
\end{lstlisting}

En este ejemplo, se crea un procedimiento almacenado llamado \enquote*{calcular\_salario} que acepta un parámetro de empleado\_id. Dentro del procedimiento, se realiza una consulta para obtener el salario del empleado correspondiente al empleado\_id proporcionado. Luego, se muestra el salario utilizando la función DBMS\_OUTPUT.PUT\_LINE.

Además de los bloques anónimos y los procedimientos almacenados, PL/SQL también ofrece la posibilidad de crear disparadores (triggers). Los disparadores son bloques de PL/SQL que se ejecutan automáticamente en respuesta a eventos específicos que ocurren en la base de datos, como la inserción, actualización o eliminación de datos en una tabla.

A continuación se muestra un ejemplo de un disparador (trigger) que se activa después de insertar una nueva fila en la tabla \enquote*{empleados}:

\begin{lstlisting}
CREATE OR REPLACE TRIGGER insertar_empleado_trigger
AFTER INSERT ON empleados
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Nuevo empleado insertado: ' || :NEW.nombre);
END;
/
\end{lstlisting}

En este ejemplo, el disparador \enquote*{insertar\_empleado\_trigger} se ejecuta después de cada inserción en la tabla \enquote*{empleados}. El bloque de PL/SQL dentro del disparador muestra un mensaje que indica el nombre del nuevo empleado que se ha insertado.

Los disparadores son una poderosa herramienta en PL/SQL que permiten automatizar acciones y aplicar lógica adicional en la base de datos en respuesta a eventos específicos.

\subsection{Variables y constantes}
En PL/SQL, se pueden declarar variables y constantes para almacenar y manipular datos. Las variables se utilizan para almacenar valores temporales y pueden cambiar durante la ejecución del programa. Las constantes, por otro lado, son valores fijos que no pueden modificarse una vez que se les ha asignado un valor. Tanto las variables como las constantes pueden tener diferentes tipos de datos, como enteros, caracteres, fechas, etc.

Algunos de los tipos de datos más comunes en PL/SQL. Cada tipo de dato tiene características específicas y se debe elegir según el tipo de datos que se desea almacenar y manipular en la base de datos.

\begin{itemize}
    \item \textbf{VARCHAR2}: se utiliza para almacenar cadenas de caracteres.
\begin{lstlisting}
DECLARE
    nombre VARCHAR2(50) := 'Juan';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Nombre: ' || nombre);
END;    
\end{lstlisting}
    \item \textbf{NUMBER}: se utiliza para almacenar números enteros o decimales.
\begin{lstlisting}
DECLARE
    sueldo NUMBER(10, 2) := 5000.50;
    extras NUMBER(10, 2) := 200.50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Saldo: ' || TO_CHAR(sueldo + extras));
END;
\end{lstlisting}
    \item \textbf{DATE}: se utiliza para almacenar fechas y horas.
\begin{lstlisting}
DECLARE
    fecha_nacimiento DATE := TO_DATE('1990/01/01', 'YYYY/MM/DD');
BEGIN
    DBMS_OUTPUT.PUT_LINE('Fecha de nacimiento: ' || TO_CHAR(fecha_nacimiento, 'DD/MM/YYYY'));
END;
\end{lstlisting}
    \item \textbf{BOOLEAN}: se utiliza para almacenar valores de verdadero o falso.
\begin{lstlisting}
DECLARE
    es_mayor BOOLEAN := TRUE;
BEGIN
    IF es_mayor THEN
        DBMS_OUTPUT.PUT_LINE('Es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Es menor de edad');
    END IF;
END;
\end{lstlisting}
    \item \textbf{CHAR}: se utiliza para almacenar caracteres de longitud fija.
\begin{lstlisting}
DECLARE
    inicial CHAR(1) := 'A';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Inicial: ' || inicial);
END;    
\end{lstlisting}
    \item \textbf{LONG}: se utiliza para almacenar cadenas de longitud variable.
\begin{lstlisting}
DECLARE
    descripcion LONG := 'Esta es una descripcion larga';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Descripcion: ' || descripcion);
END;    
\end{lstlisting}
    \item \textbf{RAW}: se utiliza para almacenar datos binarios.
\begin{lstlisting}
DECLARE
    datos RAW(100) := UTL_RAW.CAST_TO_RAW('010101');
BEGIN
    DBMS_OUTPUT.PUT_LINE('Datos: ' || UTL_RAW.CAST_TO_VARCHAR2(datos));
END;    
\end{lstlisting}
    \item \textbf{BLOB}: se utiliza para almacenar datos binarios grandes.
\begin{lstlisting}
DECLARE
    es_mayor BOOLEAN := FALSE;
    edad INTEGER := 18;
BEGIN
    es_mayor := (edad >= 18);
    IF es_mayor THEN
        DBMS_OUTPUT.PUT_LINE('Es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Es menor de edad');
    END IF;
END;
\end{lstlisting}
    \item \textbf{CLOB}: se utiliza para almacenar cadenas de caracteres grandes.
\begin{lstlisting}
DECLARE
    descripcion CLOB := 'Esta es una descripcion larga';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Descripcion: ' || descripcion);
END;
\end{lstlisting}
    \item \textbf{TIMESTAMP}: se utiliza para almacenar fechas y horas con precisión de fracciones de segundo.
\begin{lstlisting}
DECLARE
    fecha_hora TIMESTAMP := SYSTIMESTAMP;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Fecha y hora: ' || TO_CHAR(fecha_hora, 'DD/MM/YYYY HH24:MI:SS.FF'));
\end{lstlisting}
    \item \textbf{INTERVAL}: se utiliza para almacenar intervalos de tiempo.
\begin{lstlisting}
DECLARE
    duracion INTERVAL DAY TO SECOND := INTERVAL '3' HOUR;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Duracion: ' || duracion);
END;
\end{lstlisting}
    \item \textbf{RECORD}: se utiliza para almacenar un conjunto de valores relacionados.
\begin{lstlisting}
DECLARE
    TYPE tipo_empleado IS RECORD (
        nombre VARCHAR2(50),
        edad NUMBER,
        sueldo NUMBER(10, 2)
    );

    empleado tipo_empleado;
BEGIN
    empleado.nombre := 'Juan';
    empleado.edad := 30;
    empleado.sueldo := 5000.50;

    DBMS_OUTPUT.PUT_LINE('Nombre: ' || empleado.nombre);
    DBMS_OUTPUT.PUT_LINE('Edad: ' || empleado.edad);
    DBMS_OUTPUT.PUT_LINE('Sueldo: ' || empleado.sueldo);
END;
\end{lstlisting}
    \item \textbf{TABLE}: se utiliza para almacenar conjuntos de datos en forma de tabla.
\begin{lstlisting}
DECLARE
    TYPE tipo_empleados IS TABLE OF VARCHAR2(50);
    empleados tipo_empleados := tipo_empleados('Juan', 'Maria', 'Pedro');
BEGIN
    FOR i IN 1..empleados.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Empleado ' || i || ': ' || empleados(i));
    END LOOP;
END;
\end{lstlisting}
\end{itemize}

\subsection{Strings}

En PL/SQL, los strings se representan utilizando el tipo de dato \texttt{VARCHAR2} o \texttt{CHAR}. Los strings son utilizados para almacenar y manipular datos textuales. A continuación se presentan algunos métodos y operaciones comunes para trabajar con strings en PL/SQL:

\paragraph{Declaración y asignación de strings}

Se pueden declarar variables de tipo string utilizando el tipo de dato \texttt{VARCHAR2}. Luego, se pueden asignar valores utilizando el operador de asignación \texttt{:=}. Por ejemplo:

\begin{lstlisting}
DECLARE
   nombre VARCHAR2(50);
   direccion VARCHAR2(100);
BEGIN
   nombre := 'Juan';
   direccion := 'Calle Principal';
   -- Resto del codigo...
END;
\end{lstlisting}

\paragraph{Concatenación de strings}

La concatenación de strings se puede realizar utilizando el operador de concatenación \texttt{||}. Por ejemplo:

\begin{lstlisting}
DECLARE
   nombre VARCHAR2(50) := 'Juan';
   apellido VARCHAR2(50) := 'Perez';
   nombre_completo VARCHAR2(100);
BEGIN
   nombre_completo := nombre || ' ' || apellido;
   dbms_output.put_line('Nombre completo: ' || nombre_completo);
   -- Resto del codigo...
END;
\end{lstlisting}

\paragraph{Funciones y operadores de manipulación de strings}

PL/SQL proporciona varias funciones y operadores para manipular strings. Aquí se presentan algunos ejemplos:

\begin{itemize}
    \item \texttt{SUBSTR(cadena, inicio, longitud)}: Retorna una subcadena de una cadena dada. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    subcadena VARCHAR2(20);
BEGIN
    subcadena := SUBSTR(cadena, 1, 5);
    dbms_output.put_line('Subcadena: ' || subcadena);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{LENGTH(cadena)}: Retorna la longitud de una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    longitud NUMBER;
BEGIN
    longitud := LENGTH(cadena);
    dbms_output.put_line('Longitud: ' || longitud);
    -- Resto del codigo...
END;
\end{lstlisting}

    \item \texttt{UPPER(cadena)}: Convierte una cadena a mayúsculas. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    cadena_mayusculas VARCHAR2(50);
BEGIN
    cadena_mayusculas := UPPER(cadena);
    dbms_output.put_line('Cadena en mayusculas: ' || cadena_mayusculas);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{LOWER(cadena)}: Convierte una cadena a minúsculas. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    cadena_minusculas VARCHAR2(50);
BEGIN
    cadena_minusculas := LOWER(cadena);
    dbms_output.put_line('Cadena en minusculas: ' || cadena_minusculas);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{INSTR(cadena, subcadena)}: Encuentra la posición de una subcadena dentro de una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    posicion NUMBER;
BEGIN
    posicion := INSTR(cadena, 'World');
    dbms_output.put_line('Posicion de "World": ' || posicion);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{REPLACE(cadena, subcadena, nueva\_subcadena)}: Reemplaza todas las ocurrencias de una subcadena por otra en una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    nueva_cadena VARCHAR2(50);
BEGIN
    nueva_cadena := REPLACE(cadena, 'World', 'Mundo');
    dbms_output.put_line('Cadena modificada: ' || nueva_cadena);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{TRIM(cadena)}, \texttt{LTRIM(cadena)}, \texttt{RTRIM(cadena)}: Estas funciones se utilizan para eliminar caracteres de una cadena, a la iquierda o derecha respectivamente. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := '   Hola, Mundo!   ';
    cadena_sin_espacios VARCHAR2(50);
BEGIN
    cadena_sin_espacios := TRIM(cadena);
    dbms_output.put_line('Cadena sin espacios: ' || cadena_sin_espacios);
    -- Resto del codigo...
END;
\end{lstlisting}
 \end{itemize}

\subsection{Condicionales y bucles}

En PL/SQL, los condicionales y los bucles son fundamentales para controlar el flujo de ejecución de un programa. Permiten tomar decisiones y repetir tareas de manera eficiente.

\subsubsection*{Condicionales}

En PL/SQL, se utiliza la estructura \texttt{IF-THEN-ELSE} para evaluar una condición y ejecutar diferentes bloques de código según el resultado. A continuación se muestra un ejemplo:

\begin{lstlisting}
DECLARE
   edad NUMBER := 18;
BEGIN
   IF edad >= 18 THEN
      dbms_output.put_line('Eres mayor de edad');
   ELSE
      dbms_output.put_line('Eres menor de edad');
   END IF;
END;
\end{lstlisting}

En este ejemplo, se evalúa la variable \texttt{edad} y se muestra un mensaje según el resultado.

\subsubsection*{Bucles}

En PL/SQL, los bucles permiten repetir tareas y controlar el flujo de ejecución. Veamos algunos tipos de bucles comunes:

\subsubsection*{Bucle LOOP}
El bucle \texttt{LOOP} es un bucle infinito que se repite hasta que se encuentra una instrucción de salida. Puedes utilizar la instrucción \texttt{EXIT} para salir del bucle. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   contador NUMBER := 1;
BEGIN
   LOOP
      dbms_output.put_line('Contador: ' || contador);
      contador := contador + 1;
      
      IF contador > 5 THEN
         EXIT; -- Sale del bucle
      END IF;
   END LOOP;
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{LOOP} para mostrar el valor del contador y se sale del bucle cuando el contador supera 5.

\subsubsection*{Bucle WHILE}
El bucle \texttt{WHILE} se repite mientras se cumpla una condición especificada. El bucle sigue ejecutándose siempre que la condición sea verdadera. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   contador NUMBER := 1;
BEGIN
   WHILE contador <= 5 LOOP
      dbms_output.put_line('Contador: ' || contador);
      contador := contador + 1;
   END LOOP;
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{WHILE} para mostrar el valor del contador y se repite mientras el contador sea menor o igual a 5.

\subsubsection*{Bucle FOR}
El bucle \texttt{FOR} se utiliza para recorrer un conjunto de valores en un rango o una lista. Puedes especificar un rango de valores utilizando \texttt{INICIO..FIN} o proporcionar una lista separada por comas de valores. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   total NUMBER := 0;
BEGIN
   FOR i IN 1..5 LOOP
      total := total + i;
   END LOOP;
   
   dbms_output.put_line('Total: ' || total);
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{FOR} para sumar los números del 1 al 5 y se muestra el resultado final.

La principal diferencia entre los bucles LOOP y WHILE radica en cómo se controla la condición de finalización: en el caso del bucle LOOP, se controla internamente dentro del bucle, mientras que en el bucle WHILE, se evalúa antes de cada iteración. El bucle FOR se utiliza específicamente para iterar sobre colecciones de elementos, como cursores o conjuntos de registros.

Es importante tener cuidado con los bucles que no paran. Si un bucle no tiene una instrucción de salida o una condición de finalización que se cumpla, se producirá lo que se conoce como un \enquote*{bucle infinito}. En ese caso, el bucle se ejecutará continuamente sin detenerse, lo que puede llevar a problemas como un uso excesivo de recursos del sistema y un bloqueo del programa. Los bucles infinitos son un error común en la programación y deben evitarse. Si accidentalmente creas un bucle infinito, es posible que debas detener la ejecución del programa manualmente o reiniciar el entorno de ejecución

\subsection{Condicionales y bucles anidados}

En PL/SQL, es posible anidar condicionales y bucles, lo que permite realizar estructuras de control más complejas y flexibles. A continuación, se presentan ejemplos prácticos de condicionales y bucles anidados:

\subsubsection*{Condicionales anidados}

Los condicionales anidados permiten evaluar múltiples condiciones y ejecutar diferentes bloques de código en función de los resultados. Aquí tienes un ejemplo que determina la calificación de un estudiante en base a su nota:

\begin{lstlisting}
DECLARE
   nota NUMBER := 85;
BEGIN
   IF nota >= 90 THEN
      dbms_output.put_line('Calificacion: A');
   ELSIF nota >= 80 THEN
      dbms_output.put_line('Calificacion: B');
   ELSIF nota >= 70 THEN
      dbms_output.put_line('Calificacion: C');
   ELSE
      dbms_output.put_line('Calificacion: D');
   END IF;
   -- Resto del codigo...
END;
/
\end{lstlisting}

En este ejemplo, se evalúa la nota del estudiante y se imprime la calificación correspondiente utilizando condicionales anidados.

\subsubsection*{Bucles anidados}

Los bucles anidados permiten iterar sobre múltiples conjuntos de datos. Aquí tienes un ejemplo de un bucle \texttt{FOR} anidado que genera una tabla de multiplicación:

\begin{lstlisting}
DECLARE
   limite_filas NUMBER := 5;
   limite_columnas NUMBER := 5;
BEGIN
   FOR i IN 1..limite_filas LOOP
      FOR j IN 1..limite_columnas LOOP
         dbms_output.put(i*j || ' ');
      END LOOP;
      dbms_output.new_line;
   END LOOP;
   -- Resto del codigo...
END;
/
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{FOR} anidado para generar una tabla de multiplicación con el límite de filas y columnas especificado.

Los condicionales y bucles anidados brindan flexibilidad para controlar el flujo de ejecución en situaciones más complejas. Puedes combinarlos y ajustarlos según tus necesidades para lograr la lógica deseada en tu programa.

Recuerda que estos son solo ejemplos básicos, y puedes adaptarlos y expandirlos según tus requerimientos específicos.


\subsection{Matrices}
Las matrices o arrays son estructuras de datos utilizadas para almacenar múltiples valores del mismo tipo en una sola variable. En PL/SQL, se pueden declarar y manipular matrices para procesar conjuntos de datos de manera eficiente. Las matrices se acceden mediante índices y se pueden utilizar en bucles y operaciones aritméticas.

\subsubsection{Ejemplo de declaración y uso de matrices:}
\begin{lstlisting}
DECLARE
    TYPE numeros_array IS VARRAY(5) OF NUMBER;
    numeros numeros_array := numeros_array(1, 2, 3, 4, 5);
BEGIN
    FOR i IN 1..numeros.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Numero en la posicion ' || i || ': ' || numeros(i));
    END LOOP;
END;
\end{lstlisting}

\section{Procedimientos almacenados}
Los procedimientos almacenados son una característica clave de PL/SQL. Son bloques de código con nombre que se almacenan en la base de datos y se utilizan para encapsular lógica de negocio compleja. Los procedimientos almacenados se pueden invocar desde otras partes del sistema, lo que permite una reutilización eficiente del código y mejora el rendimiento de las aplicaciones al reducir la necesidad de enviar múltiples consultas al servidor de base de datos.

\subsection{Ejemplo de procedimiento almacenado:}
\begin{lstlisting}
CREATE OR REPLACE PROCEDURE calcular_salario(p_empleado_id NUMBER) AS
v_salario NUMBER;
BEGIN
    -- Logica para calcular el salario del empleado
    -- y asignarlo a la variable v_salario
    -- ...

    DBMS_OUTPUT.PUT_LINE('El salario del empleado ' || p_empleado_id || ' es: ' || v_salario);
END;
\end{lstlisting}
\end{document}