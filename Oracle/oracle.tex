\documentclass[executivepaper]{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel} % Establece el idioma español
\usepackage{csquotes} % Carga el paquete csquotes
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[left=1.00cm, right=1.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}
\setlength{\parindent}{0.5in}
\usepackage{setspace}
\doublespacing

% Define colores para el código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{mycolor}{RGB}{0,0,255}
% Configuración de lstlisting
\lstset{
    inputencoding=utf8,
    language=SQL,
    basicstyle=\ttfamily,
    columns=fullflexible,
    backgroundcolor=\color{backcolour},     
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{cyan!60!black},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    morekeywords={DECLARE,
                    BEGIN,
                    END,
                    PACKAGE,
                    IS,
                    BODY,
                    FUNCTION,
                    PROCEDURE,
                    RETURN,
                    LOOP,
                    IF,
                    FOR,
                    WHILE,
                    EXIT,
                    SUBSTR,
                    LENGTH,
                    UPPER,
                    LOWER,
                    INSTR,
                    REPLACE,
                    TRIM,
                    SERVEROUTPUT,
                    AFTER,
                    BEFORE,
                    REFERENCES},
}

% Configuración del paquete hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=gray,
}

\title{PL/SQL}
\author{Kevin Cárdenas}

\begin{document}

\begin{titlepage}
    \begin{center}
        {\Huge \textbf{PL/SQL}}
        \\[18cm]

        \large\emph{Autor:}\\
        Kevin Cárdenas.
        \\[1cm]
        {\large 2023}
    \end{center}
\end{titlepage}
\newpage
\tableofcontents
\newpage

\section{SQL}

SQL (Structured Query Language) es un lenguaje de programación utilizado para administrar y manipular bases de datos relacionales. Es el estándar de facto para interactuar con sistemas de gestión de bases de datos (DBMS) y permite realizar diversas operaciones, como consultas, inserciones, actualizaciones y eliminaciones de datos.

SQL proporciona un conjunto de comandos y sintaxis específicos que permiten interactuar con una base de datos relacional. Estos comandos se dividen en diferentes categorías, entre las que destacan:

\begin{itemize}
\item Consultas (Queries): Permite extraer información de la base de datos mediante la especificación de condiciones y criterios de búsqueda.
\item Inserciones (Inserts): Permite agregar nuevos registros a una tabla de la base de datos.
\item Actualizaciones (Updates): Permite modificar los valores de los registros existentes en una tabla.
\item Eliminaciones (Deletes): Permite eliminar registros de una tabla.
\item Uniones (Joins): Permite combinar datos de múltiples tablas basándose en una condición de unión.
\item Agrupaciones (Group By): Permite agrupar los registros de una tabla según un criterio específico y realizar cálculos agregados.
\item Ordenamiento (Order By): Permite ordenar los registros de una tabla según uno o más atributos.
\end{itemize}

Las consultas (queries) son una parte fundamental de SQL y se utilizan para recuperar información específica de una base de datos. Mediante las consultas, se pueden especificar condiciones de búsqueda, filtros y criterios de ordenamiento para obtener los datos deseados.

\subsection{Keys}

En el contexto de las bases de datos, una base de datos relacional es un conjunto de tablas que están interrelacionadas mediante keys (claves). Las keys desempeñan un papel fundamental en el diseño y la estructura de una base de datos relacional, ya que se utilizan para identificar y relacionar los registros almacenados en las tablas.

Una base de datos relacional se organiza en tablas que contienen filas (registros) y columnas (atributos). Cada registro en una tabla se identifica de forma única mediante una key, que puede ser un atributo o un conjunto de atributos. Las keys permiten establecer relaciones entre las tablas y garantizan la integridad de los datos.

En una base de datos relacional, las keys se utilizan para garantizar la unicidad de los registros y establecer relaciones entre las tablas.

\subsubsection*{Primary Key}

Una clave primaria (\textit{Primary Key}) es un atributo o conjunto de atributos que identifica de forma única cada registro en una tabla. Es utilizada para garantizar la integridad y unicidad de los datos. Cada tabla en una base de datos relacional debe tener una clave primaria.

Ejemplo de declaración de una clave primaria en SQL:

\begin{lstlisting}
CREATE TABLE empleados (
empleado_id INT PRIMARY KEY,
nombre VARCHAR(50),
apellido VARCHAR(50),
...
);
\end{lstlisting}

En este ejemplo, la columna \texttt{empleado\_id} se declara como la clave primaria de la tabla \texttt{empleados}.

\subsubsection*{Foreign Key}

Una clave foránea (\textit{Foreign Key}) es un atributo o conjunto de atributos que establece una relación entre dos tablas en una base de datos relacional. La clave foránea hace referencia a la clave primaria de otra tabla y se utiliza para mantener la integridad referencial entre las tablas.

Ejemplo de declaración de una clave foránea en SQL:

\begin{lstlisting}
CREATE TABLE ventas (
venta_id INT PRIMARY KEY,
empleado_id INT,
...
FOREIGN KEY (empleado_id) REFERENCES empleados(empleado_id)
);
\end{lstlisting}

En este ejemplo, la columna \texttt{empleado\_id} en la tabla \texttt{ventas} se declara como una clave foránea que hace referencia a la clave primaria \texttt{empleado\_id} en la tabla \texttt{empleados}.

Demos más ejemplos:

\subsubsection*{Primary Key}

Ejemplo 1: Tabla de estudiantes con clave primaria compuesta:
\begin{lstlisting}
CREATE TABLE estudiantes (
estudiante_id INT,
curso_id INT,
nombre VARCHAR(50),
PRIMARY KEY (estudiante_id, curso_id)
);
\end{lstlisting}

\subsubsection*{Foreign Key}

Ejemplo 1: Tabla de órdenes de compra con clave foránea:
\begin{lstlisting}
CREATE TABLE ordenes (
orden_id INT PRIMARY KEY,
cliente_id INT,
fecha DATE,
FOREIGN KEY (cliente_id) REFERENCES clientes(cliente_id)
);
\end{lstlisting}

Ejemplo 2: Tabla de empleados con clave foránea a sí misma (jerarquía de empleados):
\begin{lstlisting}
CREATE TABLE empleados (
empleado_id INT PRIMARY KEY,
nombre VARCHAR(50),
jefe_id INT,
FOREIGN KEY (jefe_id) REFERENCES empleados(empleado_id)
);
\end{lstlisting}

\subsection{Tipo de Relaciones}

En SQL, se pueden establecer diferentes tipos de relaciones entre tablas en una base de datos relacional. Algunos de los tipos de relaciones comunes son:

\begin{itemize}
\item Relación uno a uno (One-to-One): En esta relación, cada registro en la tabla A está asociado con un único registro en la tabla B, y viceversa. Esto significa que la clave primaria de una tabla se relaciona directamente con la clave primaria de otra tabla. Por ejemplo, en una base de datos de empleados, se puede tener una tabla \enquote*{Empleados} y una tabla \enquote*{DetallesEmpleados}, donde cada registro en la tabla \enquote*{Empleados} tiene una correspondencia única en la tabla \enquote*{DetallesEmpleados}.

\item Relación uno a muchos (One-to-Many): En esta relación, cada registro en la tabla A puede estar asociado con varios registros en la tabla B, pero cada registro en la tabla B está asociado con un único registro en la tabla A. Esto se logra mediante el uso de una clave primaria en la tabla A que se convierte en una clave foránea en la tabla B. Por ejemplo, en una base de datos de clientes y pedidos, se puede tener una tabla \enquote*{Clientes} y una tabla \enquote*{Pedidos}, donde cada cliente puede realizar varios pedidos, pero cada pedido está asociado a un único cliente.

\item Relación muchos a muchos (Many-to-Many): En esta relación, varios registros en la tabla A pueden estar asociados con varios registros en la tabla B mediante una tabla intermedia. Esta tabla intermedia contiene las claves primarias de ambas tablas como claves foráneas. Por ejemplo, en una base de datos de estudiantes y cursos, se puede tener una tabla \enquote*{Estudiantes}, una tabla \enquote*{Cursos} y una tabla intermedia \enquote*{Inscripciones}, donde varios estudiantes pueden estar inscritos en varios cursos.

\end{itemize}

Establecer y mantener estas relaciones es fundamental para mantener la integridad y coherencia de los datos en una base de datos relacional. Las claves primarias y foráneas se utilizan para establecer estas relaciones y asegurar que los registros estén correctamente relacionados entre sí.

A continuación, se presentan ejemplos de tablas que ilustran los diferentes tipos de relaciones:

\subsubsection*{Relación uno a uno (One-to-One)}
Tabla \enquote*{Empleados}:
\begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{ID} & \textbf{Nombre} & \textbf{Apellido} \\
    \hline
    1 & John & Doe \\
    \hline
    2 & Jane & Smith \\
    \hline
    \end{tabular}
    \end{center}

Tabla \enquote*{DetallesEmpleados}:
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID} & \textbf{Salario} \\
    \hline
    1 & 5000 \\
    \hline
    2 & 6000 \\
    \hline
\end{tabular}
\end{center}

\subsubsection*{Relación uno a muchos (One-to-Many)}
Tabla \enquote*{Clientes}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID} & \textbf{Nombre} & \textbf{Apellido} \\
    \hline
    1 & John & Doe \\
    \hline
    2 & Jane & Smith \\
    \hline
\end{tabular}
\end{center}

Tabla \enquote*{Pedidos}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID} & \textbf{ClienteID} & \textbf{Producto} \\
\hline
1 & 1 & Laptop \\
\hline
2 & 1 & Teléfono \\
\hline
3 & 2 & Tablet \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Relación muchos a muchos (Many-to-Many)}
Tabla \enquote*{Estudiantes}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID} & \textbf{Nombre} & \textbf{Apellido} \\
\hline
1 & John & Doe \\
\hline
2 & Jane & Smith \\
\hline
\end{tabular}
\end{center}

Tabla \enquote*{Cursos}:
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID} & \textbf{Nombre} \\
\hline
1 & Matemáticas \\
\hline
2 & Historia \\
\hline
\end{tabular}
\end{center}

Tabla \enquote*{Inscripciones}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{EstudianteID} & \textbf{CursoID} & \textbf{FechaInscripción} \\
\hline
1 & 1 & 2022-01-01 \\
\hline
1 & 2 & 2022-02-01 \\
\hline
2 & 1 & 2022-03-01 \\
\hline
\end{tabular}
\end{center}

\subsection{Normalización de una Base de Datos}

La normalización es un proceso utilizado para organizar y diseñar estructuras de bases de datos relacionales de manera eficiente y sin redundancias innecesarias. Se basa en una serie de reglas (formas normales) que ayudan a eliminar la redundancia y mejorar la integridad de los datos.

Algunas de las formas normales comunes son:

\subsubsection*{Primera Forma Normal (1NF)}

Requiere que los valores de cada columna en una tabla sean atómicos (indivisibles) y no se repitan. Esto implica dividir una tabla en múltiples tablas más pequeñas y relacionadas, donde cada tabla representa una entidad única. Por ejemplo, consideremos una tabla de empleados donde cada empleado tiene un único ID, nombre y apellido. La 1NF se aseguraría de que cada columna contenga información atómica y que no haya duplicados.

Por ejemplo:

Consideremos una tabla de empleados que contiene información sobre los empleados de una empresa:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{ID} & \textbf{Nombre} & \textbf{Apellido} & \textbf{Departamento} \\
\hline
1 & John & Doe & Ventas \\
\hline
2 & Jane & Smith & Finanzas \\
\hline
3 & Mark & Johnson & Ventas \\
\hline
\end{tabular}
\end{center}

En este ejemplo, la tabla no cumple con la primera forma normal (1NF) porque la columna \enquote*{Departamento} contiene información repetida. Para aplicar la 1NF, podemos dividir la tabla en dos:

\textbf{Tabla Empleados:}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID} & \textbf{Nombre} & \textbf{Apellido} \\
\hline
1 & John & Doe \\
\hline
2 & Jane & Smith \\
\hline
3 & Mark & Johnson \\
\hline
\end{tabular}
\end{center}

\textbf{Tabla Departamentos:}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID} & \textbf{Departamento} \\
\hline
1 & Ventas \\
\hline
2 & Finanzas \\
\hline
\end{tabular}
\end{center}

Ahora, cada tabla contiene información única y no hay redundancia en los datos.

\subsubsection*{Segunda Forma Normal (2NF)}

Requiere que la tabla esté en 1NF y que todos los atributos no clave dependan completamente de la clave primaria. En otras palabras, no debe haber dependencias parciales. Esto implica dividir la tabla en múltiples tablas para evitar redundancias y asegurarse de que cada atributo dependa completamente de la clave primaria. Por ejemplo, si tenemos una tabla de ventas donde la clave primaria es una combinación de ID de venta y ID de producto, y tenemos atributos como nombre del producto y precio, la 2NF se aseguraría de que el nombre del producto y el precio dependan completamente de la clave primaria.

Por ejemplo:

Supongamos que tenemos una tabla de pedidos que registra los pedidos realizados por los clientes:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{ID Pedido} & \textbf{ID Cliente} & \textbf{Nombre Cliente} & \textbf{Dirección} \\
\hline
1 & 1001 & John Doe & Calle Principal 123 \\
\hline
2 & 1002 & Jane Smith & Calle Secundaria 456 \\
\hline
\end{tabular}
\end{center}

En este ejemplo, la tabla no cumple con la segunda forma normal (2NF) porque el nombre del cliente y la dirección dependen de la clave primaria \enquote*{ID Cliente} y no de la clave primaria \enquote*{ID Pedido}. Para aplicar la 2NF, podemos dividir la tabla en dos:

\textbf{Tabla Pedidos:}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID Pedido} & \textbf{ID Cliente} \\
\hline
1 & 1001 \\
\hline
2 & 1002 \\
\hline
\end{tabular}
\end{center}

\textbf{Tabla Clientes:}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID Cliente} & \textbf{Nombre Cliente} & \textbf{Dirección} \\
\hline
1001 & John Doe & Calle Principal 123 \\
\hline
1002 & Jane Smith & Calle Secundaria 456 \\
\hline
\end{tabular}
\end{center}

Ahora, el nombre del cliente y la dirección dependen completamente del ID del cliente, evitando así la redundancia de datos.

\subsubsection*{Tercera Forma Normal (3NF)}

Requiere que la tabla esté en 2NF y que no haya dependencias transitivas, es decir, ningún atributo no clave depende de otro atributo no clave. Esto implica dividir la tabla en múltiples tablas para evitar dependencias transitivas y asegurarse de que cada atributo dependa únicamente de la clave primaria. Por ejemplo, si tenemos una tabla de pedidos donde la clave primaria es el ID del pedido y tenemos atributos como dirección de envío y ciudad, y además tenemos un atributo de código postal que depende de la ciudad, la 3NF se aseguraría de que el atributo de código postal se mueva a una tabla separada que solo contenga información relacionada con las ciudades.

Veamos un ejemplo para ilustrar la Tercera Forma Normal (3NF):

Supongamos que tenemos una tabla de pedidos donde la clave primaria es el ID del pedido. Además, tenemos atributos como dirección de envío, ciudad y código postal. Para cumplir con la 3NF, debemos asegurarnos de que ningún atributo no clave dependa de otro atributo no clave. En este caso, el atributo de código postal depende de la ciudad, lo cual genera una dependencia transitiva. Para resolver esto, podemos dividir la tabla en dos:

\textbf{Tabla Pedidos:}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID Pedido} & \textbf{Dirección de envío} & \textbf{ID Ciudad} \\
\hline
1 & Calle Principal 123 & 1 \\
\hline
2 & Calle Secundaria 456 & 2 \\
\hline
\end{tabular}
\end{center}

\textbf{Tabla Ciudades:}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID Ciudad} & \textbf{Ciudad} & \textbf{Código Postal} \\
\hline
1 & Ciudad A & 12345 \\
\hline
2 & Ciudad B & 67890 \\
\hline
\end{tabular}
\end{center}

En este ejemplo, hemos separado el atributo de código postal en una tabla separada llamada\enquote*{Ciudades}. Ahora, la tabla de pedidos solo contiene información relacionada con los pedidos, mientras que la tabla de ciudades contiene información relacionada con las ciudades y sus códigos postales. Esto cumple con la Tercera Forma Normal (3NF) al eliminar la dependencia transitiva y asegurarnos de que cada atributo dependa únicamente de la clave primaria correspondiente.

\subsubsection*{Cuarta Forma Normal (4NF)}

La Cuarta Forma Normal (4NF) se refiere a una forma de normalización más avanzada que aborda la redundancia causada por dependencias multivaluadas en una base de datos relacional.

En la 4NF, se busca eliminar las dependencias multivaluadas, es decir, las dependencias en las que un conjunto de atributos determina múltiples conjuntos de valores para otros atributos.

Un ejemplo sencillo de la 4NF es el siguiente:

Consideremos una tabla \enquote*{Productos} con los siguientes atributos:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID Producto} & \textbf{Nombre Producto} & \textbf{Categorías} \\
\hline
1 & Laptop & Electrónica, Informática \\
\hline
2 & Televisor & Electrónica, Hogar \\
\hline
\end{tabular}
\end{center}

En este ejemplo, la columna \enquote*{Categorías} es multivaluada, lo que significa que un producto puede tener múltiples categorías asociadas. Para aplicar la 4NF, podemos crear una nueva tabla \enquote*{Categorías} y utilizar una clave foránea para establecer la relación:

\textbf{Tabla Productos:}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID Producto} & \textbf{Nombre Producto} \\
\hline
1 & Laptop \\
\hline
2 & Televisor \\
\hline
\end{tabular}
\end{center}

\textbf{Tabla Categorías:}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID Producto} & \textbf{Categoría} \\
\hline
1 & Electrónica \\
\hline
1 & Informática \\
\hline
2 & Electrónica \\
\hline
2 & Hogar \\
\hline
\end{tabular}
\end{center}

De esta manera, hemos eliminado la redundancia en la columna \enquote*{Categorías} y hemos establecido una relación adecuada entre los productos y sus categorías.

\subsubsection*{Quinta Forma Normal (5NF)}

La Quinta Forma Normal (5NF) es una forma de normalización aún más avanzada que aborda las dependencias de unión, también conocidas como dependencias de proyección y unión.

En la 5NF, se busca eliminar las dependencias de unión al descomponer las relaciones en tablas más pequeñas y más especializadas.

Un ejemplo de la 5NF es el siguiente:

Consideremos una tabla \enquote*{Pedidos} con los siguientes atributos:

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID Pedido} & \textbf{Productos} \\
\hline
1 & Laptop, Televisor \\
\hline
2 & Teléfono, Tablet \\
\hline
\end{tabular}
\end{center}

En este ejemplo, la columna \enquote*{Productos} tiene una dependencia de unión, ya que contiene múltiples valores separados por comas. Para aplicar la 5NF, podemos crear una nueva tabla \enquote*{ProductosPedidos} para representar las relaciones entre los productos y los pedidos:

\textbf{Tabla Pedidos:}
\begin{center}
\begin{tabular}{|c|}
\hline
\textbf{ID Pedido} \\
\hline
1 \\
\hline
2 \\
\hline
\end{tabular}
\end{center}

\textbf{Tabla ProductosPedidos:}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{ID Pedido} & \textbf{Producto} \\
\hline
1 & Laptop \\
\hline
1 & Televisor \\
\hline
2 & Teléfono \\
\hline
2 & Tablet \\
\hline
\end{tabular}
\end{center}

De esta manera, hemos eliminado la dependencia de unión en la columna \enquote*{Productos} y hemos descompuesto la relación en dos tablas más especializadas.

La Cuarta Forma Normal (4NF) y la Quinta Forma Normal (5NF) son formas normales más avanzadas que se utilizan para abordar situaciones más complejas y garantizar una mayor eficiencia y estructura en las bases de datos relacionales.

\subsection{Tipos de Operaciones en una Sentencia SQL}

SQL admite una amplia gama de operaciones para interactuar con una base de datos. Algunas de las operaciones más comunes en SQL son:

\begin{itemize}
\item SELECT: Utilizado para recuperar datos de una o varias tablas.
\item INSERT: Utilizado para insertar nuevos registros en una tabla.
\item UPDATE: Utilizado para actualizar registros existentes en una tabla.
\item DELETE: Utilizado para eliminar registros de una tabla.
\item JOIN: Utilizado para combinar datos de dos o más tablas basándose en una condición de unión.
\item GROUP BY: Utilizado para agrupar filas según un criterio y realizar cálculos agregados en los grupos resultantes.
\item ORDER BY: Utilizado para ordenar los resultados de una consulta según uno o más atributos.
\end{itemize}

\subsubsection*{SELECT}

La operación SELECT se utiliza para recuperar datos de una o varias tablas en una base de datos. Permite especificar qué columnas se desean seleccionar, así como aplicar condiciones y criterios de filtrado para obtener resultados más específicos.

Un ejemplo de uso de la operación SELECT sería:

\begin{lstlisting}
SELECT nombre, apellido FROM empleados WHERE edad > 30;
\end{lstlisting}

Esta consulta selecciona los nombres y apellidos de los empleados cuya edad es mayor a 30.

\subsubsection*{INSERT}

La operación INSERT se utiliza para insertar nuevos registros en una tabla. Permite especificar los valores a ser insertados en cada columna de la tabla.

Un ejemplo de uso de la operación INSERT sería:

\begin{lstlisting}
INSERT INTO clientes (nombre, apellido, correo) VALUES ('Juan', 'Perez', 'juan@example.com');
\end{lstlisting}

Esta consulta inserta un nuevo cliente en la tabla \enquote*{clientes} con los valores especificados para nombre, apellido y correo.

\subsubsection*{UPDATE}

La operación UPDATE se utiliza para actualizar registros existentes en una tabla. Permite modificar los valores de una o varias columnas en base a una condición.

Un ejemplo de uso de la operación UPDATE sería:

\begin{lstlisting}
UPDATE productos SET precio = 10.99 WHERE categoria = 'Electronica';
\end{lstlisting}

Esta consulta actualiza el precio de todos los productos de la categoría 'Electrónica' a 10.99.

\subsubsection*{DELETE}

La operación DELETE se utiliza para eliminar registros de una tabla. Permite especificar una condición para determinar qué registros deben ser eliminados.

Un ejemplo de uso de la operación DELETE sería:

\begin{lstlisting}
DELETE FROM pedidos WHERE fecha < '2022-01-01';
\end{lstlisting}

Esta consulta elimina todos los pedidos cuya fecha sea anterior al 1 de enero de 2022.

\subsubsection*{JOIN}

La operación JOIN se utiliza para combinar datos de dos o más tablas en base a una condición de unión. Permite obtener resultados que relacionen registros de diferentes tablas.

Un ejemplo de uso de la operación JOIN sería:

\begin{lstlisting}
SELECT empleados.nombre, departamentos.nombre
FROM empleados
JOIN departamentos ON empleados.departamento_id = departamentos.id;
\end{lstlisting}

Esta consulta combina los datos de las tablas \enquote*{empleados} y \enquote*{departamentos} utilizando la condición de unión \enquote*{empleados.departamento\_id = departamentos.id}, y selecciona los nombres de los empleados junto con los nombres de los departamentos a los que pertenecen.

\subsubsection*{GROUP BY}

La operación GROUP BY se utiliza para agrupar filas según un criterio y realizar cálculos agregados en los grupos resultantes. Permite obtener resultados resumidos y estadísticas sobre los datos de una tabla.

Un ejemplo de uso de la operación GROUP BY sería:

\begin{lstlisting}
SELECT categoria, COUNT(*) as total_productos
FROM productos
GROUP BY categoria;
\end{lstlisting}

Esta consulta agrupa los productos por categoría y cuenta cuántos productos hay en cada categoría, mostrando el resultado en la columna \enquote*{total\_productos}.

\subsubsection*{ORDER BY}

La operación ORDER BY se utiliza para ordenar los resultados de una consulta según uno o más atributos. Permite especificar el orden ascendente (ASC) o descendente (DESC) de los resultados.

Un ejemplo de uso de la operación ORDER BY sería:

\begin{lstlisting}
SELECT nombre, precio
FROM productos
ORDER BY precio DESC;
\end{lstlisting}

Esta consulta selecciona los nombres y precios de los productos y los ordena de forma descendente según el precio.

\newpage

\section{PL/SQL}
PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programación procedural desarrollado por Oracle Corporation para su uso con el sistema de gestión de bases de datos Oracle. Fue creado en la década de 1990 como una extensión del lenguaje SQL estándar, con el objetivo de proporcionar capacidades avanzadas de programación y lógica empresarial en el contexto de una base de datos relacional.

PL/SQL combina elementos de lenguajes de programación procedurales tradicionales, como variables, estructuras de control de flujo y subrutinas, con la potencia del lenguaje SQL para interactuar con la base de datos. Esto permite a los desarrolladores crear aplicaciones más complejas y sofisticadas que pueden aprovechar todas las capacidades de una base de datos relacional.

Una de las principales ventajas de PL/SQL es su estrecha integración con Oracle Database. Los programas PL/SQL se ejecutan directamente en el servidor de la base de datos, lo que reduce la necesidad de enviar múltiples consultas desde una aplicación cliente y minimiza la cantidad de datos transferidos a través de la red. Esto mejora significativamente el rendimiento y la eficiencia de las aplicaciones, especialmente en entornos empresariales donde el acceso a la base de datos es fundamental.

PL/SQL se utiliza ampliamente para desarrollar funciones, procedimientos almacenados, desencadenadores (triggers) y paquetes, que encapsulan la lógica de negocio y proporcionan una capa de abstracción adicional sobre los datos almacenados en la base de datos. Estas construcciones permiten una mejor organización y modularidad del código, promoviendo la reutilización y el mantenimiento eficiente de la lógica empresarial.

\subsection{Bloques de PL/SQL}
Un bloque de PL/SQL es una unidad básica de código en PL/SQL. Puede contener declaraciones, sentencias SQL y lógica de programación. Los bloques de PL/SQL se utilizan para encapsular la lógica de negocio y pueden ser anónimos o nombrados.

Los bloques anónimos se ejecutan de forma inmediata, mientras que los bloques nombrados se almacenan en la base de datos y se pueden invocar desde otras partes del sistema.

A continuación, se muestra un ejemplo de un bloque de PL/SQL anónimo:

\begin{lstlisting}
SET SERVEROUTPUT ON --Imprimir mensajes en consola

DECLARE
    nombre VARCHAR2(50) := 'Juan';
    edad NUMBER := 30;
BEGIN
    -- Logic of program
    IF edad >= 18 THEN
        DBMS_OUTPUT.PUT_LINE(nombre || ' es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE(nombre || ' es menor de edad');
    END IF;
END;

-- Sentencias SQL
INSERT INTO empleados (nombre, salario)
    VALUES ('Ana', 5000);

COMMIT;
END;
/
\end{lstlisting}

En este ejemplo, el bloque de PL/SQL anónimo comienza con la palabra clave \enquote*{BEGIN} y finaliza con \enquote*{/} para indicar el final del bloque. Dentro del bloque, se pueden realizar declaraciones como la declaración de variables y constantes. Además, se puede incluir lógica de programación como condicionales y sentencias SQL para manipular la base de datos.

Por otro lado, los bloques de PL/SQL nombrados se almacenan en la base de datos y se pueden invocar desde otras partes del sistema. A continuación se muestra un ejemplo de un procedimiento almacenado, que es un tipo de bloque de PL/SQL nombrado:

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE calcular_salario(p_empleado_id NUMBER) AS
v_salario NUMBER;
BEGIN
    -- Logica para calcular el salario del empleado
    SELECT salario INTO v_salario
        FROM empleados
        WHERE empleado_id = p_empleado_id;

    DBMS_OUTPUT.PUT_LINE('El salario del empleado ' || p_empleado_id || ' es: ' || v_salario);
END;
/
\end{lstlisting}

En este ejemplo, se crea un procedimiento almacenado llamado \enquote*{calcular\_salario} que acepta un parámetro de empleado\_id. Dentro del procedimiento, se realiza una consulta para obtener el salario del empleado correspondiente al empleado\_id proporcionado. Luego, se muestra el salario utilizando la función DBMS\_OUTPUT.PUT\_LINE.

Además de los bloques anónimos y los procedimientos almacenados, PL/SQL también ofrece la posibilidad de crear disparadores (triggers). Los disparadores son bloques de PL/SQL que se ejecutan automáticamente en respuesta a eventos específicos que ocurren en la base de datos, como la inserción, actualización o eliminación de datos en una tabla.

A continuación se muestra un ejemplo de un disparador (trigger) que se activa después de insertar una nueva fila en la tabla \enquote*{empleados}:

\begin{lstlisting}
CREATE OR REPLACE TRIGGER insertar_empleado_trigger
AFTER INSERT ON empleados
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Nuevo empleado insertado: ' || :NEW.nombre);
END;
/
\end{lstlisting}

En este ejemplo, el disparador \enquote*{insertar\_empleado\_trigger} se ejecuta después de cada inserción en la tabla \enquote*{empleados}. El bloque de PL/SQL dentro del disparador muestra un mensaje que indica el nombre del nuevo empleado que se ha insertado.

Los disparadores son una poderosa herramienta en PL/SQL que permiten automatizar acciones y aplicar lógica adicional en la base de datos en respuesta a eventos específicos.

\subsection{Variables y constantes}
En PL/SQL, se pueden declarar variables y constantes para almacenar y manipular datos. Las variables se utilizan para almacenar valores temporales y pueden cambiar durante la ejecución del programa. Las constantes, por otro lado, son valores fijos que no pueden modificarse una vez que se les ha asignado un valor. Tanto las variables como las constantes pueden tener diferentes tipos de datos, como enteros, caracteres, fechas, etc.

Algunos de los tipos de datos más comunes en PL/SQL. Cada tipo de dato tiene características específicas y se debe elegir según el tipo de datos que se desea almacenar y manipular en la base de datos.

\begin{itemize}
    \item \textbf{VARCHAR2}: se utiliza para almacenar cadenas de caracteres.
\begin{lstlisting}
DECLARE
    nombre VARCHAR2(50) := 'Juan';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Nombre: ' || nombre);
END;    
\end{lstlisting}
    \item \textbf{NUMBER}: se utiliza para almacenar números enteros o decimales.
\begin{lstlisting}
DECLARE
    sueldo NUMBER(10, 2) := 5000.50;
    extras NUMBER(10, 2) := 200.50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Saldo: ' || TO_CHAR(sueldo + extras));
END;
\end{lstlisting}
    \item \textbf{DATE}: se utiliza para almacenar fechas y horas.
\begin{lstlisting}
DECLARE
    fecha_nacimiento DATE := TO_DATE('1990/01/01', 'YYYY/MM/DD');
BEGIN
    DBMS_OUTPUT.PUT_LINE('Fecha de nacimiento: ' || TO_CHAR(fecha_nacimiento, 'DD/MM/YYYY'));
END;
\end{lstlisting}
    \item \textbf{BOOLEAN}: se utiliza para almacenar valores de verdadero o falso.
\begin{lstlisting}
DECLARE
    es_mayor BOOLEAN := TRUE;
BEGIN
    IF es_mayor THEN
        DBMS_OUTPUT.PUT_LINE('Es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Es menor de edad');
    END IF;
END;
\end{lstlisting}
    \item \textbf{CHAR}: se utiliza para almacenar caracteres de longitud fija.
\begin{lstlisting}
DECLARE
    inicial CHAR(1) := 'A';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Inicial: ' || inicial);
END;    
\end{lstlisting}
    \item \textbf{LONG}: se utiliza para almacenar cadenas de longitud variable.
\begin{lstlisting}
DECLARE
    descripcion LONG := 'Esta es una descripcion larga';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Descripcion: ' || descripcion);
END;    
\end{lstlisting}
    \item \textbf{RAW}: se utiliza para almacenar datos binarios.
\begin{lstlisting}
DECLARE
    datos RAW(100) := UTL_RAW.CAST_TO_RAW('010101');
BEGIN
    DBMS_OUTPUT.PUT_LINE('Datos: ' || UTL_RAW.CAST_TO_VARCHAR2(datos));
END;    
\end{lstlisting}
    \item \textbf{BLOB}: se utiliza para almacenar datos binarios grandes.
\begin{lstlisting}
DECLARE
    es_mayor BOOLEAN := FALSE;
    edad INTEGER := 18;
BEGIN
    es_mayor := (edad >= 18);
    IF es_mayor THEN
        DBMS_OUTPUT.PUT_LINE('Es mayor de edad');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Es menor de edad');
    END IF;
END;
\end{lstlisting}
    \item \textbf{CLOB}: se utiliza para almacenar cadenas de caracteres grandes.
\begin{lstlisting}
DECLARE
    descripcion CLOB := 'Esta es una descripcion larga';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Descripcion: ' || descripcion);
END;
\end{lstlisting}
    \item \textbf{TIMESTAMP}: se utiliza para almacenar fechas y horas con precisión de fracciones de segundo.
\begin{lstlisting}
DECLARE
    fecha_hora TIMESTAMP := SYSTIMESTAMP;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Fecha y hora: ' || TO_CHAR(fecha_hora, 'DD/MM/YYYY HH24:MI:SS.FF'));
\end{lstlisting}
    \item \textbf{INTERVAL}: se utiliza para almacenar intervalos de tiempo.
\begin{lstlisting}
DECLARE
    duracion INTERVAL DAY TO SECOND := INTERVAL '3' HOUR;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Duracion: ' || duracion);
END;
\end{lstlisting}
    \item \textbf{RECORD}: se utiliza para almacenar un conjunto de valores relacionados.
\begin{lstlisting}
DECLARE
    TYPE tipo_empleado IS RECORD (
        nombre VARCHAR2(50),
        edad NUMBER,
        sueldo NUMBER(10, 2)
    );

    empleado tipo_empleado;
BEGIN
    empleado.nombre := 'Juan';
    empleado.edad := 30;
    empleado.sueldo := 5000.50;

    DBMS_OUTPUT.PUT_LINE('Nombre: ' || empleado.nombre);
    DBMS_OUTPUT.PUT_LINE('Edad: ' || empleado.edad);
    DBMS_OUTPUT.PUT_LINE('Sueldo: ' || empleado.sueldo);
END;
\end{lstlisting}
    \item \textbf{TABLE}: se utiliza para almacenar conjuntos de datos en forma de tabla.
\begin{lstlisting}
DECLARE
    TYPE tipo_empleados IS TABLE OF VARCHAR2(50);
    empleados tipo_empleados := tipo_empleados('Juan', 'Maria', 'Pedro');
BEGIN
    FOR i IN 1..empleados.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Empleado ' || i || ': ' || empleados(i));
    END LOOP;
END;
\end{lstlisting}
\end{itemize}

\subsection{Strings}

En PL/SQL, los strings se representan utilizando el tipo de dato \texttt{VARCHAR2} o \texttt{CHAR}. Los strings son utilizados para almacenar y manipular datos textuales. A continuación se presentan algunos métodos y operaciones comunes para trabajar con strings en PL/SQL:

\paragraph{Declaración y asignación de strings}

Se pueden declarar variables de tipo string utilizando el tipo de dato \texttt{VARCHAR2}. Luego, se pueden asignar valores utilizando el operador de asignación \texttt{:=}. Por ejemplo:

\begin{lstlisting}
DECLARE
   nombre VARCHAR2(50);
   direccion VARCHAR2(100);
BEGIN
   nombre := 'Juan';
   direccion := 'Calle Principal';
   -- Resto del codigo...
END;
\end{lstlisting}

\paragraph{Concatenación de strings}

La concatenación de strings se puede realizar utilizando el operador de concatenación \texttt{||}. Por ejemplo:

\begin{lstlisting}
DECLARE
   nombre VARCHAR2(50) := 'Juan';
   apellido VARCHAR2(50) := 'Perez';
   nombre_completo VARCHAR2(100);
BEGIN
   nombre_completo := nombre || ' ' || apellido;
   dbms_output.put_line('Nombre completo: ' || nombre_completo);
   -- Resto del codigo...
END;
\end{lstlisting}

\paragraph{Funciones y operadores de manipulación de strings}

PL/SQL proporciona varias funciones y operadores para manipular strings. Aquí se presentan algunos ejemplos:

\begin{itemize}
    \item \texttt{SUBSTR(cadena, inicio, longitud)}: Retorna una subcadena de una cadena dada. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    subcadena VARCHAR2(20);
BEGIN
    subcadena := SUBSTR(cadena, 1, 5);
    dbms_output.put_line('Subcadena: ' || subcadena);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{LENGTH(cadena)}: Retorna la longitud de una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    longitud NUMBER;
BEGIN
    longitud := LENGTH(cadena);
    dbms_output.put_line('Longitud: ' || longitud);
    -- Resto del codigo...
END;
\end{lstlisting}

    \item \texttt{UPPER(cadena)}: Convierte una cadena a mayúsculas. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    cadena_mayusculas VARCHAR2(50);
BEGIN
    cadena_mayusculas := UPPER(cadena);
    dbms_output.put_line('Cadena en mayusculas: ' || cadena_mayusculas);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{LOWER(cadena)}: Convierte una cadena a minúsculas. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    cadena_minusculas VARCHAR2(50);
BEGIN
    cadena_minusculas := LOWER(cadena);
    dbms_output.put_line('Cadena en minusculas: ' || cadena_minusculas);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{INSTR(cadena, subcadena)}: Encuentra la posición de una subcadena dentro de una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    posicion NUMBER;
BEGIN
    posicion := INSTR(cadena, 'World');
    dbms_output.put_line('Posicion de "World": ' || posicion);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{REPLACE(cadena, subcadena, nueva\_subcadena)}: Reemplaza todas las ocurrencias de una subcadena por otra en una cadena. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := 'Hello, World!';
    nueva_cadena VARCHAR2(50);
BEGIN
    nueva_cadena := REPLACE(cadena, 'World', 'Mundo');
    dbms_output.put_line('Cadena modificada: ' || nueva_cadena);
    -- Resto del codigo...
END;
\end{lstlisting}
 
    \item \texttt{TRIM(cadena)}, \texttt{LTRIM(cadena)}, \texttt{RTRIM(cadena)}: Estas funciones se utilizan para eliminar caracteres de una cadena, a la iquierda o derecha respectivamente. Ejemplo:
\begin{lstlisting}
DECLARE
    cadena VARCHAR2(50) := '   Hola, Mundo!   ';
    cadena_sin_espacios VARCHAR2(50);
BEGIN
    cadena_sin_espacios := TRIM(cadena);
    dbms_output.put_line('Cadena sin espacios: ' || cadena_sin_espacios);
    -- Resto del codigo...
END;
\end{lstlisting}
 \end{itemize}

\subsection{Condicionales y bucles}

En PL/SQL, los condicionales y los bucles son fundamentales para controlar el flujo de ejecución de un programa. Permiten tomar decisiones y repetir tareas de manera eficiente.

\subsubsection*{Condicionales}

En PL/SQL, se utiliza la estructura \texttt{IF-THEN-ELSE} para evaluar una condición y ejecutar diferentes bloques de código según el resultado. A continuación se muestra un ejemplo:

\begin{lstlisting}
DECLARE
   edad NUMBER := 18;
BEGIN
   IF edad >= 18 THEN
      dbms_output.put_line('Eres mayor de edad');
   ELSE
      dbms_output.put_line('Eres menor de edad');
   END IF;
END;
\end{lstlisting}

En este ejemplo, se evalúa la variable \texttt{edad} y se muestra un mensaje según el resultado.

\subsubsection*{Condicional CASE}

El condicional \texttt{CASE} en PL/SQL es una estructura de control que permite evaluar una expresión y tomar decisiones basadas en su valor. Proporciona una alternativa a la estructura \texttt{IF-THEN-ELSE} y es especialmente útil cuando se tienen múltiples condiciones a evaluar.

La sintaxis básica del condicional \texttt{CASE} es la siguiente:

\begin{lstlisting}
CASE expresion
   WHEN valor1 THEN
      -- Codigo a ejecutar cuando la expresion es igual a valor1
   WHEN valor2 THEN
      -- Codigo a ejecutar cuando la expresion es igual a valor2
   ...
   ELSE
      -- Codigo a ejecutar cuando la expresion no coincide con ninguno de los valores anteriores
END CASE;
\end{lstlisting}

En este caso, \texttt{expresion} es la expresión que se evalúa y \texttt{valor1}, \texttt{valor2}, etc., son los valores posibles que se comparan con la expresión. El bloque de código correspondiente se ejecutará cuando la expresión coincida con uno de los valores especificados.

A continuación, se muestra un ejemplo de uso del condicional \texttt{CASE} en PL/SQL:

\begin{lstlisting}
DECLARE
   nota NUMBER := 80;
BEGIN
   CASE nota
      WHEN 90 THEN
         DBMS_OUTPUT.PUT_LINE('Excelente');
      WHEN 80 THEN
         DBMS_OUTPUT.PUT_LINE('Bueno');
      WHEN 70 THEN
         DBMS_OUTPUT.PUT_LINE('Aceptable');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Reprobado');
   END CASE;
END;
\end{lstlisting}

En este ejemplo, la variable \texttt{nota} se evalúa y se ejecuta el código correspondiente según el valor de la nota. Si la nota es 90, se mostrará \enquote*{Excelente}; si es 80, se mostrará \enquote*{Bueno}; si es 70, se mostrará \enquote*{Aceptable}; y en cualquier otro caso, se mostrará \enquote*{Reprobado}.

El condicional \texttt{CASE} también permite el uso de condiciones adicionales utilizando la cláusula \texttt{WHEN-THEN}:

\begin{lstlisting}
DECLARE
   nota NUMBER := 75;
BEGIN
   CASE
      WHEN nota >= 90 THEN
         DBMS_OUTPUT.PUT_LINE('Excelente');
      WHEN nota >= 80 THEN
         DBMS_OUTPUT.PUT_LINE('Bueno');
      WHEN nota >= 70 THEN
         DBMS_OUTPUT.PUT_LINE('Aceptable');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Reprobado');
   END CASE;
END;
\end{lstlisting}

En este caso, no se especifica una expresión en el \texttt{CASE}, pero se utilizan condiciones para evaluar la variable \texttt{nota} y ejecutar el código correspondiente.

\subsubsection*{Bucles}

En PL/SQL, los bucles permiten repetir tareas y controlar el flujo de ejecución. Veamos algunos tipos de bucles comunes:

\subsubsection*{Bucle LOOP}
El bucle \texttt{LOOP} es un bucle infinito que se repite hasta que se encuentra una instrucción de salida. Puedes utilizar la instrucción \texttt{EXIT} para salir del bucle. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   contador NUMBER := 1;
BEGIN
   LOOP
      dbms_output.put_line('Contador: ' || contador);
      contador := contador + 1;
      
      IF contador > 5 THEN
         EXIT; -- Sale del bucle
      END IF;
   END LOOP;
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{LOOP} para mostrar el valor del contador y se sale del bucle cuando el contador supera 5.

\subsubsection*{Bucle WHILE}
El bucle \texttt{WHILE} se repite mientras se cumpla una condición especificada. El bucle sigue ejecutándose siempre que la condición sea verdadera. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   contador NUMBER := 1;
BEGIN
   WHILE contador <= 5 LOOP
      dbms_output.put_line('Contador: ' || contador);
      contador := contador + 1;
   END LOOP;
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{WHILE} para mostrar el valor del contador y se repite mientras el contador sea menor o igual a 5.

\subsubsection*{Bucle FOR}
El bucle \texttt{FOR} se utiliza para recorrer un conjunto de valores en un rango o una lista. Puedes especificar un rango de valores utilizando \texttt{INICIO..FIN} o proporcionar una lista separada por comas de valores. Aquí tienes un ejemplo:

\begin{lstlisting}
DECLARE
   total NUMBER := 0;
BEGIN
   FOR i IN 1..5 LOOP
      total := total + i;
   END LOOP;
   
   dbms_output.put_line('Total: ' || total);
END;
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{FOR} para sumar los números del 1 al 5 y se muestra el resultado final.

La principal diferencia entre los bucles LOOP y WHILE radica en cómo se controla la condición de finalización: en el caso del bucle LOOP, se controla internamente dentro del bucle, mientras que en el bucle WHILE, se evalúa antes de cada iteración. El bucle FOR se utiliza específicamente para iterar sobre colecciones de elementos, como cursores o conjuntos de registros.

Es importante tener cuidado con los bucles que no paran. Si un bucle no tiene una instrucción de salida o una condición de finalización que se cumpla, se producirá lo que se conoce como un \enquote*{bucle infinito}. En ese caso, el bucle se ejecutará continuamente sin detenerse, lo que puede llevar a problemas como un uso excesivo de recursos del sistema y un bloqueo del programa. Los bucles infinitos son un error común en la programación y deben evitarse. Si accidentalmente creas un bucle infinito, es posible que debas detener la ejecución del programa manualmente o reiniciar el entorno de ejecución

En PL/SQL, es posible anidar condicionales y bucles, lo que permite realizar estructuras de control más complejas y flexibles. A continuación, se presentan ejemplos prácticos de condicionales y bucles anidados:

\subsubsection*{Condicionales anidados}

Los condicionales anidados permiten evaluar múltiples condiciones y ejecutar diferentes bloques de código en función de los resultados. Aquí tienes un ejemplo que determina la calificación de un estudiante en base a su nota:

\begin{lstlisting}
DECLARE
   nota NUMBER := 85;
BEGIN
   IF nota >= 90 THEN
      dbms_output.put_line('Calificacion: A');
   ELSIF nota >= 80 THEN
      dbms_output.put_line('Calificacion: B');
   ELSIF nota >= 70 THEN
      dbms_output.put_line('Calificacion: C');
   ELSE
      dbms_output.put_line('Calificacion: D');
   END IF;
   -- Resto del codigo...
END;
/
\end{lstlisting}

En este ejemplo, se evalúa la nota del estudiante y se imprime la calificación correspondiente utilizando condicionales anidados.

\subsubsection*{Bucles anidados}

Los bucles anidados permiten iterar sobre múltiples conjuntos de datos. Aquí tienes un ejemplo de un bucle \texttt{FOR} anidado que genera una tabla de multiplicación:

\begin{lstlisting}
DECLARE
   limite_filas NUMBER := 5;
   limite_columnas NUMBER := 5;
BEGIN
   FOR i IN 1..limite_filas LOOP
      FOR j IN 1..limite_columnas LOOP
         dbms_output.put(i*j || ' ');
      END LOOP;
      dbms_output.new_line;
   END LOOP;
   -- Resto del codigo...
END;
/
\end{lstlisting}

En este ejemplo, se utiliza un bucle \texttt{FOR} anidado para generar una tabla de multiplicación con el límite de filas y columnas especificado.

Los condicionales y bucles anidados brindan flexibilidad para controlar el flujo de ejecución en situaciones más complejas. Puedes combinarlos y ajustarlos según tus necesidades para lograr la lógica deseada en tu programa.

Recuerda que estos son solo ejemplos básicos, y puedes adaptarlos y expandirlos según tus requerimientos específicos.

\subsection{Matrices (Arrays)}

En PL/SQL, las matrices se pueden representar utilizando tipos de datos de matriz, como \texttt{VARRAY} (Variable Array). Una matriz, también conocida como vector, es una estructura de datos unidimensional que puede contener un conjunto de elementos del mismo tipo.

\subsubsection*{Introducción a las matrices}

Para declarar una matriz en PL/SQL, se utiliza la siguiente sintaxis:

\begin{lstlisting}
DECLARE
   TYPE matriz_t IS VARRAY(n) OF tipo_dato;
   matriz matriz_t := matriz_t(elemento1, elemento2, ..., elementon);
BEGIN
   -- Resto del codigo
END;
\end{lstlisting}

Donde:
\begin{itemize}
   \item \texttt{matriz\_t}: es el tipo de dato de la matriz.
   \item \texttt{n}: es el tamaño máximo de la matriz (número de elementos).
   \item \texttt{tipo\_dato}: es el tipo de dato de los elementos de la matriz.
   \item \texttt{matriz}: es el nombre de la matriz.
   \item \texttt{elemento1, elemento2, ..., elementon}: son los elementos que se asignarán a la matriz durante la inicialización.
\end{itemize}

A continuación, se muestra un ejemplo de declaración e inicialización de una matriz de números en PL/SQL:

\begin{lstlisting}
DECLARE
   TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
   numeros matriz_numeros := matriz_numeros(1, 2, 3, 4, 5);
BEGIN
   -- Resto del codigo
END;
\end{lstlisting}

\subsubsection*{Acceso a una matriz}

Los elementos de una matriz se pueden acceder utilizando el nombre de la matriz seguido de un índice entre paréntesis. El índice indica la posición del elemento en la matriz, comenzando desde 1.

A continuación, se muestra un ejemplo de acceso a los elementos de una matriz en PL/SQL:

\begin{lstlisting}
DECLARE
   TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
   numeros matriz_numeros := matriz_numeros(1, 2, 3, 4, 5);
   elemento NUMBER;
BEGIN
   elemento := numeros(3); -- Acceso al elemento en la posicion 3
   DBMS_OUTPUT.PUT_LINE('Elemento: ' || elemento);
END;
\end{lstlisting}

\subsubsection*{Operaciones con matrices}

En PL/SQL, se pueden realizar diversas operaciones con matrices, como actualización de elementos, obtención del tamaño de la matriz, iteración sobre los elementos y concatenación de matrices. A continuación, se presentan algunos ejemplos de estas operaciones:

\begin{itemize}
   \item \textbf{Actualización de elementos de una matriz}:

\begin{lstlisting}
DECLARE
    TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
    numeros matriz_numeros := matriz_numeros(1, 2, 3, 4, 5);
BEGIN
    numeros(3) := 10; -- Actualizacion del elemento en la posicion 3
    -- Resto del codigo
END;
\end{lstlisting}

   \item \textbf{Obtención del tamaño de una matriz}:

\begin{lstlisting}
DECLARE
    TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
    numeros matriz_numeros := matriz_numeros(1, 2, 3, 4, 5);
    total_elementos INTEGER;
BEGIN
    total_elementos := numeros.COUNT; -- Obtener la cantidad de elementos en la matriz
    DBMS_OUTPUT.PUT_LINE('Total de elementos: ' || total_elementos);
END;
\end{lstlisting}

   \item \textbf{Iteración sobre los elementos de una matriz}:

\begin{lstlisting}
DECLARE
    TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
    numeros matriz_numeros := matriz_numeros(1, 2, 3, 4, 5);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Elementos de la matriz:');
    FOR i IN 1..numeros.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Elemento ' || i || ': ' || numeros(i));
    END LOOP;
END;
\end{lstlisting}

   \item \textbf{Concatenación de matrices}:

\begin{lstlisting}
DECLARE
    TYPE matriz_numeros IS VARRAY(5) OF NUMBER;
    numeros1 matriz_numeros := matriz_numeros(1, 2, 3);
    numeros2 matriz_numeros := matriz_numeros(4, 5);
    numeros_concat matriz_numeros;
BEGIN
    numeros_concat := numeros1 || numeros2; -- Concatenacion de las matrices numeros1 y numeros2
    -- Resto del codigo
END;
\end{lstlisting}

\end{itemize}

Estos ejemplos muestran algunas de las operaciones más comunes que se pueden realizar con matrices en PL/SQL. Puedes adaptar y combinar estas operaciones según tus necesidades específicas.

Recuerda que la sintaxis y las funciones específicas pueden variar dependiendo de la versión de Oracle y de las características soportadas.

\subsection{Funciones}

Las funciones en PL/SQL son subprogramas que realizan un cálculo o una operación y devuelven un valor. Pueden tener parámetros de entrada y/o de salida, lo que les permite aceptar valores proporcionados al llamar a la función y retornar un resultado al finalizar su ejecución.

\subsubsection*{Parámetros de entrada}

Los parámetros de entrada de una función son utilizados para pasar valores desde el código que llama a la función hacia el interior de la función. Estos valores son utilizados dentro de la función para realizar cálculos u operaciones. Los parámetros de entrada se definen en la declaración de la función y deben especificar su tipo de datos.

A continuación, se muestra un ejemplo de una función con parámetros de entrada:

\begin{lstlisting}
CREATE OR REPLACE FUNCTION calcular_area_circulo(radio IN NUMBER) RETURN NUMBER IS
   area NUMBER;
BEGIN
   area := 3.14159 * radio * radio;
   RETURN area;
END;
\end{lstlisting}

En este ejemplo, la función \texttt{calcular\_area\_circulo} acepta un parámetro de entrada llamado \texttt{radio} de tipo \texttt{NUMBER}. Dentro de la función, se utiliza este parámetro para calcular el área de un círculo y se devuelve el resultado.

\subsubsection*{Parámetros de salida}

Los parámetros de salida de una función son utilizados para devolver valores desde la función hacia el código que la llama. Estos valores son definidos y asignados dentro de la función y luego son retornados al finalizar su ejecución. Los parámetros de salida se definen en la declaración de la función utilizando la cláusula \texttt{RETURN}.

A continuación, se muestra un ejemplo de una función con parámetros de salida:

\begin{lstlisting}
CREATE OR REPLACE FUNCTION obtener_saludo(nombre IN VARCHAR2) RETURN VARCHAR2 IS
   saludo VARCHAR2(50);
BEGIN
   saludo := 'Hola, ' || nombre || '!';
   RETURN saludo;
END;
\end{lstlisting}

En este ejemplo, la función \texttt{obtener\_saludo} acepta un parámetro de entrada llamado \texttt{nombre} de tipo \texttt{VARCHAR2} y devuelve un saludo personalizado utilizando ese nombre.

\subsubsection*{Ejemplos}

A continuación, se presentan ejemplos de funciones que combinan parámetros de entrada y salida:

\begin{lstlisting}
CREATE OR REPLACE FUNCTION calcular_promedio(numeros IN matriz_numeros) RETURN NUMBER IS
   suma NUMBER := 0;
   promedio NUMBER;
BEGIN
   FOR i IN 1..numeros.COUNT LOOP
      suma := suma + numeros(i);
   END LOOP;
   
   promedio := suma / numeros.COUNT;
   RETURN promedio;
END;

CREATE OR REPLACE FUNCTION obtener_persona(id IN NUMBER) RETURN persona IS
   p persona;
BEGIN
   SELECT * INTO p FROM personas WHERE persona_id = id;
   RETURN p;
END;
\end{lstlisting}

En el primer ejemplo, la función \texttt{calcular\_promedio} recibe una matriz de números como parámetro de entrada y calcula el promedio de esos números. Devuelve el promedio como resultado.

En el segundo ejemplo, la función \texttt{obtener\_persona} recibe un ID como parámetro de entrada y busca en una tabla de personas el registro correspondiente a ese ID. Retorna el registro de persona encontrado.

\subsection{Procedimientos Almacenados en SQL}

Un procedimiento almacenado es una colección de instrucciones SQL que se guarda en el servidor de base de datos y se puede invocar para realizar operaciones específicas. Proporciona una forma conveniente de ejecutar tareas sin tener que volver a escribir el código SQL cada vez.

La sintaxis básica para crear un procedimiento almacenado es la siguiente:

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE nombre_procedimiento (parametros)
AS
BEGIN
-- Cuerpo del procedimiento (instrucciones SQL)
END;
\end{lstlisting}

Los parámetros son valores opcionales que se pueden pasar al procedimiento para su procesamiento. Pueden ser de entrada, salida o ambos.

A continuación, se presentan algunos ejemplos prácticos de procedimientos almacenados en SQL:

\subsubsection*{Ejemplo 1: Procedimiento para insertar un nuevo registro}

Supongamos que tenemos una tabla \enquote*{Empleados} con las siguientes columnas: ID, Nombre y Salario. Queremos crear un procedimiento almacenado para insertar un nuevo empleado en la tabla.

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE insertar_empleado(
p_ID INT,
p_Nombre VARCHAR(100),
p_Salario DECIMAL(10,2))
AS
BEGIN
INSERT INTO Empleados (ID, Nombre, Salario)
VALUES (p_ID, p_Nombre, p_Salario);
END;
\end{lstlisting}

En este ejemplo, el procedimiento almacenado \lstinline{insertar_empleado} toma tres parámetros de entrada: p\_ID, p\_Nombre y p\_Salario. Luego, ejecuta una instrucción \lstinline{INSERT} para agregar un nuevo empleado a la tabla \enquote*{Empleados} con los valores proporcionados.

Para llamar a este procedimiento almacenado, se puede utilizar la siguiente sentencia:

\begin{lstlisting}
EXECUTE insertar_empleado(1, 'John Doe', 5000.00);
\end{lstlisting}

Esto insertará un nuevo registro en la tabla \enquote*{Empleados} con el ID 1, el nombre \enquote*{John Doe} y un salario de 5000.00.

\subsubsection*{Ejemplo 2: Procedimiento para actualizar el salario de un empleado}

Supongamos que queremos crear un procedimiento almacenado para actualizar el salario de un empleado en la tabla "Empleados" basado en su ID.

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE actualizar_salario_empleado(
p_ID INT,
p_NuevoSalario DECIMAL(10,2))
AS
BEGIN
UPDATE Empleados
SET Salario = p_NuevoSalario
WHERE ID = p_ID;
END;
\end{lstlisting}

En este ejemplo, el procedimiento almacenado \lstinline{actualizar_salario_empleado} toma dos parámetros de entrada: p\_ID y p\_NuevoSalario. Luego, ejecuta una instrucción \lstinline{UPDATE} para modificar el salario de un empleado en la tabla \enquote*{Empleados} con el ID correspondiente.

Para llamar a este procedimiento almacenado, se puede utilizar la siguiente sentencia:

\begin{lstlisting}
EXECUTE actualizar_salario_empleado(1, 6000.00);
\end{lstlisting}

Esto actualizará el salario del empleado con ID 1 a 6000.00 en la tabla \enquote*{Empleados}.

\subsubsection*{Ejemplo 3: Procedimiento para eliminar un empleado}

Supongamos que queremos crear un procedimiento almacenado para eliminar un empleado de la tabla \enquote*{Empleados} basado en su ID.

\begin{lstlisting}
CREATE OR REPLACE PROCEDURE eliminar_empleado(
p_ID INT)
AS
BEGIN
DELETE FROM Empleados
WHERE ID = p_ID;
END;
\end{lstlisting}

En este ejemplo, el procedimiento almacenado \lstinline{"eliminar_empleado"} toma un parámetro de entrada: p\_ID. Luego, ejecuta una instrucción DELETE para eliminar un empleado de la tabla \enquote*{Empleados} con el ID correspondiente.

Para llamar a este procedimiento almacenado, se puede utilizar la siguiente sentencia:

\begin{lstlisting}
EXECUTE eliminar_empleado(1);
\end{lstlisting}

Esto eliminará el empleado con ID 1 de la tabla "Empleados".

Los procedimientos almacenados son útiles para encapsular lógica compleja de base de datos, mejorar el rendimiento, reutilizar código y mantener la integridad de los datos. Se pueden llamar desde aplicaciones o incluso desde otros procedimientos almacenados.

\subsection{Triggers}

Un trigger es un objeto de base de datos que se asocia con una tabla y se dispara automáticamente cuando ocurre un evento en la tabla, como una operación de inserción, actualización o eliminación. Los triggers permiten ejecutar acciones personalizadas antes o después de que ocurra un evento en la tabla.

La sintaxis básica para crear un trigger es la siguiente:

\begin{lstlisting}
CREATE OR REPLACE TRIGGER nombre_trigger
{BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON nombre_tabla
[FOR EACH ROW]
BEGIN
-- Cuerpo del trigger (instrucciones PL/SQL)
END;
\end{lstlisting}

El disparador se puede configurar para ejecutarse antes o después de un evento (\lstinline{BEFORE o AFTER}), y se especifica qué tipo de evento desencadenará el trigger (\lstinline{INSERT, UPDATE o DELETE}). Además, se puede agregar la cláusula opcional \lstinline{FOR EACH ROW} para indicar que el trigger se ejecutará una vez por cada fila afectada por el evento.

A continuación, se muestra un ejemplo de trigger que invoca el procedimiento almacenado \texttt{insert\_cliente\_control} después de cada inserción en la tabla \texttt{Cliente}:

\begin{lstlisting}
CREATE OR REPLACE TRIGGER tr_insert_cliente
AFTER INSERT ON Cliente
FOR EACH ROW
BEGIN
insert_cliente_control(:new.strNumeroIdentificacion, :new.strNombre || ' ' || :new.strApellido);
END;
\end{lstlisting}

En este ejemplo, el trigger \texttt{tr\_insert\_cliente} se ejecutará después de cada inserción en la tabla \texttt{Cliente}. Utiliza la pseudo-variable \texttt{:new} para acceder a los valores de la nueva fila insertada y los pasa como argumentos al procedimiento almacenado \texttt{insert\_cliente\_control}.

\subsubsection*{Ejemplo de Uso}

A continuación, se muestra un ejemplo completo que combina la creación de la tabla \texttt{ClienteInformacion}, el procedimiento almacenado \texttt{insert\_cliente\_control} y el trigger \texttt{tr\_insert\_cliente}:

\begin{lstlisting}
CREATE TABLE ClienteInformacion (
Identificacion VARCHAR(20) PRIMARY KEY,
NombreCompleto VARCHAR(100),
FechaRegistro DATE,
FechaUltimaActualizacion DATE
);

CREATE OR REPLACE PROCEDURE insert_cliente_control(
Identificacion IN VARCHAR,
NombreCompleto IN VARCHAR)
AS
BEGIN
INSERT INTO ClienteInformacion VALUES (Identificacion, NombreCompleto, SYSDATE, SYSDATE);
END;

CREATE OR REPLACE TRIGGER tr_insert_cliente
AFTER INSERT ON Cliente
FOR EACH ROW
BEGIN
insert_cliente_control(:new.strNumeroIdentificacion, :new.strNombre || ' ' || :new.strApellido);
END;

INSERT INTO Cliente (strTipoIdentificacion, strNumeroIdentificacion, strNombre, strApellido, strEmail)
VALUES ('cedula', '1111', 'El kakas', 'kakasNet', 'kakasNet@gmail.com');

SELECT * FROM ClienteInformacion;
\end{lstlisting}

En este ejemplo, se crea la tabla \texttt{ClienteInformacion} con las columnas requeridas. Luego, se define el procedimiento almacenado \texttt{insert\_cliente\_control}, que inserta un nuevo registro en la tabla \texttt{ClienteInformacion}. Después, se crea el trigger \texttt{tr\_insert\_cliente}, que invoca el procedimiento almacenado después de cada inserción en la tabla \texttt{Cliente}. Finalmente, se realiza una inserción en la tabla \texttt{Cliente} y se muestra el contenido de la tabla \texttt{ClienteInformacion} para verificar los resultados.

Los triggers son una herramienta poderosa en SQL que permiten automatizar tareas y ejecutar lógica personalizada en respuesta a eventos en las tablas. Pueden ser utilizados para mantener la integridad de los datos, auditar cambios, aplicar reglas de negocio y mucho más. Es importante tener en cuenta las implicaciones de rendimiento y la correcta gestión de los eventos que desencadenan los triggers para asegurar un funcionamiento óptimo de la base de datos.
\end{document}